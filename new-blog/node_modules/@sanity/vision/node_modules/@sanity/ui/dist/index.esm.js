var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14, _templateObject15, _templateObject16, _templateObject17, _templateObject18, _templateObject19, _templateObject20, _templateObject21, _templateObject22, _templateObject23, _templateObject24, _templateObject25, _templateObject26, _templateObject27, _templateObject28, _templateObject29, _templateObject30, _templateObject31, _templateObject32, _templateObject33, _templateObject34, _templateObject35, _templateObject36, _templateObject37, _templateObject38, _templateObject39, _templateObject40, _templateObject41, _templateObject42, _templateObject43, _templateObject44, _templateObject45, _templateObject46, _templateObject47, _templateObject48, _templateObject49, _templateObject50, _templateObject51, _templateObject52, _templateObject53, _templateObject54, _templateObject55, _templateObject56, _templateObject57, _templateObject58, _templateObject59, _templateObject60, _templateObject61, _templateObject62, _templateObject63, _templateObject64, _templateObject65, _templateObject66, _templateObject67, _templateObject68, _templateObject69, _templateObject70, _templateObject71, _templateObject72, _templateObject73, _templateObject74, _templateObject75, _templateObject76, _templateObject77, _templateObject78, _templateObject79, _templateObject80, _templateObject81, _templateObject82, _templateObject83, _templateObject84, _templateObject85, _templateObject86, _templateObject87, _templateObject88, _templateObject89, _templateObject90;
function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import { useMemo, useState, useRef, useEffect, createContext, useContext, useSyncExternalStore, useLayoutEffect, forwardRef, useId, useCallback, cloneElement, isValidElement, createElement, Component, memo, useReducer, Children, Fragment as Fragment$1, startTransition } from 'react';
import ReactIs, { isElement as isElement$1, isFragment, isValidElementType } from 'react-is';
import styled, { ThemeProvider as ThemeProvider$1, useTheme as useTheme$1, css, keyframes } from 'styled-components';
import { white as white$1, black as black$1, hues } from '@sanity/color';
import { SpinnerIcon, CheckmarkIcon, RemoveIcon, SelectIcon, CloseIcon, ChevronDownIcon, ChevronRightIcon, ToggleArrowRightIcon } from '@sanity/icons';
import Refractor from 'react-refractor';
import { detectOverflow, flip, offset, shift, arrow, hide, autoUpdate, useFloating } from '@floating-ui/react-dom';
import { createPortal } from 'react-dom';
import { AnimatePresence, motion } from 'framer-motion';
const EMPTY_ARRAY = [];
const EMPTY_RECORD = {};
const FLOATING_STATIC_SIDES = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
function _fillCSSObject(keys, value) {
  return keys.reduce((style, key) => {
    style[key] = value;
    return style;
  }, {});
}
function rem(pixelValue) {
  if (pixelValue === 0) return 0;
  return "".concat(pixelValue / 16, "rem");
}
function _responsive(media, values, callback) {
  const statements = (values == null ? void 0 : values.map(callback)) || [];
  return statements.map((statement, mediaIndex) => {
    if (mediaIndex === 0) return statement;
    return {
      ["@media screen and (min-width: ".concat(media[mediaIndex - 1], "px)")]: statement
    };
  });
}
function _getArrayProp(val, defaultVal) {
  if (val === void 0) return defaultVal || EMPTY_ARRAY;
  return Array.isArray(val) ? val : [val];
}
function _getResponsiveSpace(theme, props) {
  let spaceIndexes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EMPTY_ARRAY;
  if (!Array.isArray(spaceIndexes)) {
    throw new Error("the property must be array of numbers");
  }
  if (spaceIndexes.length === 0) {
    return null;
  }
  return _responsive(theme.sanity.media, spaceIndexes, spaceIndex => _fillCSSObject(props, rem(theme.sanity.space[spaceIndex])));
}
function responsiveFont(fontKey, props) {
  const {
    $size,
    $weight,
    theme
  } = props;
  const {
    fonts,
    media
  } = theme.sanity;
  const {
    family,
    sizes,
    weights
  } = fonts[fontKey];
  const fontWeight = $weight && weights[$weight] || weights.regular;
  const defaultSize = sizes[2];
  const base = {
    position: "relative",
    fontFamily: family,
    fontWeight,
    padding: "1px 0",
    margin: 0,
    "&:before": {
      content: '""',
      display: "block",
      height: 0
    },
    "&:after": {
      content: '""',
      display: "block",
      height: 0
    },
    "& > code, & > span": {
      display: "block"
    },
    "&:not([hidden])": {
      display: "block"
    }
  };
  if (!$size) {
    if (!responsiveFont.warned) {
      console.warn("No size specified for responsive font", {
        fontKey,
        $size,
        props,
        base
      });
      responsiveFont.warned = true;
    }
    return [base];
  }
  const resp = _responsive(media, $size, sizeIndex => fontSize(sizes[sizeIndex] || defaultSize));
  return [base, ...resp];
}
function fontSize(size) {
  const {
    ascenderHeight,
    descenderHeight,
    fontSize: fontSize2,
    iconSize,
    letterSpacing,
    lineHeight
  } = size;
  const negHeight = ascenderHeight + descenderHeight;
  const capHeight = lineHeight - negHeight;
  const iconOffset = (capHeight - iconSize) / 2;
  const customIconSize = Math.floor(fontSize2 * 1.125 / 2) * 2 + 1;
  const customIconOffset = (capHeight - customIconSize) / 2;
  return {
    fontSize: rem(fontSize2),
    lineHeight: "calc(".concat(lineHeight, " / ").concat(fontSize2, ")"),
    letterSpacing: rem(letterSpacing),
    transform: "translateY(".concat(rem(descenderHeight), ")"),
    "&:before": {
      marginTop: "calc(".concat(rem(0 - negHeight), " - 1px)")
    },
    "&:after": {
      marginBottom: "-1px"
    },
    "& svg:not([data-sanity-icon])": {
      fontSize: "calc(".concat(customIconSize, " / 16 * 1rem)"),
      margin: rem(customIconOffset)
    },
    "& [data-sanity-icon]": {
      fontSize: "calc(".concat(iconSize, " / 16 * 1rem)"),
      margin: rem(iconOffset)
    }
  };
}
function responsiveCodeFontStyle(props) {
  return responsiveFont("code", props);
}
function responsiveHeadingFont(props) {
  return responsiveFont("heading", props);
}
function responsiveLabelFont(props) {
  return responsiveFont("label", props);
}
function responsiveTextAlignStyle(props) {
  const {
    theme
  } = props;
  return _responsive(theme.sanity.media, props.$align, textAlign => {
    return {
      textAlign
    };
  });
}
function responsiveTextFont(props) {
  return responsiveFont("text", props);
}
function useArrayProp(val, defaultVal) {
  const __perf_hash__ = useMemo(() => JSON.stringify(val != null ? val : defaultVal), [defaultVal, val]);
  return useMemo(() => _getArrayProp(val, defaultVal),
  // Improve performance: Keep object identify for a given hash of the value
  // eslint-disable-next-line react-hooks/exhaustive-deps
  [__perf_hash__]);
}
function _getElements(element, elementsArg) {
  const ret = [element];
  for (const el of elementsArg) {
    if (Array.isArray(el)) {
      ret.push(...el);
    } else {
      ret.push(el);
    }
  }
  return ret.filter(Boolean);
}
function useClickOutside(listener) {
  let elementsArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EMPTY_ARRAY;
  let boundaryElement = arguments.length > 2 ? arguments[2] : undefined;
  const [element, setElement] = useState(null);
  const [elements, setElements] = useState(() => _getElements(element, elementsArg));
  const elementsRef = useRef(elements);
  useEffect(() => {
    const prevElements = elementsRef.current;
    const nextElements = _getElements(element, elementsArg);
    if (prevElements.length !== nextElements.length) {
      setElements(nextElements);
      elementsRef.current = nextElements;
      return;
    }
    for (const el of prevElements) {
      if (!nextElements.includes(el)) {
        setElements(nextElements);
        elementsRef.current = nextElements;
        return;
      }
    }
    for (const el of nextElements) {
      if (!prevElements.includes(el)) {
        setElements(nextElements);
        elementsRef.current = nextElements;
        return;
      }
    }
  }, [element, elementsArg]);
  useEffect(() => {
    if (!listener) return void 0;
    const handleWindowMouseDown = evt => {
      const target = evt.target;
      if (!(target instanceof Node)) {
        return;
      }
      if (boundaryElement && !boundaryElement.contains(target)) {
        return;
      }
      for (const el of elements) {
        if (target === el || el.contains(target)) {
          return;
        }
      }
      listener(evt);
    };
    window.addEventListener("mousedown", handleWindowMouseDown);
    return () => {
      window.removeEventListener("mousedown", handleWindowMouseDown);
    };
  }, [boundaryElement, listener, elements]);
  return setElement;
}
var resizeObservers = [];
var hasActiveObservations = function () {
  return resizeObservers.some(function (ro) {
    return ro.activeTargets.length > 0;
  });
};
var hasSkippedObservations = function () {
  return resizeObservers.some(function (ro) {
    return ro.skippedTargets.length > 0;
  });
};
var msg = 'ResizeObserver loop completed with undelivered notifications.';
var deliverResizeLoopError = function () {
  var event;
  if (typeof ErrorEvent === 'function') {
    event = new ErrorEvent('error', {
      message: msg
    });
  } else {
    event = document.createEvent('Event');
    event.initEvent('error', false, false);
    event.message = msg;
  }
  window.dispatchEvent(event);
};
var ResizeObserverBoxOptions;
(function (ResizeObserverBoxOptions) {
  ResizeObserverBoxOptions["BORDER_BOX"] = "border-box";
  ResizeObserverBoxOptions["CONTENT_BOX"] = "content-box";
  ResizeObserverBoxOptions["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));
var freeze = function (obj) {
  return Object.freeze(obj);
};
var ResizeObserverSize = function () {
  function ResizeObserverSize(inlineSize, blockSize) {
    this.inlineSize = inlineSize;
    this.blockSize = blockSize;
    freeze(this);
  }
  return ResizeObserverSize;
}();
var DOMRectReadOnly = function () {
  function DOMRectReadOnly(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.top = this.y;
    this.left = this.x;
    this.bottom = this.top + this.height;
    this.right = this.left + this.width;
    return freeze(this);
  }
  DOMRectReadOnly.prototype.toJSON = function () {
    var _a = this,
      x = _a.x,
      y = _a.y,
      top = _a.top,
      right = _a.right,
      bottom = _a.bottom,
      left = _a.left,
      width = _a.width,
      height = _a.height;
    return {
      x: x,
      y: y,
      top: top,
      right: right,
      bottom: bottom,
      left: left,
      width: width,
      height: height
    };
  };
  DOMRectReadOnly.fromRect = function (rectangle) {
    return new DOMRectReadOnly(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
  };
  return DOMRectReadOnly;
}();
var isSVG = function (target) {
  return target instanceof SVGElement && 'getBBox' in target;
};
var isHidden = function (target) {
  if (isSVG(target)) {
    var _a = target.getBBox(),
      width = _a.width,
      height = _a.height;
    return !width && !height;
  }
  var _b = target,
    offsetWidth = _b.offsetWidth,
    offsetHeight = _b.offsetHeight;
  return !(offsetWidth || offsetHeight || target.getClientRects().length);
};
var isElement = function (obj) {
  var _a;
  if (obj instanceof Element) {
    return true;
  }
  var scope = (_a = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
  return !!(scope && obj instanceof scope.Element);
};
var isReplacedElement = function (target) {
  switch (target.tagName) {
    case 'INPUT':
      if (target.type !== 'image') {
        break;
      }
    case 'VIDEO':
    case 'AUDIO':
    case 'EMBED':
    case 'OBJECT':
    case 'CANVAS':
    case 'IFRAME':
    case 'IMG':
      return true;
  }
  return false;
};
var global$1 = typeof window !== 'undefined' ? window : {};
var cache = new WeakMap();
var scrollRegexp = /auto|scroll/;
var verticalRegexp = /^tb|vertical/;
var IE = /msie|trident/i.test(global$1.navigator && global$1.navigator.userAgent);
var parseDimension = function (pixel) {
  return parseFloat(pixel || '0');
};
var size$1 = function (inlineSize, blockSize, switchSizes) {
  if (inlineSize === void 0) {
    inlineSize = 0;
  }
  if (blockSize === void 0) {
    blockSize = 0;
  }
  if (switchSizes === void 0) {
    switchSizes = false;
  }
  return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
};
var zeroBoxes = freeze({
  devicePixelContentBoxSize: size$1(),
  borderBoxSize: size$1(),
  contentBoxSize: size$1(),
  contentRect: new DOMRectReadOnly(0, 0, 0, 0)
});
var calculateBoxSizes = function (target, forceRecalculation) {
  if (forceRecalculation === void 0) {
    forceRecalculation = false;
  }
  if (cache.has(target) && !forceRecalculation) {
    return cache.get(target);
  }
  if (isHidden(target)) {
    cache.set(target, zeroBoxes);
    return zeroBoxes;
  }
  var cs = getComputedStyle(target);
  var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
  var removePadding = !IE && cs.boxSizing === 'border-box';
  var switchSizes = verticalRegexp.test(cs.writingMode || '');
  var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || '');
  var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || '');
  var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
  var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
  var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
  var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
  var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
  var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
  var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
  var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
  var horizontalPadding = paddingLeft + paddingRight;
  var verticalPadding = paddingTop + paddingBottom;
  var horizontalBorderArea = borderLeft + borderRight;
  var verticalBorderArea = borderTop + borderBottom;
  var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
  var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
  var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
  var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
  var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
  var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
  var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
  var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
  var boxes = freeze({
    devicePixelContentBoxSize: size$1(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
    borderBoxSize: size$1(borderBoxWidth, borderBoxHeight, switchSizes),
    contentBoxSize: size$1(contentWidth, contentHeight, switchSizes),
    contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
  });
  cache.set(target, boxes);
  return boxes;
};
var calculateBoxSize = function (target, observedBox, forceRecalculation) {
  var _a = calculateBoxSizes(target, forceRecalculation),
    borderBoxSize = _a.borderBoxSize,
    contentBoxSize = _a.contentBoxSize,
    devicePixelContentBoxSize = _a.devicePixelContentBoxSize;
  switch (observedBox) {
    case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
      return devicePixelContentBoxSize;
    case ResizeObserverBoxOptions.BORDER_BOX:
      return borderBoxSize;
    default:
      return contentBoxSize;
  }
};
var ResizeObserverEntry = function () {
  function ResizeObserverEntry(target) {
    var boxes = calculateBoxSizes(target);
    this.target = target;
    this.contentRect = boxes.contentRect;
    this.borderBoxSize = freeze([boxes.borderBoxSize]);
    this.contentBoxSize = freeze([boxes.contentBoxSize]);
    this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
  }
  return ResizeObserverEntry;
}();
var calculateDepthForNode = function (node) {
  if (isHidden(node)) {
    return Infinity;
  }
  var depth = 0;
  var parent = node.parentNode;
  while (parent) {
    depth += 1;
    parent = parent.parentNode;
  }
  return depth;
};
var broadcastActiveObservations = function () {
  var shallowestDepth = Infinity;
  var callbacks = [];
  resizeObservers.forEach(function processObserver(ro) {
    if (ro.activeTargets.length === 0) {
      return;
    }
    var entries = [];
    ro.activeTargets.forEach(function processTarget(ot) {
      var entry = new ResizeObserverEntry(ot.target);
      var targetDepth = calculateDepthForNode(ot.target);
      entries.push(entry);
      ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);
      if (targetDepth < shallowestDepth) {
        shallowestDepth = targetDepth;
      }
    });
    callbacks.push(function resizeObserverCallback() {
      ro.callback.call(ro.observer, entries, ro.observer);
    });
    ro.activeTargets.splice(0, ro.activeTargets.length);
  });
  for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {
    var callback = callbacks_1[_i];
    callback();
  }
  return shallowestDepth;
};
var gatherActiveObservationsAtDepth = function (depth) {
  resizeObservers.forEach(function processObserver(ro) {
    ro.activeTargets.splice(0, ro.activeTargets.length);
    ro.skippedTargets.splice(0, ro.skippedTargets.length);
    ro.observationTargets.forEach(function processTarget(ot) {
      if (ot.isActive()) {
        if (calculateDepthForNode(ot.target) > depth) {
          ro.activeTargets.push(ot);
        } else {
          ro.skippedTargets.push(ot);
        }
      }
    });
  });
};
var process = function () {
  var depth = 0;
  gatherActiveObservationsAtDepth(depth);
  while (hasActiveObservations()) {
    depth = broadcastActiveObservations();
    gatherActiveObservationsAtDepth(depth);
  }
  if (hasSkippedObservations()) {
    deliverResizeLoopError();
  }
  return depth > 0;
};
var trigger;
var callbacks = [];
var notify = function () {
  return callbacks.splice(0).forEach(function (cb) {
    return cb();
  });
};
var queueMicroTask = function (callback) {
  if (!trigger) {
    var toggle_1 = 0;
    var el_1 = document.createTextNode('');
    var config = {
      characterData: true
    };
    new MutationObserver(function () {
      return notify();
    }).observe(el_1, config);
    trigger = function () {
      el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
    };
  }
  callbacks.push(callback);
  trigger();
};
var queueResizeObserver = function (cb) {
  queueMicroTask(function ResizeObserver() {
    requestAnimationFrame(cb);
  });
};
var watching = 0;
var isWatching = function () {
  return !!watching;
};
var CATCH_PERIOD = 250;
var observerConfig = {
  attributes: true,
  characterData: true,
  childList: true,
  subtree: true
};
var events = ['resize', 'load', 'transitionend', 'animationend', 'animationstart', 'animationiteration', 'keyup', 'keydown', 'mouseup', 'mousedown', 'mouseover', 'mouseout', 'blur', 'focus'];
var time = function (timeout) {
  if (timeout === void 0) {
    timeout = 0;
  }
  return Date.now() + timeout;
};
var scheduled = false;
var Scheduler = function () {
  function Scheduler() {
    var _this = this;
    this.stopped = true;
    this.listener = function () {
      return _this.schedule();
    };
  }
  Scheduler.prototype.run = function (timeout) {
    var _this = this;
    if (timeout === void 0) {
      timeout = CATCH_PERIOD;
    }
    if (scheduled) {
      return;
    }
    scheduled = true;
    var until = time(timeout);
    queueResizeObserver(function () {
      var elementsHaveResized = false;
      try {
        elementsHaveResized = process();
      } finally {
        scheduled = false;
        timeout = until - time();
        if (!isWatching()) {
          return;
        }
        if (elementsHaveResized) {
          _this.run(1000);
        } else if (timeout > 0) {
          _this.run(timeout);
        } else {
          _this.start();
        }
      }
    });
  };
  Scheduler.prototype.schedule = function () {
    this.stop();
    this.run();
  };
  Scheduler.prototype.observe = function () {
    var _this = this;
    var cb = function () {
      return _this.observer && _this.observer.observe(document.body, observerConfig);
    };
    document.body ? cb() : global$1.addEventListener('DOMContentLoaded', cb);
  };
  Scheduler.prototype.start = function () {
    var _this = this;
    if (this.stopped) {
      this.stopped = false;
      this.observer = new MutationObserver(this.listener);
      this.observe();
      events.forEach(function (name) {
        return global$1.addEventListener(name, _this.listener, true);
      });
    }
  };
  Scheduler.prototype.stop = function () {
    var _this = this;
    if (!this.stopped) {
      this.observer && this.observer.disconnect();
      events.forEach(function (name) {
        return global$1.removeEventListener(name, _this.listener, true);
      });
      this.stopped = true;
    }
  };
  return Scheduler;
}();
var scheduler = new Scheduler();
var updateCount = function (n) {
  !watching && n > 0 && scheduler.start();
  watching += n;
  !watching && scheduler.stop();
};
var skipNotifyOnElement = function (target) {
  return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === 'inline';
};
var ResizeObservation = function () {
  function ResizeObservation(target, observedBox) {
    this.target = target;
    this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
    this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  ResizeObservation.prototype.isActive = function () {
    var size = calculateBoxSize(this.target, this.observedBox, true);
    if (skipNotifyOnElement(this.target)) {
      this.lastReportedSize = size;
    }
    if (this.lastReportedSize.inlineSize !== size.inlineSize || this.lastReportedSize.blockSize !== size.blockSize) {
      return true;
    }
    return false;
  };
  return ResizeObservation;
}();
var ResizeObserverDetail = function () {
  function ResizeObserverDetail(resizeObserver, callback) {
    this.activeTargets = [];
    this.skippedTargets = [];
    this.observationTargets = [];
    this.observer = resizeObserver;
    this.callback = callback;
  }
  return ResizeObserverDetail;
}();
var observerMap = new WeakMap();
var getObservationIndex = function (observationTargets, target) {
  for (var i = 0; i < observationTargets.length; i += 1) {
    if (observationTargets[i].target === target) {
      return i;
    }
  }
  return -1;
};
var ResizeObserverController = function () {
  function ResizeObserverController() {}
  ResizeObserverController.connect = function (resizeObserver, callback) {
    var detail = new ResizeObserverDetail(resizeObserver, callback);
    observerMap.set(resizeObserver, detail);
  };
  ResizeObserverController.observe = function (resizeObserver, target, options) {
    var detail = observerMap.get(resizeObserver);
    var firstObservation = detail.observationTargets.length === 0;
    if (getObservationIndex(detail.observationTargets, target) < 0) {
      firstObservation && resizeObservers.push(detail);
      detail.observationTargets.push(new ResizeObservation(target, options && options.box));
      updateCount(1);
      scheduler.schedule();
    }
  };
  ResizeObserverController.unobserve = function (resizeObserver, target) {
    var detail = observerMap.get(resizeObserver);
    var index = getObservationIndex(detail.observationTargets, target);
    var lastObservation = detail.observationTargets.length === 1;
    if (index >= 0) {
      lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
      detail.observationTargets.splice(index, 1);
      updateCount(-1);
    }
  };
  ResizeObserverController.disconnect = function (resizeObserver) {
    var _this = this;
    var detail = observerMap.get(resizeObserver);
    detail.observationTargets.slice().forEach(function (ot) {
      return _this.unobserve(resizeObserver, ot.target);
    });
    detail.activeTargets.splice(0, detail.activeTargets.length);
  };
  return ResizeObserverController;
}();
var ResizeObserver = function () {
  function ResizeObserver(callback) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (typeof callback !== 'function') {
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    }
    ResizeObserverController.connect(this, callback);
  }
  ResizeObserver.prototype.observe = function (target, options) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement(target)) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.observe(this, target, options);
  };
  ResizeObserver.prototype.unobserve = function (target) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement(target)) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.unobserve(this, target);
  };
  ResizeObserver.prototype.disconnect = function () {
    ResizeObserverController.disconnect(this);
  };
  ResizeObserver.toString = function () {
    return 'function ResizeObserver () { [polyfill code] }';
  };
  return ResizeObserver;
}();
const _ResizeObserver = typeof document !== "undefined" && window.ResizeObserver ? window.ResizeObserver : ResizeObserver;
const _elementSizeObserver = _createElementSizeObserver();
function _createElementRectValueListener() {
  return {
    subscribe(element, subscriber) {
      const resizeObserver = new _ResizeObserver(_ref => {
        let [entry] = _ref;
        subscriber({
          _contentRect: entry.contentRect,
          border: {
            width: entry.borderBoxSize[0].inlineSize,
            height: entry.borderBoxSize[0].blockSize
          },
          content: {
            width: entry.contentRect.width,
            height: entry.contentRect.height
          }
        });
      });
      resizeObserver.observe(element);
      return () => {
        resizeObserver.unobserve(element);
        resizeObserver.disconnect();
      };
    }
  };
}
function _createElementSizeObserver() {
  const disposeCache = /* @__PURE__ */new WeakMap();
  const subscribersCache = /* @__PURE__ */new WeakMap();
  return {
    subscribe(element, subscriber) {
      const subscribers = subscribersCache.get(element) || [];
      let dispose = disposeCache.get(element);
      if (!subscribersCache.has(element)) {
        subscribersCache.set(element, subscribers);
        const listener = _createElementRectValueListener();
        dispose = listener.subscribe(element, elementRect => {
          for (const sub of subscribers) {
            sub(elementRect);
          }
        });
      }
      subscribers.push(subscriber);
      return () => {
        const idx = subscribers.indexOf(subscriber);
        if (idx > -1) {
          subscribers.splice(idx, 1);
        }
        if (subscribers.length === 0) {
          if (dispose) dispose();
        }
      };
    }
  };
}
function useElementSize(element) {
  const [size, setSize] = useState(null);
  useEffect(() => {
    if (!element) return void 0;
    return _elementSizeObserver.subscribe(element, setSize);
  }, [element]);
  return size;
}
function useElementRect(element) {
  const elementSize = useElementSize(element);
  return (elementSize == null ? void 0 : elementSize._contentRect) || null;
}
function useGlobalKeyDown(onKeyDown) {
  return useEffect(() => {
    addEventListener("keydown", onKeyDown);
    return () => removeEventListener("keydown", onKeyDown);
  }, [onKeyDown]);
}
function multiplyChannel(b, s) {
  return b * s;
}
function multiply$1(b, s) {
  return {
    r: Math.round(clamp$1(multiplyChannel(b.r / 255, s.r / 255) * 255)),
    g: Math.round(clamp$1(multiplyChannel(b.g / 255, s.g / 255) * 255)),
    b: Math.round(clamp$1(multiplyChannel(b.b / 255, s.b / 255) * 255))
  };
}
function clamp$1(num) {
  return Math.max(Math.min(num, 255), 0);
}
function screenChannel(b, s) {
  return b + s - b * s;
}
function screen$1(b, s) {
  return {
    r: Math.round(clamp(screenChannel(b.r / 255, s.r / 255) * 255)),
    g: Math.round(clamp(screenChannel(b.g / 255, s.g / 255) * 255)),
    b: Math.round(clamp(screenChannel(b.b / 255, s.b / 255) * 255))
  };
}
function clamp(num) {
  return Math.max(Math.min(num, 255), 0);
}
function hexToRgb(hex) {
  if (hex.length === 4) {
    const hexR = hex.slice(1, 2);
    const hexG = hex.slice(2, 3);
    const hexB = hex.slice(3, 4);
    return {
      r: parseInt(hexR + hexR, 16),
      g: parseInt(hexG + hexG, 16),
      b: parseInt(hexB + hexB, 16)
    };
  }
  return {
    r: parseInt(hex.slice(1, 3), 16),
    g: parseInt(hex.slice(3, 5), 16),
    b: parseInt(hex.slice(5, 7), 16)
  };
}
function rgbToHex(_ref2) {
  let {
    r,
    g,
    b
  } = _ref2;
  return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}
function rgbToHsl(_ref3) {
  let {
    r,
    g,
    b
  } = _ref3;
  r /= 255;
  g /= 255;
  b /= 255;
  const cmin = Math.min(r, g, b);
  const cmax = Math.max(r, g, b);
  const delta = cmax - cmin;
  let h = 0;
  let s = 0;
  let l = 0;
  if (delta == 0) h = 0;else if (cmax == r) h = (g - b) / delta % 6;else if (cmax == g) h = (b - r) / delta + 2;else h = (r - g) / delta + 4;
  h = Math.round(h * 60);
  if (h < 0) h += 360;
  l = (cmax + cmin) / 2;
  s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
  s = +(s * 100).toFixed(1);
  l = +(l * 100).toFixed(1);
  return {
    h,
    s,
    l
  };
}
function hslToRgb(hsl) {
  const s = hsl.s / 100;
  const l = hsl.l / 100;
  const c = (1 - Math.abs(2 * l - 1)) * s;
  const x = c * (1 - Math.abs(hsl.h / 60 % 2 - 1));
  const m = l - c / 2;
  let r = 0;
  let g = 0;
  let b = 0;
  if (0 <= hsl.h && hsl.h < 60) {
    r = c;
    g = x;
    b = 0;
  } else if (60 <= hsl.h && hsl.h < 120) {
    r = x;
    g = c;
    b = 0;
  } else if (120 <= hsl.h && hsl.h < 180) {
    r = 0;
    g = c;
    b = x;
  } else if (180 <= hsl.h && hsl.h < 240) {
    r = 0;
    g = x;
    b = c;
  } else if (240 <= hsl.h && hsl.h < 300) {
    r = x;
    g = 0;
    b = c;
  } else if (300 <= hsl.h && hsl.h < 360) {
    r = c;
    g = 0;
    b = x;
  }
  return {
    r: Math.round((r + m) * 255),
    g: Math.round((g + m) * 255),
    b: Math.round((b + m) * 255)
  };
}
const HEX_CHARS = "0123456789ABCDEFabcdef";
const HSL_RE = /hsl\(\s*(\d+)\s*,\s*((\d+(?:\.\d+)?)%)\s*,\s*((\d+(?:\.\d+)?)%)\s*\)/i;
function isHexChars(str) {
  for (const c of str) {
    if (HEX_CHARS.indexOf(c) === -1) {
      return false;
    }
  }
  return true;
}
function isHex(str) {
  if (str[0] !== "#") return false;
  if (!(str.length === 4 || str.length === 7)) return false;
  return isHexChars(str.slice(1));
}
function parseHsl(str) {
  const res = HSL_RE.exec(str);
  if (!res) {
    throw new Error("parseHsl: string is not a HSL color: \"".concat(str, "\""));
  }
  return {
    h: parseInt(res[1]),
    s: parseFloat(res[3]),
    l: parseFloat(res[5])
  };
}
function parseColor(color) {
  if (!color) return {
    r: 0,
    g: 0,
    b: 0
  };
  if (typeof color !== "string") {
    throw new Error("parseColor: expected a string");
  }
  if (isHex(color)) {
    return hexToRgb(color);
  }
  if (color.startsWith("hsl(")) {
    return hslToRgb(parseHsl(color));
  }
  throw new Error("parseColor: unexpected color format: \"".concat(color, "\""));
}
function rgba(color, a) {
  const rgb = parseColor(color);
  return "rgba(".concat(rgb.r, ",").concat(rgb.g, ",").concat(rgb.b, ",").concat(a, ")");
}
function createButtonTones(opts, base, dark, solid, muted, mode) {
  return {
    default: opts.button({
      base,
      dark,
      solid: solid.default,
      muted: muted.default,
      mode
    }),
    primary: opts.button({
      base,
      dark,
      solid: solid.primary,
      muted: muted.primary,
      mode
    }),
    positive: opts.button({
      base,
      dark,
      solid: solid.positive,
      muted: muted.positive,
      mode
    }),
    caution: opts.button({
      base,
      dark,
      solid: solid.caution,
      muted: muted.caution,
      mode
    }),
    critical: opts.button({
      base,
      dark,
      solid: solid.critical,
      muted: muted.critical,
      mode
    })
  };
}
function createButtonModes(opts, base, dark, solid, muted) {
  return {
    default: createButtonTones(opts, base, dark, solid, muted, "default"),
    ghost: createButtonTones(opts, base, dark, solid, muted, "ghost"),
    bleed: createButtonTones(opts, base, dark, solid, muted, "bleed")
  };
}
function createCardStates(opts, base, dark, name, solid, muted) {
  return {
    enabled: opts.card({
      base,
      dark,
      name,
      state: "enabled",
      solid,
      muted
    }),
    disabled: opts.card({
      base,
      dark,
      name,
      state: "disabled",
      solid,
      muted
    }),
    hovered: opts.card({
      base,
      dark,
      name,
      state: "hovered",
      solid,
      muted
    }),
    pressed: opts.card({
      base,
      dark,
      name,
      state: "pressed",
      solid,
      muted
    }),
    selected: opts.card({
      base,
      dark,
      name,
      state: "selected",
      solid,
      muted
    })
  };
}
const black = "hsl(0, 0%, 0%)";
const white = "hsl(0, 0%, 100%)";
const colors = {
  default: {
    lightest: "hsl(0, 0%, 95%)",
    lighter: "hsl(0, 0%, 70%)",
    light: "hsl(0, 0%, 65%)",
    base: "hsl(0, 0%, 50%)",
    dark: "hsl(0, 0%, 35%)",
    darker: "hsl(0, 0%, 20%)",
    darkest: "hsl(0, 0%, 5%)"
  },
  transparent: {
    lightest: "hsl(240, 100%, 95%)",
    lighter: "hsl(240, 100%, 70%)",
    light: "hsl(240, 100%, 65%)",
    base: "hsl(240, 100%, 50%)",
    dark: "hsl(240, 100%, 35%)",
    darker: "hsl(240, 100%, 20%)",
    darkest: "hsl(240, 100%, 5%)"
  },
  primary: {
    lightest: "hsl(240, 100%, 95%)",
    lighter: "hsl(240, 100%, 70%)",
    light: "hsl(240, 100%, 65%)",
    base: "hsl(240, 100%, 50%)",
    dark: "hsl(240, 100%, 35%)",
    darker: "hsl(240, 100%, 20%)",
    darkest: "hsl(240, 100%, 5%)"
  },
  positive: {
    lightest: "hsl(120, 100%, 95%)",
    lighter: "hsl(120, 100%, 70%)",
    light: "hsl(120, 100%, 65%)",
    base: "hsl(120, 100%, 50%)",
    dark: "hsl(120, 100%, 35%)",
    darker: "hsl(120, 100%, 20%)",
    darkest: "hsl(120, 100%, 5%)"
  },
  caution: {
    lightest: "hsl(60, 100%, 95%)",
    lighter: "hsl(60, 100%, 70%)",
    light: "hsl(60, 100%, 65%)",
    base: "hsl(60, 100%, 50%)",
    dark: "hsl(60, 100%, 35%)",
    darker: "hsl(60, 100%, 20%)",
    darkest: "hsl(60, 100%, 5%)"
  },
  critical: {
    lightest: "hsl(0, 100%, 95%)",
    lighter: "hsl(0, 100%, 70%)",
    light: "hsl(0, 100%, 65%)",
    base: "hsl(0, 100%, 50%)",
    dark: "hsl(0, 100%, 35%)",
    darker: "hsl(0, 100%, 20%)",
    darkest: "hsl(0, 100%, 5%)"
  }
};
const spots = {
  gray: "hsl(0, 0%, 50%)",
  red: "hsl(0, 100%, 50%)",
  orange: "hsl(30, 100%, 50%)",
  yellow: "hsl(60, 100%, 50%)",
  green: "hsl(120, 100%, 50%)",
  cyan: "hsl(180, 100%, 50%)",
  blue: "hsl(240, 100%, 50%)",
  purple: "hsl(270, 100%, 50%)",
  magenta: "hsl(300, 100%, 50%)"
};
const tones$1 = {
  transparent: {
    bg: [colors.transparent.darkest, colors.transparent.lightest],
    fg: [colors.transparent.lightest, colors.transparent.darkest],
    border: [colors.transparent.darker, colors.transparent.lighter],
    focusRing: [colors.transparent.base, colors.transparent.base]
  },
  primary: {
    bg: [colors.primary.darkest, colors.primary.lightest],
    fg: [colors.primary.lightest, colors.primary.darkest],
    border: [colors.primary.darker, colors.primary.lighter],
    focusRing: [colors.primary.base, colors.primary.base]
  },
  positive: {
    bg: [colors.positive.darkest, colors.positive.lightest],
    fg: [colors.positive.lightest, colors.positive.darkest],
    border: [colors.positive.darker, colors.positive.lighter],
    focusRing: [colors.positive.base, colors.positive.base]
  },
  caution: {
    bg: [colors.caution.darkest, colors.caution.lightest],
    fg: [colors.caution.lightest, colors.caution.darkest],
    border: [colors.caution.darker, colors.caution.lighter],
    focusRing: [colors.caution.base, colors.caution.base]
  },
  critical: {
    bg: [colors.critical.darkest, colors.critical.lightest],
    fg: [colors.critical.lightest, colors.critical.darkest],
    border: [colors.critical.darker, colors.critical.lighter],
    focusRing: [colors.critical.base, colors.critical.base]
  }
};
const defaultOpts = {
  base: _ref4 => {
    let {
      dark,
      name
    } = _ref4;
    if (name === "default") {
      return {
        bg: dark ? black : white,
        fg: dark ? white : black,
        border: dark ? colors.default.darkest : colors.default.lightest,
        focusRing: colors.primary.base,
        shadow: {
          outline: black,
          umbra: black,
          penumbra: black,
          ambient: black
        },
        skeleton: {
          from: dark ? white : black,
          to: dark ? white : black
        }
      };
    }
    return {
      bg: tones$1[name].bg[dark ? 0 : 1],
      fg: tones$1[name].fg[dark ? 0 : 1],
      border: tones$1[name].border[dark ? 0 : 1],
      focusRing: tones$1[name].focusRing[dark ? 0 : 1],
      shadow: {
        outline: black,
        umbra: black,
        penumbra: black,
        ambient: black
      },
      skeleton: {
        from: dark ? white : black,
        to: dark ? white : black
      }
    };
  },
  solid: _ref5 => {
    let {
      base,
      dark,
      state,
      tone
    } = _ref5;
    const color = colors[tone];
    if (state === "hovered") {
      return {
        bg: dark ? color.light : color.dark,
        bg2: dark ? color.light : color.dark,
        border: dark ? color.lighter : color.darker,
        fg: dark ? color.darkest : color.lightest,
        muted: {
          fg: black
        },
        accent: {
          fg: black
        },
        link: {
          fg: black
        },
        code: {
          bg: black,
          fg: black
        },
        skeleton: base.skeleton
      };
    }
    return {
      bg: color.base,
      bg2: color.base,
      border: dark ? color.light : color.dark,
      fg: dark ? color.darkest : color.lightest,
      muted: {
        fg: black
      },
      accent: {
        fg: black
      },
      link: {
        fg: black
      },
      code: {
        bg: black,
        fg: black
      },
      skeleton: base.skeleton
    };
  },
  muted: _ref6 => {
    let {
      base,
      dark,
      state,
      tone
    } = _ref6;
    const color = colors[tone];
    if (state === "hovered") {
      return {
        bg: dark ? color.darker : color.lighter,
        bg2: dark ? color.darker : color.lighter,
        border: dark ? color.lighter : color.darker,
        fg: dark ? color.lightest : color.darkest,
        muted: {
          fg: black
        },
        accent: {
          fg: black
        },
        link: {
          fg: black
        },
        code: {
          bg: black,
          fg: black
        },
        skeleton: base.skeleton
      };
    }
    return {
      bg: dark ? color.darkest : color.lightest,
      bg2: dark ? color.darkest : color.lightest,
      border: dark ? color.darker : color.lighter,
      fg: dark ? color.lighter : color.darker,
      muted: {
        fg: black
      },
      accent: {
        fg: black
      },
      link: {
        fg: black
      },
      code: {
        bg: black,
        fg: black
      },
      skeleton: base.skeleton
    };
  },
  button: _ref7 => {
    let {
      base,
      mode,
      muted,
      solid
    } = _ref7;
    if (mode === "bleed") {
      return {
        ...muted,
        enabled: {
          bg: "transparent",
          bg2: "transparent",
          fg: muted.enabled.fg,
          border: "transparent",
          muted: {
            fg: black
          },
          accent: {
            fg: black
          },
          link: {
            fg: black
          },
          code: {
            bg: black,
            fg: black
          },
          skeleton: base.skeleton
        },
        hovered: {
          bg: muted.enabled.bg,
          bg2: muted.enabled.bg,
          fg: muted.hovered.fg,
          border: "transparent",
          muted: {
            fg: black
          },
          accent: {
            fg: black
          },
          link: {
            fg: black
          },
          code: {
            bg: black,
            fg: black
          },
          skeleton: base.skeleton
        }
      };
    }
    if (mode === "ghost") return {
      ...solid,
      enabled: muted.enabled
    };
    return solid;
  },
  card: _ref8 => {
    let {
      base
    } = _ref8;
    return {
      bg: black,
      bg2: black,
      fg: black,
      border: black,
      muted: {
        fg: black
      },
      accent: {
        fg: black
      },
      link: {
        fg: black
      },
      code: {
        bg: black,
        fg: black
      },
      skeleton: base.skeleton
    };
  },
  input: () => {
    return {
      bg: black,
      fg: black,
      border: black,
      placeholder: black
    };
  },
  selectable: _ref9 => {
    let {
      muted,
      state,
      tone
    } = _ref9;
    return muted[tone][state];
  },
  spot: _ref10 => {
    let {
      key
    } = _ref10;
    return spots[key];
  },
  syntax: () => ({
    atrule: black,
    attrName: black,
    attrValue: black,
    attribute: black,
    boolean: black,
    builtin: black,
    cdata: black,
    char: black,
    class: black,
    className: black,
    comment: black,
    constant: black,
    deleted: black,
    doctype: black,
    entity: black,
    function: black,
    hexcode: black,
    id: black,
    important: black,
    inserted: black,
    keyword: black,
    number: black,
    operator: black,
    prolog: black,
    property: black,
    pseudoClass: black,
    pseudoElement: black,
    punctuation: black,
    regex: black,
    selector: black,
    string: black,
    symbol: black,
    tag: black,
    unit: black,
    url: black,
    variable: black
  })
};
function createInputModes(opts, base, dark, solid, muted) {
  return {
    default: {
      enabled: opts.input({
        base,
        dark,
        mode: "default",
        state: "enabled",
        solid: solid.default,
        muted: muted.default
      }),
      disabled: opts.input({
        base,
        dark,
        mode: "default",
        state: "disabled",
        solid: solid.default,
        muted: muted.default
      }),
      hovered: opts.input({
        base,
        dark,
        mode: "default",
        state: "hovered",
        solid: solid.default,
        muted: muted.default
      }),
      readOnly: opts.input({
        base,
        dark,
        mode: "default",
        state: "readOnly",
        solid: solid.default,
        muted: muted.default
      })
    },
    invalid: {
      enabled: opts.input({
        base,
        dark,
        mode: "invalid",
        state: "enabled",
        solid: solid.default,
        muted: muted.default
      }),
      disabled: opts.input({
        base,
        dark,
        mode: "invalid",
        state: "disabled",
        solid: solid.default,
        muted: muted.default
      }),
      hovered: opts.input({
        base,
        dark,
        mode: "invalid",
        state: "hovered",
        solid: solid.default,
        muted: muted.default
      }),
      readOnly: opts.input({
        base,
        dark,
        mode: "invalid",
        state: "readOnly",
        solid: solid.default,
        muted: muted.default
      })
    }
  };
}
function createMutedTones(opts, base, dark, name) {
  return {
    default: {
      enabled: opts.muted({
        base,
        dark,
        tone: "default",
        name,
        state: "enabled"
      }),
      disabled: opts.muted({
        base,
        dark,
        tone: "default",
        name,
        state: "disabled"
      }),
      hovered: opts.muted({
        base,
        dark,
        tone: "default",
        name,
        state: "hovered"
      }),
      pressed: opts.muted({
        base,
        dark,
        tone: "default",
        name,
        state: "pressed"
      }),
      selected: opts.muted({
        base,
        dark,
        tone: "default",
        name,
        state: "selected"
      })
    },
    transparent: {
      enabled: opts.muted({
        base,
        dark,
        tone: "transparent",
        name,
        state: "enabled"
      }),
      disabled: opts.muted({
        base,
        dark,
        tone: "transparent",
        name,
        state: "disabled"
      }),
      hovered: opts.muted({
        base,
        dark,
        tone: "transparent",
        name,
        state: "hovered"
      }),
      pressed: opts.muted({
        base,
        dark,
        tone: "transparent",
        name,
        state: "pressed"
      }),
      selected: opts.muted({
        base,
        dark,
        tone: "transparent",
        name,
        state: "selected"
      })
    },
    primary: {
      enabled: opts.muted({
        base,
        dark,
        tone: "primary",
        name,
        state: "enabled"
      }),
      disabled: opts.muted({
        base,
        dark,
        tone: "primary",
        name,
        state: "disabled"
      }),
      hovered: opts.muted({
        base,
        dark,
        tone: "primary",
        name,
        state: "hovered"
      }),
      pressed: opts.muted({
        base,
        dark,
        tone: "primary",
        name,
        state: "pressed"
      }),
      selected: opts.muted({
        base,
        dark,
        tone: "primary",
        name,
        state: "selected"
      })
    },
    positive: {
      enabled: opts.muted({
        base,
        dark,
        tone: "positive",
        name,
        state: "enabled"
      }),
      disabled: opts.muted({
        base,
        dark,
        tone: "positive",
        name,
        state: "disabled"
      }),
      hovered: opts.muted({
        base,
        dark,
        tone: "positive",
        name,
        state: "hovered"
      }),
      pressed: opts.muted({
        base,
        dark,
        tone: "positive",
        name,
        state: "pressed"
      }),
      selected: opts.muted({
        base,
        dark,
        tone: "positive",
        name,
        state: "selected"
      })
    },
    caution: {
      enabled: opts.muted({
        base,
        dark,
        tone: "caution",
        name,
        state: "enabled"
      }),
      disabled: opts.muted({
        base,
        dark,
        tone: "caution",
        name,
        state: "disabled"
      }),
      hovered: opts.muted({
        base,
        dark,
        tone: "caution",
        name,
        state: "hovered"
      }),
      pressed: opts.muted({
        base,
        dark,
        tone: "caution",
        name,
        state: "pressed"
      }),
      selected: opts.muted({
        base,
        dark,
        tone: "caution",
        name,
        state: "selected"
      })
    },
    critical: {
      enabled: opts.muted({
        base,
        dark,
        tone: "critical",
        name,
        state: "enabled"
      }),
      disabled: opts.muted({
        base,
        dark,
        tone: "critical",
        name,
        state: "disabled"
      }),
      hovered: opts.muted({
        base,
        dark,
        tone: "critical",
        name,
        state: "hovered"
      }),
      pressed: opts.muted({
        base,
        dark,
        tone: "critical",
        name,
        state: "pressed"
      }),
      selected: opts.muted({
        base,
        dark,
        tone: "critical",
        name,
        state: "selected"
      })
    }
  };
}
function createSelectableTones(opts, base, dark, solid, muted) {
  return {
    default: _createSelectableStates(opts, base, dark, solid, muted, "default"),
    primary: _createSelectableStates(opts, base, dark, solid, muted, "primary"),
    positive: _createSelectableStates(opts, base, dark, solid, muted, "positive"),
    caution: _createSelectableStates(opts, base, dark, solid, muted, "caution"),
    critical: _createSelectableStates(opts, base, dark, solid, muted, "critical")
  };
}
function _createSelectableStates(opts, base, dark, solid, muted, tone) {
  return {
    enabled: opts.selectable({
      base,
      dark,
      solid,
      muted,
      state: "enabled",
      tone
    }),
    hovered: opts.selectable({
      base,
      dark,
      solid,
      muted,
      state: "hovered",
      tone
    }),
    pressed: opts.selectable({
      base,
      dark,
      solid,
      muted,
      state: "pressed",
      tone
    }),
    selected: opts.selectable({
      base,
      dark,
      solid,
      muted,
      state: "selected",
      tone
    }),
    disabled: opts.selectable({
      base,
      dark,
      solid,
      muted,
      state: "disabled",
      tone
    })
  };
}
function createSolidTones(opts, base, dark, name) {
  return {
    default: {
      enabled: opts.solid({
        base,
        dark,
        tone: "default",
        name,
        state: "enabled"
      }),
      disabled: opts.solid({
        base,
        dark,
        tone: "default",
        name,
        state: "disabled"
      }),
      hovered: opts.solid({
        base,
        dark,
        tone: "default",
        name,
        state: "hovered"
      }),
      pressed: opts.solid({
        base,
        dark,
        tone: "default",
        name,
        state: "pressed"
      }),
      selected: opts.solid({
        base,
        dark,
        tone: "default",
        name,
        state: "selected"
      })
    },
    transparent: {
      enabled: opts.solid({
        base,
        dark,
        tone: "transparent",
        name,
        state: "enabled"
      }),
      disabled: opts.solid({
        base,
        dark,
        tone: "transparent",
        name,
        state: "disabled"
      }),
      hovered: opts.solid({
        base,
        dark,
        tone: "transparent",
        name,
        state: "hovered"
      }),
      pressed: opts.solid({
        base,
        dark,
        tone: "transparent",
        name,
        state: "pressed"
      }),
      selected: opts.solid({
        base,
        dark,
        tone: "transparent",
        name,
        state: "selected"
      })
    },
    primary: {
      enabled: opts.solid({
        base,
        dark,
        tone: "primary",
        name,
        state: "enabled"
      }),
      disabled: opts.solid({
        base,
        dark,
        tone: "primary",
        name,
        state: "disabled"
      }),
      hovered: opts.solid({
        base,
        dark,
        tone: "primary",
        name,
        state: "hovered"
      }),
      pressed: opts.solid({
        base,
        dark,
        tone: "primary",
        name,
        state: "pressed"
      }),
      selected: opts.solid({
        base,
        dark,
        tone: "primary",
        name,
        state: "selected"
      })
    },
    positive: {
      enabled: opts.solid({
        base,
        dark,
        tone: "positive",
        name,
        state: "enabled"
      }),
      disabled: opts.solid({
        base,
        dark,
        tone: "positive",
        name,
        state: "disabled"
      }),
      hovered: opts.solid({
        base,
        dark,
        tone: "positive",
        name,
        state: "hovered"
      }),
      pressed: opts.solid({
        base,
        dark,
        tone: "positive",
        name,
        state: "pressed"
      }),
      selected: opts.solid({
        base,
        dark,
        tone: "positive",
        name,
        state: "selected"
      })
    },
    caution: {
      enabled: opts.solid({
        base,
        dark,
        tone: "caution",
        name,
        state: "enabled"
      }),
      disabled: opts.solid({
        base,
        dark,
        tone: "caution",
        name,
        state: "disabled"
      }),
      hovered: opts.solid({
        base,
        dark,
        tone: "caution",
        name,
        state: "hovered"
      }),
      pressed: opts.solid({
        base,
        dark,
        tone: "caution",
        name,
        state: "pressed"
      }),
      selected: opts.solid({
        base,
        dark,
        tone: "caution",
        name,
        state: "selected"
      })
    },
    critical: {
      enabled: opts.solid({
        base,
        dark,
        tone: "critical",
        name,
        state: "enabled"
      }),
      disabled: opts.solid({
        base,
        dark,
        tone: "critical",
        name,
        state: "disabled"
      }),
      hovered: opts.solid({
        base,
        dark,
        tone: "critical",
        name,
        state: "hovered"
      }),
      pressed: opts.solid({
        base,
        dark,
        tone: "critical",
        name,
        state: "pressed"
      }),
      selected: opts.solid({
        base,
        dark,
        tone: "critical",
        name,
        state: "selected"
      })
    }
  };
}
function createSpot(opts, base, dark) {
  return {
    gray: opts.spot({
      base,
      dark,
      key: "gray"
    }),
    blue: opts.spot({
      base,
      dark,
      key: "blue"
    }),
    purple: opts.spot({
      base,
      dark,
      key: "purple"
    }),
    magenta: opts.spot({
      base,
      dark,
      key: "magenta"
    }),
    red: opts.spot({
      base,
      dark,
      key: "red"
    }),
    orange: opts.spot({
      base,
      dark,
      key: "orange"
    }),
    yellow: opts.spot({
      base,
      dark,
      key: "yellow"
    }),
    green: opts.spot({
      base,
      dark,
      key: "green"
    }),
    cyan: opts.spot({
      base,
      dark,
      key: "cyan"
    })
  };
}
function createColorTheme() {
  let partialOpts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const builders = {
    ...defaultOpts,
    ...partialOpts
  };
  return {
    light: _createColorScheme(builders, false),
    dark: _createColorScheme(builders, true)
  };
}
function _createColorScheme(opts, dark) {
  return {
    default: _createColor(opts, dark, "default"),
    transparent: _createColor(opts, dark, "transparent"),
    primary: _createColor(opts, dark, "primary"),
    positive: _createColor(opts, dark, "positive"),
    caution: _createColor(opts, dark, "caution"),
    critical: _createColor(opts, dark, "critical")
  };
}
function _createColor(opts, dark, name) {
  const base = opts.base({
    dark,
    name
  });
  const solid = createSolidTones(opts, base, dark, name);
  const muted = createMutedTones(opts, base, dark, name);
  return {
    base,
    button: createButtonModes(opts, base, dark, solid, muted),
    card: createCardStates(opts, base, dark, name, solid, muted),
    dark,
    input: createInputModes(opts, base, dark, solid, muted),
    selectable: createSelectableTones(opts, base, dark, solid, muted),
    spot: createSpot(opts, base, dark),
    syntax: opts.syntax({
      base,
      dark
    }),
    solid,
    muted
  };
}
function multiply(bg, fg) {
  const b = parseColor(bg);
  const s = parseColor(fg);
  const hex = rgbToHex(multiply$1(b, s));
  return hex;
}
function screen(bg, fg) {
  const b = parseColor(bg);
  const s = parseColor(fg);
  const hex = rgbToHex(screen$1(b, s));
  return hex;
}
const tones = {
  default: hues.gray,
  transparent: hues.gray,
  primary: hues.blue,
  positive: hues.green,
  caution: hues.yellow,
  critical: hues.red
};
const NEUTRAL_TONES = ["default", "transparent"];
const color = createColorTheme({
  base: _ref11 => {
    let {
      dark,
      name
    } = _ref11;
    if (name === "default") {
      const tints2 = hues.gray;
      const skeletonFrom2 = dark ? tints2[900].hex : tints2[100].hex;
      return {
        fg: dark ? white$1.hex : black$1.hex,
        bg: dark ? black$1.hex : white$1.hex,
        border: tints2[dark ? 800 : 200].hex,
        focusRing: hues.blue[dark ? 500 : 500].hex,
        shadow: {
          outline: rgba(tints2[500].hex, 0.4),
          umbra: dark ? rgba(tints2[950].hex, 0.4) : rgba(tints2[500].hex, 0.2),
          penumbra: dark ? rgba(tints2[950].hex, 0.28) : rgba(tints2[500].hex, 0.14),
          ambient: dark ? rgba(tints2[950].hex, 0.24) : rgba(tints2[500].hex, 0.12)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba(skeletonFrom2, 0.5)
        }
      };
    }
    if (name === "transparent") {
      const tints2 = tones.default;
      const skeletonFrom2 = tints2[dark ? 800 : 200].hex;
      return {
        fg: tints2[dark ? 100 : 900].hex,
        bg: tints2[dark ? 950 : 50].hex,
        border: tints2[dark ? 800 : 300].hex,
        focusRing: hues.blue[500].hex,
        shadow: {
          outline: rgba(tints2[500].hex, 0.4),
          umbra: dark ? rgba(tints2[900].hex, 0.4) : rgba(tints2[500].hex, 0.2),
          penumbra: dark ? rgba(tints2[900].hex, 0.28) : rgba(tints2[500].hex, 0.14),
          ambient: dark ? rgba(tints2[900].hex, 0.24) : rgba(tints2[500].hex, 0.12)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba(skeletonFrom2, 0.5)
        }
      };
    }
    const tints = tones[name] || tones.default;
    const skeletonFrom = tints[dark ? 800 : 200].hex;
    return {
      fg: tints[dark ? 100 : 900].hex,
      bg: tints[dark ? 950 : 50].hex,
      border: tints[dark ? 800 : 200].hex,
      focusRing: tints[500].hex,
      shadow: {
        outline: rgba(tints[500].hex, 0.4),
        umbra: dark ? rgba(tints[900].hex, 0.4) : rgba(tints[500].hex, 0.2),
        penumbra: dark ? rgba(tints[900].hex, 0.28) : rgba(tints[500].hex, 0.14),
        ambient: dark ? rgba(tints[900].hex, 0.24) : rgba(tints[500].hex, 0.12)
      },
      skeleton: {
        from: skeletonFrom,
        to: rgba(skeletonFrom, 0.5)
      }
    };
  },
  solid: _ref12 => {
    let {
      base,
      dark,
      name,
      state,
      tone
    } = _ref12;
    const mix = dark ? screen : multiply;
    const mix2 = dark ? multiply : screen;
    const defaultTints = tones[name] || tones.default;
    const isNeutral = NEUTRAL_TONES.includes(name) && NEUTRAL_TONES.includes(tone);
    let tints = tones[tone === "default" ? name : tone] || defaultTints;
    if (state === "disabled") {
      tints = defaultTints;
      const bg2 = mix(base.bg, tints[dark ? 800 : 200].hex);
      const skeletonFrom2 = mix2(bg2, tints[dark ? 200 : 800].hex);
      return {
        bg: bg2,
        bg2: mix2(bg2, tints[dark ? 50 : 950].hex),
        border: mix(base.bg, tints[dark ? 800 : 200].hex),
        fg: mix(base.bg, dark ? black$1.hex : white$1.hex),
        muted: {
          fg: mix(base.bg, tints[dark ? 950 : 50].hex)
        },
        accent: {
          fg: mix(base.bg, tints[dark ? 950 : 50].hex)
        },
        link: {
          fg: mix(base.bg, tints[dark ? 950 : 50].hex)
        },
        code: {
          bg: bg2,
          fg: mix(base.bg, tints[dark ? 950 : 50].hex)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba(skeletonFrom2, 0.5)
        }
      };
    }
    if (state === "hovered") {
      const bg2 = mix(base.bg, tints[dark ? 300 : 600].hex);
      const skeletonFrom2 = mix2(bg2, tints[dark ? 200 : 800].hex);
      return {
        bg: bg2,
        bg2: mix2(bg2, tints[dark ? 50 : 950].hex),
        border: mix(base.bg, tints[dark ? 300 : 600].hex),
        fg: mix(base.bg, dark ? black$1.hex : white$1.hex),
        muted: {
          fg: mix(base.bg, tints[dark ? 800 : 200].hex)
        },
        accent: {
          fg: mix2(bg2, hues.red[dark ? 800 : 200].hex)
        },
        link: {
          fg: mix2(bg2, hues.blue[dark ? 800 : 200].hex)
        },
        code: {
          bg: mix(bg2, tints[dark ? 950 : 50].hex),
          fg: mix(base.bg, tints[dark ? 800 : 200].hex)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba(skeletonFrom2, 0.5)
        }
      };
    }
    if (state === "pressed") {
      const bg2 = mix(base.bg, tints[dark ? 200 : 800].hex);
      const skeletonFrom2 = mix2(bg2, tints[dark ? 200 : 800].hex);
      return {
        bg: mix(base.bg, tints[dark ? 200 : 800].hex),
        bg2: mix2(bg2, tints[dark ? 50 : 950].hex),
        border: mix(base.bg, tints[dark ? 200 : 800].hex),
        fg: mix(base.bg, dark ? black$1.hex : white$1.hex),
        muted: {
          fg: mix(base.bg, tints[dark ? 800 : 200].hex)
        },
        accent: {
          fg: mix2(bg2, hues.red[dark ? 800 : 200].hex)
        },
        link: {
          fg: mix2(bg2, hues.blue[dark ? 800 : 200].hex)
        },
        code: {
          bg: mix(bg2, tints[dark ? 950 : 50].hex),
          fg: mix(base.bg, tints[dark ? 800 : 200].hex)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba(skeletonFrom2, 0.5)
        }
      };
    }
    if (state === "selected") {
      if (isNeutral) {
        tints = tones.primary;
      }
      const bg2 = mix(base.bg, tints[dark ? 200 : 800].hex);
      const skeletonFrom2 = mix2(bg2, tints[dark ? 200 : 800].hex);
      return {
        bg: bg2,
        bg2: mix2(bg2, tints[dark ? 50 : 950].hex),
        border: mix(base.bg, tints[dark ? 200 : 800].hex),
        fg: mix(base.bg, dark ? black$1.hex : white$1.hex),
        muted: {
          fg: mix(base.bg, tints[dark ? 800 : 200].hex)
        },
        accent: {
          fg: mix2(bg2, hues.red[dark ? 800 : 200].hex)
        },
        link: {
          fg: mix2(bg2, hues.blue[dark ? 800 : 200].hex)
        },
        code: {
          bg: mix(bg2, tints[dark ? 950 : 50].hex),
          fg: mix(base.bg, tints[dark ? 800 : 200].hex)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba(skeletonFrom2, 0.5)
        }
      };
    }
    const bg = mix(base.bg, tints[dark ? 400 : 500].hex);
    const skeletonFrom = mix2(bg, tints[dark ? 200 : 800].hex);
    return {
      bg,
      bg2: mix2(bg, tints[dark ? 50 : 950].hex),
      border: mix(base.bg, tints[dark ? 400 : 500].hex),
      fg: mix(base.bg, dark ? black$1.hex : white$1.hex),
      muted: {
        fg: mix(base.bg, tints[dark ? 900 : 100].hex)
      },
      accent: {
        fg: mix2(bg, hues.red[dark ? 900 : 100].hex)
      },
      link: {
        fg: mix2(bg, hues.blue[dark ? 900 : 100].hex)
      },
      code: {
        bg: mix(bg, tints[dark ? 950 : 50].hex),
        fg: mix(base.bg, tints[dark ? 900 : 100].hex)
      },
      skeleton: {
        from: skeletonFrom,
        to: rgba(skeletonFrom, 0.5)
      }
    };
  },
  muted: _ref13 => {
    let {
      base,
      dark,
      name,
      state,
      tone
    } = _ref13;
    const mix = dark ? screen : multiply;
    const defaultTints = tones[name] || tones.default;
    const isNeutral = NEUTRAL_TONES.includes(name) && NEUTRAL_TONES.includes(tone);
    let tints = tones[tone === "default" ? name : tone] || defaultTints;
    if (state === "disabled") {
      tints = defaultTints;
      const bg2 = base.bg;
      const skeletonFrom2 = mix(bg2, tints[dark ? 900 : 100].hex);
      return {
        bg: bg2,
        bg2: mix(bg2, tints[dark ? 950 : 50].hex),
        border: mix(bg2, tints[dark ? 950 : 50].hex),
        fg: mix(bg2, tints[dark ? 800 : 200].hex),
        muted: {
          fg: mix(bg2, tints[dark ? 900 : 100].hex)
        },
        accent: {
          fg: mix(bg2, tints[dark ? 900 : 100].hex)
        },
        link: {
          fg: mix(bg2, tints[dark ? 900 : 100].hex)
        },
        code: {
          bg: bg2,
          fg: mix(bg2, tints[dark ? 900 : 100].hex)
        },
        skeleton: {
          from: rgba(skeletonFrom2, 0.5),
          to: rgba(skeletonFrom2, 0.25)
        }
      };
    }
    if (state === "hovered") {
      const bg2 = mix(base.bg, tints[dark ? 950 : 50].hex);
      const skeletonFrom2 = mix(bg2, tints[dark ? 900 : 100].hex);
      return {
        bg: bg2,
        bg2: mix(bg2, tints[dark ? 950 : 50].hex),
        border: mix(bg2, tints[dark ? 900 : 100].hex),
        fg: mix(base.bg, tints[dark ? 200 : 800].hex),
        muted: {
          fg: mix(base.bg, tints[dark ? 400 : 600].hex)
        },
        accent: {
          fg: mix(base.bg, hues.red[dark ? 400 : 500].hex)
        },
        link: {
          fg: mix(base.bg, hues.blue[dark ? 400 : 600].hex)
        },
        code: {
          bg: mix(bg2, tints[dark ? 950 : 50].hex),
          fg: mix(base.bg, tints[dark ? 400 : 600].hex)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba(skeletonFrom2, 0.5)
        }
      };
    }
    if (state === "pressed") {
      if (isNeutral) {
        tints = tones.primary;
      }
      const bg2 = mix(base.bg, tints[dark ? 900 : 100].hex);
      const skeletonFrom2 = mix(bg2, tints[dark ? 900 : 100].hex);
      return {
        bg: bg2,
        bg2: mix(bg2, tints[dark ? 950 : 50].hex),
        border: mix(bg2, tints[dark ? 900 : 100].hex),
        fg: mix(base.bg, tints[dark ? 200 : 800].hex),
        muted: {
          fg: mix(base.bg, tints[dark ? 400 : 600].hex)
        },
        accent: {
          fg: mix(bg2, hues.red[dark ? 400 : 500].hex)
        },
        link: {
          fg: mix(bg2, hues.blue[dark ? 400 : 600].hex)
        },
        code: {
          bg: mix(bg2, tints[dark ? 950 : 50].hex),
          fg: mix(base.bg, tints[dark ? 400 : 600].hex)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba(skeletonFrom2, 0.5)
        }
      };
    }
    if (state === "selected") {
      if (isNeutral) {
        tints = tones.primary;
      }
      const bg2 = mix(base.bg, tints[dark ? 900 : 100].hex);
      const skeletonFrom2 = mix(bg2, tints[dark ? 900 : 100].hex);
      return {
        bg: bg2,
        bg2: mix(bg2, tints[dark ? 950 : 50].hex),
        border: mix(bg2, tints[dark ? 900 : 100].hex),
        fg: mix(base.bg, tints[dark ? 200 : 800].hex),
        muted: {
          fg: mix(base.bg, tints[dark ? 400 : 600].hex)
        },
        accent: {
          fg: mix(bg2, hues.red[dark ? 400 : 500].hex)
        },
        link: {
          fg: mix(bg2, hues.blue[dark ? 400 : 600].hex)
        },
        code: {
          bg: mix(bg2, tints[dark ? 950 : 50].hex),
          fg: mix(base.bg, tints[dark ? 400 : 600].hex)
        },
        skeleton: {
          from: skeletonFrom2,
          to: rgba(skeletonFrom2, 0.5)
        }
      };
    }
    const bg = base.bg;
    const skeletonFrom = mix(bg, tints[dark ? 900 : 100].hex);
    return {
      bg,
      bg2: mix(bg, tints[dark ? 950 : 50].hex),
      border: mix(bg, tints[dark ? 900 : 100].hex),
      fg: mix(base.bg, tints[dark ? 300 : 700].hex),
      muted: {
        fg: mix(base.bg, tints[dark ? 400 : 600].hex)
      },
      accent: {
        fg: mix(base.bg, hues.red[dark ? 400 : 500].hex)
      },
      link: {
        fg: mix(base.bg, hues.blue[dark ? 400 : 600].hex)
      },
      code: {
        bg: mix(base.bg, tints[dark ? 950 : 50].hex),
        fg: mix(base.bg, tints[dark ? 400 : 600].hex)
      },
      skeleton: {
        from: skeletonFrom,
        to: rgba(skeletonFrom, 0.5)
      }
    };
  },
  button: _ref14 => {
    let {
      base,
      mode,
      muted,
      solid
    } = _ref14;
    if (mode === "bleed") {
      return {
        enabled: {
          ...muted.enabled,
          border: muted.enabled.bg
        },
        hovered: {
          ...muted.hovered,
          border: muted.hovered.bg
        },
        pressed: {
          ...muted.pressed,
          border: muted.pressed.bg
        },
        selected: {
          ...muted.selected,
          border: muted.selected.bg
        },
        disabled: {
          ...muted.disabled,
          border: muted.disabled.bg
        }
      };
    }
    if (mode === "ghost") {
      return {
        ...solid,
        enabled: {
          ...muted.enabled,
          border: base.border
        },
        disabled: muted.disabled
      };
    }
    return solid;
  },
  card: _ref15 => {
    let {
      base,
      dark,
      muted,
      name,
      solid,
      state
    } = _ref15;
    if (state === "hovered") {
      return muted[name].hovered;
    }
    if (state === "disabled") {
      return muted[name].disabled;
    }
    const isNeutral = NEUTRAL_TONES.includes(name);
    const tints = tones[name] || tones.default;
    const mix = dark ? screen : multiply;
    if (state === "pressed") {
      if (isNeutral) {
        return muted.primary.pressed;
      }
      return muted[name].pressed;
    }
    if (state === "selected") {
      if (isNeutral) {
        return solid.primary.enabled;
      }
      return solid[name].enabled;
    }
    const bg = base.bg;
    const skeletonFrom = mix(base.bg, tints[dark ? 900 : 100].hex);
    return {
      bg,
      bg2: mix(bg, tints[dark ? 950 : 50].hex),
      fg: base.fg,
      border: base.border,
      muted: {
        fg: mix(base.bg, tints[dark ? 400 : 600].hex)
      },
      accent: {
        fg: mix(base.bg, hues.red[dark ? 400 : 500].hex)
      },
      link: {
        fg: mix(base.bg, hues.blue[dark ? 400 : 600].hex)
      },
      code: {
        bg: mix(base.bg, tints[dark ? 950 : 50].hex),
        fg: tints[dark ? 400 : 600].hex
      },
      skeleton: {
        from: skeletonFrom,
        to: rgba(skeletonFrom, 0.5)
      }
    };
  },
  input: _ref16 => {
    let {
      base,
      dark,
      mode,
      state
    } = _ref16;
    const mix = dark ? screen : multiply;
    if (mode === "invalid") {
      const tints = tones.critical;
      return {
        bg: mix(base.bg, tints[dark ? 950 : 50].hex),
        fg: mix(base.bg, tints[dark ? 400 : 600].hex),
        border: mix(base.bg, tints[dark ? 800 : 200].hex),
        placeholder: mix(base.bg, tints[dark ? 600 : 400].hex)
      };
    }
    if (state === "hovered") {
      return {
        bg: base.bg,
        fg: base.fg,
        border: mix(base.bg, hues.gray[dark ? 700 : 300].hex),
        placeholder: mix(base.bg, hues.gray[dark ? 600 : 400].hex)
      };
    }
    if (state === "disabled") {
      return {
        bg: mix(base.bg, hues.gray[dark ? 950 : 50].hex),
        fg: mix(base.bg, hues.gray[dark ? 700 : 300].hex),
        border: mix(base.bg, hues.gray[dark ? 900 : 100].hex),
        placeholder: mix(base.bg, hues.gray[dark ? 800 : 200].hex)
      };
    }
    if (state === "readOnly") {
      return {
        bg: mix(base.bg, hues.gray[dark ? 950 : 50].hex),
        fg: mix(base.bg, hues.gray[dark ? 200 : 800].hex),
        border: mix(base.bg, hues.gray[dark ? 800 : 200].hex),
        placeholder: mix(base.bg, hues.gray[dark ? 600 : 400].hex)
      };
    }
    return {
      bg: base.bg,
      fg: base.fg,
      border: base.border,
      placeholder: mix(base.bg, hues.gray[dark ? 600 : 400].hex)
    };
  },
  selectable: _ref17 => {
    let {
      base,
      muted,
      tone,
      solid,
      state
    } = _ref17;
    if (state === "enabled") {
      return {
        ...muted[tone].enabled,
        bg: base.bg
      };
    }
    if (state === "pressed") {
      if (tone === "default") {
        return muted.primary.pressed;
      }
      return muted[tone].pressed;
    }
    if (state === "selected") {
      if (tone === "default") {
        return solid.primary.enabled;
      }
      return solid[tone].enabled;
    }
    if (state === "disabled") {
      return {
        ...muted[tone].disabled,
        bg: base.bg
      };
    }
    return muted[tone][state];
  },
  spot: _ref18 => {
    let {
      base,
      dark,
      key
    } = _ref18;
    const mix = dark ? screen : multiply;
    return mix(base.bg, hues[key][dark ? 400 : 500].hex);
  },
  syntax: _ref19 => {
    let {
      base,
      dark
    } = _ref19;
    const mix = dark ? screen : multiply;
    const mainShade = dark ? 400 : 600;
    const secondaryShade = dark ? 600 : 400;
    return {
      atrule: mix(base.bg, hues.purple[mainShade].hex),
      attrName: mix(base.bg, hues.green[mainShade].hex),
      attrValue: mix(base.bg, hues.yellow[mainShade].hex),
      attribute: mix(base.bg, hues.yellow[mainShade].hex),
      boolean: mix(base.bg, hues.purple[mainShade].hex),
      builtin: mix(base.bg, hues.purple[mainShade].hex),
      cdata: mix(base.bg, hues.yellow[mainShade].hex),
      char: mix(base.bg, hues.yellow[mainShade].hex),
      class: mix(base.bg, hues.orange[mainShade].hex),
      className: mix(base.bg, hues.cyan[mainShade].hex),
      comment: mix(base.bg, hues.gray[secondaryShade].hex),
      constant: mix(base.bg, hues.purple[mainShade].hex),
      deleted: mix(base.bg, hues.red[mainShade].hex),
      doctype: mix(base.bg, hues.gray[secondaryShade].hex),
      entity: mix(base.bg, hues.red[mainShade].hex),
      function: mix(base.bg, hues.green[mainShade].hex),
      hexcode: mix(base.bg, hues.blue[mainShade].hex),
      id: mix(base.bg, hues.purple[mainShade].hex),
      important: mix(base.bg, hues.purple[mainShade].hex),
      inserted: mix(base.bg, hues.yellow[mainShade].hex),
      keyword: mix(base.bg, hues.magenta[mainShade].hex),
      number: mix(base.bg, hues.purple[mainShade].hex),
      operator: mix(base.bg, hues.magenta[mainShade].hex),
      prolog: mix(base.bg, hues.gray[secondaryShade].hex),
      property: mix(base.bg, hues.blue[mainShade].hex),
      pseudoClass: mix(base.bg, hues.yellow[mainShade].hex),
      pseudoElement: mix(base.bg, hues.yellow[mainShade].hex),
      punctuation: mix(base.bg, hues.gray[mainShade].hex),
      regex: mix(base.bg, hues.blue[mainShade].hex),
      selector: mix(base.bg, hues.red[mainShade].hex),
      string: mix(base.bg, hues.yellow[mainShade].hex),
      symbol: mix(base.bg, hues.purple[mainShade].hex),
      tag: mix(base.bg, hues.red[mainShade].hex),
      unit: mix(base.bg, hues.orange[mainShade].hex),
      url: mix(base.bg, hues.red[mainShade].hex),
      variable: mix(base.bg, hues.red[mainShade].hex)
    };
  }
});
const fonts = {
  code: {
    family: "ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace",
    weights: {
      regular: 400,
      medium: 500,
      semibold: 600,
      bold: 700
    },
    sizes: [{
      ascenderHeight: 3,
      descenderHeight: 3,
      fontSize: 10,
      iconSize: 17,
      lineHeight: 13,
      letterSpacing: 0
    }, {
      ascenderHeight: 4,
      descenderHeight: 4,
      fontSize: 13,
      iconSize: 21,
      lineHeight: 17,
      letterSpacing: 0
    }, {
      ascenderHeight: 5,
      descenderHeight: 5,
      fontSize: 16,
      iconSize: 25,
      lineHeight: 21,
      letterSpacing: 0
    }, {
      ascenderHeight: 6,
      descenderHeight: 6,
      fontSize: 19,
      iconSize: 29,
      lineHeight: 25,
      letterSpacing: 0
    }, {
      ascenderHeight: 7,
      descenderHeight: 7,
      fontSize: 22,
      iconSize: 33,
      lineHeight: 29,
      letterSpacing: 0
    }]
  },
  heading: {
    family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", "Liberation Sans", Helvetica, Arial, system-ui, sans-serif',
    weights: {
      regular: 700,
      medium: 800,
      semibold: 900,
      bold: 900
    },
    sizes: [{
      ascenderHeight: 4,
      descenderHeight: 4,
      fontSize: 12,
      iconSize: 17,
      lineHeight: 17,
      letterSpacing: 0
    }, {
      ascenderHeight: 5,
      descenderHeight: 5,
      fontSize: 16,
      iconSize: 25,
      lineHeight: 21,
      letterSpacing: 0
    }, {
      ascenderHeight: 6,
      descenderHeight: 6,
      fontSize: 21,
      iconSize: 33,
      lineHeight: 27,
      letterSpacing: 0
    }, {
      ascenderHeight: 7,
      descenderHeight: 7,
      fontSize: 27,
      iconSize: 41,
      lineHeight: 33,
      letterSpacing: 0
    }, {
      ascenderHeight: 8,
      descenderHeight: 8,
      fontSize: 33,
      iconSize: 49,
      lineHeight: 39,
      letterSpacing: 0
    }, {
      ascenderHeight: 9,
      descenderHeight: 9,
      fontSize: 38,
      iconSize: 53,
      lineHeight: 45,
      letterSpacing: 0
    }]
  },
  label: {
    family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", "Liberation Sans", system-ui, sans-serif',
    weights: {
      regular: 600,
      medium: 700,
      semibold: 800,
      bold: 900
    },
    sizes: [{
      ascenderHeight: 2,
      descenderHeight: 2,
      fontSize: 9.8,
      iconSize: 15,
      lineHeight: 11,
      letterSpacing: 0.5
    }, {
      ascenderHeight: 2,
      descenderHeight: 2,
      fontSize: 11.25,
      iconSize: 17,
      lineHeight: 12,
      letterSpacing: 0.5
    }, {
      ascenderHeight: 2,
      descenderHeight: 2,
      fontSize: 12.75,
      iconSize: 19,
      lineHeight: 13,
      letterSpacing: 0.5
    }, {
      ascenderHeight: 2,
      descenderHeight: 2,
      fontSize: 14,
      iconSize: 21,
      lineHeight: 14,
      letterSpacing: 0.5
    }, {
      ascenderHeight: 2,
      descenderHeight: 2,
      fontSize: 15.5,
      iconSize: 23,
      lineHeight: 15,
      letterSpacing: 0.5
    }]
  },
  text: {
    family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", "Liberation Sans", Helvetica, Arial, system-ui, sans-serif',
    weights: {
      regular: 400,
      medium: 500,
      semibold: 600,
      bold: 700
    },
    sizes: [{
      ascenderHeight: 3,
      descenderHeight: 3,
      fontSize: 10,
      iconSize: 17,
      lineHeight: 13,
      letterSpacing: 0
    }, {
      ascenderHeight: 4,
      descenderHeight: 4,
      fontSize: 13,
      iconSize: 21,
      lineHeight: 17,
      letterSpacing: 0
    }, {
      ascenderHeight: 5,
      descenderHeight: 5,
      fontSize: 16,
      iconSize: 25,
      lineHeight: 21,
      letterSpacing: 0
    }, {
      ascenderHeight: 6,
      descenderHeight: 6,
      fontSize: 19,
      iconSize: 29,
      lineHeight: 25,
      letterSpacing: 0
    }, {
      ascenderHeight: 7,
      descenderHeight: 7,
      fontSize: 22,
      iconSize: 33,
      lineHeight: 29,
      letterSpacing: 0
    }]
  }
};
const studioTheme = {
  avatar: {
    sizes: [{
      distance: -3,
      size: 25
    }, {
      distance: -6,
      size: 35
    }, {
      distance: -9,
      size: 55
    }]
  },
  button: {
    textWeight: "medium"
  },
  color,
  container: [320, 640, 960, 1280, 1600, 1920],
  focusRing: {
    offset: 1,
    width: 2
  },
  fonts,
  media: [360, 600, 900, 1200, 1800, 2400],
  radius: [0, 1, 3, 6, 9, 12, 21],
  shadows: [null, {
    umbra: [0, 0, 0, 0],
    penumbra: [0, 0, 0, 0],
    ambient: [0, 0, 0, 0]
  }, {
    umbra: [0, 3, 5, -1],
    penumbra: [0, 6, 10, 0],
    ambient: [0, 1, 18, 0]
  }, {
    umbra: [0, 7, 8, -4],
    penumbra: [0, 12, 17, 2],
    ambient: [0, 5, 22, 4]
  }, {
    umbra: [0, 9, 11, -5],
    penumbra: [0, 18, 28, 2],
    ambient: [0, 7, 34, 6]
  }, {
    umbra: [0, 11, 15, -7],
    penumbra: [0, 24, 38, 3],
    ambient: [0, 9, 46, 8]
  }],
  space: [0, 4, 8, 12, 20, 32, 52, 84, 136, 220],
  input: {
    checkbox: {
      size: 17
    },
    radio: {
      size: 17,
      markSize: 9
    },
    switch: {
      width: 33,
      height: 17,
      padding: 4,
      transitionDurationMs: 150,
      transitionTimingFunction: "ease-out"
    },
    border: {
      width: 1
    }
  }
  // styles: {
  //   button: {
  //     root: {
  //       transition: 'background-color 100ms,border-color 100ms,color 100ms',
  //     },
  //   },
  //   card: {
  //     root: {
  //       transition: 'background-color 100ms,border-color 100ms,color 100ms',
  //     },
  //   },
  // },
};

const DEFAULT_THEME_LAYER = {
  dialog: {
    zOffset: 600
  },
  popover: {
    zOffset: 400
  },
  tooltip: {
    zOffset: 200
  }
};
function getGlobalScope() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof window !== "undefined") return window;
  if (typeof self !== "undefined") return self;
  if (typeof global !== "undefined") return global;
  throw new Error("@sanity/ui: could not locate global scope");
}
const globalScope = getGlobalScope();
const key$7 = Symbol.for("@sanity/ui/context/theme");
globalScope[key$7] = globalScope[key$7] || createContext(null);
const ThemeContext = globalScope[key$7];
function ThemeProvider(props) {
  const parentTheme = useContext(ThemeContext);
  const {
    children,
    scheme = (parentTheme == null ? void 0 : parentTheme.scheme) || "light",
    theme: themeProp = (parentTheme == null ? void 0 : parentTheme.theme) || null,
    tone = (parentTheme == null ? void 0 : parentTheme.tone) || "default"
  } = props;
  const theme = useMemo(() => {
    if (!themeProp) return null;
    const {
      color: rootColor,
      layer: rootLayer,
      ...restTheme
    } = themeProp;
    const colorScheme = rootColor[scheme] || rootColor.light;
    const color = colorScheme[tone] || colorScheme.default;
    const layer = rootLayer || DEFAULT_THEME_LAYER;
    return {
      sanity: {
        ...restTheme,
        color,
        layer
      }
    };
  }, [scheme, themeProp, tone]);
  const value = useMemo(() => themeProp && {
    version: 0,
    theme: themeProp,
    scheme,
    tone
  }, [themeProp, scheme, tone]);
  if (!theme) {
    return /* @__PURE__ */jsx("pre", {
      children: 'ThemeProvider: no "theme" property provided'
    });
  }
  return /* @__PURE__ */jsx(ThemeContext.Provider, {
    value,
    children: /* @__PURE__ */jsx(ThemeProvider$1, {
      theme,
      children
    })
  });
}
function isRecord(value) {
  return Boolean(value && typeof value === "object");
}
function useRootTheme() {
  const value = useContext(ThemeContext);
  if (!value) {
    throw new Error("useRootTheme(): missing context value");
  }
  if (!isRecord(value) || value.version !== 0) {
    throw new Error("useRootTheme(): the context value is not compatible");
  }
  return value;
}
function ThemeColorProvider(props) {
  const {
    children,
    scheme,
    tone
  } = props;
  const root = useRootTheme();
  return /* @__PURE__ */jsx(ThemeProvider, {
    scheme: scheme || root.scheme,
    theme: root.theme,
    tone,
    children
  });
}
function useTheme() {
  return useTheme$1();
}
const MEDIA_STORE_CACHE = /* @__PURE__ */new WeakMap();
function _getMediaQuery(media, index) {
  if (index === 0) {
    return "screen and (max-width: ".concat(media[index] - 1, "px)");
  }
  if (index === media.length) {
    return "screen and (min-width: ".concat(media[index - 1], "px)");
  }
  return "screen and (min-width: ".concat(media[index - 1], "px) and (max-width: ").concat(media[index] - 1, "px)");
}
function _createMediaStore(media) {
  const mediaLen = media.length;
  let sizes;
  const getSizes = () => {
    if (!sizes) {
      sizes = [];
      for (let index = mediaLen; index > -1; index -= 1) {
        const mediaQuery = _getMediaQuery(media, index);
        sizes.push({
          index,
          mq: window.matchMedia(mediaQuery)
        });
      }
    }
    return sizes;
  };
  const getSnapshot = () => {
    for (const {
      index,
      mq
    } of getSizes()) {
      if (mq.matches) return index;
    }
    return 0;
  };
  const subscribe = onStoreChange => {
    const disposeFns = [];
    for (const {
      mq
    } of getSizes()) {
      const handleChange = () => {
        if (mq.matches) onStoreChange();
      };
      mq.addEventListener("change", handleChange);
      disposeFns.push(() => mq.removeEventListener("change", handleChange));
    }
    return () => {
      for (const disposeFn of disposeFns) {
        disposeFn();
      }
    };
  };
  return {
    getSnapshot,
    subscribe
  };
}
function getServerSnapshot$1() {
  return 0;
}
function useMediaIndex() {
  const theme = useTheme();
  const {
    media
  } = theme.sanity;
  let store = MEDIA_STORE_CACHE.get(media);
  if (!store) {
    store = _createMediaStore(media);
    MEDIA_STORE_CACHE.set(media, store);
  }
  return useSyncExternalStore(store.subscribe, store.getSnapshot, getServerSnapshot$1);
}
let MEDIA_QUERY_CACHE;
function getMatchMedia() {
  if (!MEDIA_QUERY_CACHE) {
    MEDIA_QUERY_CACHE = window.matchMedia("(prefers-color-scheme: dark)");
  }
  return MEDIA_QUERY_CACHE;
}
function subscribe(onStoreChange) {
  const matchMedia = getMatchMedia();
  matchMedia.addEventListener("change", onStoreChange);
  return () => matchMedia.removeEventListener("change", onStoreChange);
}
function getSnapshot() {
  return getMatchMedia().matches;
}
function getServerSnapshot() {
  return false;
}
function usePrefersDark() {
  return useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
}
const useIsomorphicEffect = typeof window !== "undefined" ? useLayoutEffect : useEffect;
function useForwardedRef(ref) {
  const innerRef = useRef(null);
  useIsomorphicEffect(() => {
    if (!ref) return;
    if (typeof ref === "function") {
      ref(innerRef.current);
    } else {
      ref.current = innerRef.current;
    }
  });
  return innerRef;
}
function useCustomValidity(ref, customValidity) {
  useEffect(() => {
    if (ref.current) {
      ref.current.setCustomValidity(customValidity || "");
    }
  }, [customValidity, ref]);
}
const BORDER_VALUE = "1px solid var(--card-border-color)";
function responsiveBorderStyle() {
  return [border, borderTop, borderRight, borderBottom, borderLeft];
}
function border(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$border, value => value ? {
    "&&": {
      border: BORDER_VALUE
    }
  } : {
    "&&": {
      border: 0
    }
  });
}
function borderTop(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$borderTop, value => value ? {
    "&&": {
      borderTop: BORDER_VALUE
    }
  } : {
    "&&": {
      borderTop: 0
    }
  });
}
function borderRight(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$borderRight, value => value ? {
    "&&": {
      borderRight: BORDER_VALUE
    }
  } : {
    "&&": {
      borderRight: 0
    }
  });
}
function borderBottom(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$borderBottom, value => value ? {
    "&&": {
      borderBottom: BORDER_VALUE
    }
  } : {
    "&&": {
      borderBottom: 0
    }
  });
}
function borderLeft(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$borderLeft, value => value ? {
    "&&": {
      borderLeft: BORDER_VALUE
    }
  } : {
    "&&": {
      borderLeft: 0
    }
  });
}
const BASE_STYLE$4 = {
  '&[data-as="ul"],&[data-as="ol"]': {
    listStyle: "none"
  }
};
const BOX_SIZING = {
  content: "content-box",
  border: "border-box"
};
const BOX_HEIGHT = {
  stretch: "stretch",
  fill: "100%"
};
function boxStyle() {
  return BASE_STYLE$4;
}
function responsiveBoxStyle() {
  return [responsiveBoxSizingStyle, responsiveBoxHeightStyle, responsiveBoxOverflowStyle, responsiveBoxDisplayStyle];
}
function responsiveBoxDisplayStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$display, display => ({
    "&:not([hidden])": {
      display
    }
  }));
}
function responsiveBoxSizingStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$sizing, sizing => ({
    boxSizing: BOX_SIZING[sizing]
  }));
}
function responsiveBoxHeightStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$height, height => ({
    height: BOX_HEIGHT[height]
  }));
}
function responsiveBoxOverflowStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$overflow, overflow => ({
    overflow
  }));
}
const BASE_STYLE$3 = {
  "&&:not([hidden])": {
    display: "flex"
  }
};
function responsiveFlexStyle() {
  return [BASE_STYLE$3, responsiveFlexAlignStyle, responsiveFlexGapStyle, responsiveFlexWrapStyle, responsiveFlexJustifyStyle, responsiveFlexDirectionStyle];
}
function responsiveFlexAlignStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$align, align => {
    return {
      alignItems: align
    };
  });
}
function responsiveFlexGapStyle(props) {
  const {
    theme
  } = props;
  const {
    media,
    space
  } = theme.sanity;
  return _responsive(media, props.$gap, gap => ({
    gap: gap ? rem(space[gap]) : void 0
  }));
}
function responsiveFlexWrapStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$wrap, wrap => {
    return {
      flexWrap: wrap
    };
  });
}
function responsiveFlexJustifyStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$justify, justify => {
    return {
      justifyContent: justify
    };
  });
}
function responsiveFlexDirectionStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$direction, direction => {
    return {
      flexDirection: direction
    };
  });
}
const BASE_STYLE$2 = {
  minWidth: 0,
  minHeight: 0
};
function flexItemStyle() {
  return [BASE_STYLE$2, responsiveFlexItemStyle];
}
function responsiveFlexItemStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  if (!props.$flex) return EMPTY_ARRAY;
  return _responsive(media, props.$flex, flex => ({
    flex
  }));
}
function focusRingBorderStyle(border) {
  return "inset 0 0 0 ".concat(border.width, "px ").concat(border.color);
}
function focusRingStyle(opts) {
  const {
    base,
    border,
    focusRing
  } = opts;
  const focusRingOutsetWidth = focusRing.offset + focusRing.width;
  const focusRingInsetWidth = 0 - focusRing.offset;
  const bgColor = base ? base.bg : "var(--card-bg-color)";
  return [focusRingInsetWidth > 0 && "inset 0 0 0 ".concat(focusRingInsetWidth, "px var(--card-focus-ring-color)"), border && focusRingBorderStyle(border), focusRingInsetWidth < 0 && "0 0 0 ".concat(0 - focusRingInsetWidth, "px ").concat(bgColor), focusRingOutsetWidth > 0 && "0 0 0 ".concat(focusRingOutsetWidth, "px var(--card-focus-ring-color)")].filter(Boolean).join(",");
}
const GRID_CSS = {
  "&&:not([hidden])": {
    display: "grid"
  },
  '&[data-as="ul"],&[data-as="ol"]': {
    listStyle: "none"
  }
};
const GRID_AUTO_COLUMS = {
  auto: "auto",
  min: "min-content",
  max: "max-content",
  fr: "minmax(0, 1fr)"
};
const GRID_AUTO_ROWS = {
  auto: "auto",
  min: "min-content",
  max: "max-content",
  fr: "minmax(0, 1fr)"
};
function responsiveGridStyle() {
  return [GRID_CSS, responsiveGridAutoFlowStyle, responsiveGridAutoRowsStyle, responsiveGridAutoColsStyle, responsiveGridColumnsStyle, responsiveGridRowsStyle, responsiveGridGapStyle, responsiveGridGapXStyle, responsiveGridGapYStyle];
}
function responsiveGridAutoFlowStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$autoFlow, autoFlow => ({
    gridAutoFlow: autoFlow
  }));
}
function responsiveGridAutoRowsStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$autoRows, autoRows => ({
    gridAutoRows: autoRows && GRID_AUTO_ROWS[autoRows]
  }));
}
function responsiveGridAutoColsStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$autoCols, autoCols => ({
    gridAutoColumns: autoCols && GRID_AUTO_COLUMS[autoCols]
  }));
}
function responsiveGridColumnsStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$columns, columns => ({
    gridTemplateColumns: columns && "repeat(".concat(columns, ",minmax(0,1fr));")
  }));
}
function responsiveGridRowsStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$rows, rows => ({
    gridTemplateRows: rows && "repeat(".concat(rows, ",minmax(0,1fr));")
  }));
}
function responsiveGridGapStyle(props) {
  const {
    theme
  } = props;
  const {
    media,
    space
  } = theme.sanity;
  return _responsive(media, props.$gap, gap => ({
    gridGap: gap ? rem(space[gap]) : void 0
  }));
}
function responsiveGridGapXStyle(props) {
  const {
    theme
  } = props;
  const {
    media,
    space
  } = theme.sanity;
  return _responsive(media, props.$gapX, gapX => ({
    columnGap: gapX ? rem(space[gapX]) : void 0
  }));
}
function responsiveGridGapYStyle(props) {
  const {
    theme
  } = props;
  const {
    media,
    space
  } = theme.sanity;
  return _responsive(media, props.$gapY, gapY => ({
    rowGap: gapY ? rem(space[gapY]) : void 0
  }));
}
function responsiveGridItemStyle() {
  return [responsiveGridItemRowStyle, responsiveGridItemRowStartStyle, responsiveGridItemRowEndStyle, responsiveGridItemColumnStyle, responsiveGridItemColumnStartStyle, responsiveGridItemColumnEndStyle];
}
const GRID_ITEM_ROW = {
  auto: "auto",
  full: "1 / -1"
};
const GRID_ITEM_COLUMN = {
  auto: "auto",
  full: "1 / -1"
};
function responsiveGridItemRowStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$row, row => {
    if (typeof row === "number") {
      return {
        gridRow: "span ".concat(row, " / span ").concat(row)
      };
    }
    return {
      gridRow: GRID_ITEM_ROW[row]
    };
  });
}
function responsiveGridItemRowStartStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$rowStart, rowStart => ({
    gridRowStart: rowStart
  }));
}
function responsiveGridItemRowEndStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$rowEnd, rowEnd => ({
    gridRowEnd: rowEnd
  }));
}
function responsiveGridItemColumnStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$column, column => {
    if (typeof column === "number") {
      return {
        gridColumn: "span ".concat(column, " / span ").concat(column)
      };
    }
    return {
      gridColumn: GRID_ITEM_COLUMN[column]
    };
  });
}
function responsiveGridItemColumnStartStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$columnStart, columnStart => ({
    gridColumnStart: columnStart
  }));
}
function responsiveGridItemColumnEndStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$columnEnd, columnEnd => ({
    gridColumnEnd: columnEnd
  }));
}
function responsiveInputPaddingStyle(props) {
  const {
    $fontSize,
    $iconLeft,
    $iconRight,
    $padding,
    $space,
    theme
  } = props;
  const {
    fonts,
    media,
    space: spaceScale
  } = theme.sanity;
  const len = Math.max($padding.length, $space.length, $fontSize.length);
  const _padding = [];
  const _space = [];
  const _fontSize = [];
  for (let i = 0; i < len; i += 1) {
    _fontSize[i] = $fontSize[i] === void 0 ? _fontSize[i - 1] : $fontSize[i];
    _padding[i] = $padding[i] === void 0 ? _padding[i - 1] : $padding[i];
    _space[i] = $space[i] === void 0 ? _space[i - 1] : $space[i];
  }
  return _responsive(media, _padding, (_, i) => {
    const size = fonts.text.sizes[_fontSize[i]] || fonts.text.sizes[2];
    const emSize = size.lineHeight - size.ascenderHeight - size.descenderHeight;
    const p = spaceScale[_padding[i]];
    const s = spaceScale[_space[i]];
    const styles = {
      paddingTop: rem(p - size.ascenderHeight),
      paddingRight: rem(p),
      paddingBottom: rem(p - size.descenderHeight),
      paddingLeft: rem(p)
    };
    if ($iconRight) styles.paddingRight = rem(p + emSize + s);
    if ($iconLeft) styles.paddingLeft = rem(p + emSize + s);
    return styles;
  });
}
function responsiveInputPaddingIconRightStyle(props) {
  return responsiveInputPaddingStyle({
    ...props,
    $iconRight: true
  });
}
const ROOT_STYLE = css(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  &:not([hidden]) {\n    display: flex;\n  }\n\n  align-items: center;\n"])));
function textInputRootStyle() {
  return ROOT_STYLE;
}
function textInputBaseStyle(props) {
  const {
    theme,
    $scheme,
    $tone,
    $weight
  } = props;
  const font = theme.sanity.fonts.text;
  const color = theme.sanity.color.input;
  return css(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n    appearance: none;\n    background: none;\n    border: 0;\n    border-radius: 0;\n    outline: none;\n    width: 100%;\n    box-sizing: border-box;\n    font-family: ", ";\n    font-weight: ", ";\n    margin: 0;\n    position: relative;\n    z-index: 1;\n    display: block;\n\n    /* NOTE: This is a hack to disable Chrome\u2019s autofill styles */\n    &:-webkit-autofill,\n    &:-webkit-autofill:hover,\n    &:-webkit-autofill:focus,\n    &:-webkit-autofill:active {\n      -webkit-text-fill-color: var(--input-fg-color) !important;\n      transition: background-color 5000s;\n      transition-delay: 86400s /* 24h */;\n    }\n\n    /* &:is(textarea) */\n    &[data-as='textarea'] {\n      resize: none;\n    }\n\n    color: var(--input-fg-color);\n\n    &::placeholder {\n      color: var(--input-placeholder-color);\n    }\n\n    &[data-scheme='", "'][data-tone='", "'] {\n      --input-fg-color: ", ";\n      --input-placeholder-color: ", ";\n\n      /* enabled */\n      &:not(:invalid):not(:disabled):not(:read-only) {\n        --input-fg-color: ", ";\n        --input-placeholder-color: ", ";\n      }\n\n      /* disabled */\n      &:not(:invalid):disabled {\n        --input-fg-color: ", ";\n        --input-placeholder-color: ", ";\n      }\n\n      /* invalid */\n      &:invalid {\n        --input-fg-color: ", ";\n        --input-placeholder-color: ", ";\n      }\n\n      /* readOnly */\n      &:read-only {\n        --input-fg-color: ", ";\n        --input-placeholder-color: ", ";\n      }\n    }\n  "])), font.family, $weight && font.weights[$weight] || font.weights.regular, $scheme, $tone, color.default.enabled.fg, color.default.enabled.placeholder, color.default.enabled.fg, color.default.enabled.placeholder, color.default.disabled.fg, color.default.disabled.placeholder, color.invalid.enabled.fg, color.invalid.enabled.placeholder, color.default.readOnly.fg, color.default.readOnly.placeholder);
}
function textInputFontSizeStyle(props) {
  const {
    theme
  } = props;
  const {
    fonts,
    media
  } = theme.sanity;
  return _responsive(media, props.$fontSize, sizeIndex => {
    const size = fonts.text.sizes[sizeIndex] || fonts.text.sizes[2];
    return {
      fontSize: rem(size.fontSize),
      lineHeight: size.lineHeight / size.fontSize
    };
  });
}
function textInputRepresentationStyle(props) {
  const {
    $hasPrefix,
    $hasSuffix,
    $scheme,
    $tone,
    theme
  } = props;
  const {
    focusRing,
    input
  } = theme.sanity;
  const color = theme.sanity.color.input;
  return css(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["\n    --input-box-shadow: none;\n\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    display: block;\n    pointer-events: none;\n    z-index: 0;\n\n    background-color: var(--card-bg-color);\n    box-shadow: var(--input-box-shadow);\n\n    border-top-left-radius: ", ";\n    border-bottom-left-radius: ", ";\n    border-top-right-radius: ", ";\n    border-bottom-right-radius: ", ";\n\n    &[data-scheme='", "'][data-tone='", "'] {\n      --card-bg-color: ", ";\n      --card-fg-color: ", ";\n\n      /* enabled */\n      *:not(:disabled) + &[data-border] {\n        --input-box-shadow: ", ";\n      }\n\n      /* invalid */\n      *:not(:disabled):invalid + & {\n        --card-bg-color: ", ";\n        --card-fg-color: ", ";\n\n        &[data-border] {\n          --input-box-shadow: ", ";\n        }\n      }\n\n      /* focused */\n      *:not(:disabled):focus + & {\n        &[data-border] {\n          --input-box-shadow: ", ";\n        }\n\n        &:not([data-border]) {\n          --input-box-shadow: ", ";\n        }\n      }\n\n      /* disabled */\n      *:disabled + & {\n        --card-bg-color: ", " !important;\n        --card-fg-color: ", " !important;\n\n        &[data-border] {\n          --input-box-shadow: ", ";\n        }\n      }\n\n      /* readOnly */\n      *:read-only + & {\n        --card-bg-color: ", " !important;\n        --card-fg-color: ", " !important;\n      }\n\n      /* hovered */\n      @media (hover: hover) {\n        *:not(:disabled):not(:read-only):not(:invalid):hover + & {\n          --card-bg-color: ", ";\n          --card-fg-color: ", ";\n        }\n\n        *:not(:disabled):not(:read-only):not(:invalid):not(:focus):hover + &[data-border] {\n          --input-box-shadow: ", ";\n        }\n      }\n    }\n  "])), $hasPrefix ? 0 : void 0, $hasPrefix ? 0 : void 0, $hasSuffix ? 0 : void 0, $hasSuffix ? 0 : void 0, $scheme, $tone, color.default.enabled.bg, color.default.enabled.fg, focusRingBorderStyle({
    color: color.default.enabled.border,
    width: input.border.width
  }), color.invalid.enabled.bg, color.invalid.enabled.fg, focusRingBorderStyle({
    color: color.invalid.enabled.border,
    width: input.border.width
  }), focusRingStyle({
    border: {
      color: color.default.enabled.border,
      width: input.border.width
    },
    focusRing
  }), focusRingStyle({
    focusRing
  }), color.default.disabled.bg, color.default.disabled.fg, focusRingBorderStyle({
    color: color.default.disabled.border,
    width: input.border.width
  }), color.default.readOnly.bg, color.default.readOnly.fg, color.default.hovered.bg, color.default.hovered.fg, focusRingBorderStyle({
    color: color.default.hovered.border,
    width: input.border.width
  }));
}
function responsiveMarginStyle(props) {
  const {
    theme
  } = props;
  return [_getResponsiveSpace(theme, ["margin"], props.$margin), _getResponsiveSpace(theme, ["marginLeft", "marginRight"], props.$marginX), _getResponsiveSpace(theme, ["marginTop", "marginBottom"], props.$marginY), _getResponsiveSpace(theme, ["marginTop"], props.$marginTop), _getResponsiveSpace(theme, ["marginRight"], props.$marginRight), _getResponsiveSpace(theme, ["marginBottom"], props.$marginBottom), _getResponsiveSpace(theme, ["marginLeft"], props.$marginLeft)].filter(Boolean);
}
function responsivePaddingStyle(props) {
  const {
    theme
  } = props;
  return [_getResponsiveSpace(theme, ["padding"], props.$padding), _getResponsiveSpace(theme, ["paddingLeft", "paddingRight"], props.$paddingX), _getResponsiveSpace(theme, ["paddingTop", "paddingBottom"], props.$paddingY), _getResponsiveSpace(theme, ["paddingTop"], props.$paddingTop), _getResponsiveSpace(theme, ["paddingRight"], props.$paddingRight), _getResponsiveSpace(theme, ["paddingBottom"], props.$paddingBottom), _getResponsiveSpace(theme, ["paddingLeft"], props.$paddingLeft)].filter(Boolean);
}
function responsiveRadiusStyle(props) {
  const {
    theme
  } = props;
  const {
    media,
    radius
  } = theme.sanity;
  return _responsive(media, props.$radius, radiusIndex => ({
    borderRadius: rem(radius[radiusIndex])
  }));
}
function toBoxShadow(shadow, color) {
  return "".concat(shadow.map(rem).join(" "), " ").concat(color);
}
function shadowStyle(shadow) {
  if (!shadow) return EMPTY_RECORD;
  const outline = "0 0 0 ".concat(rem(1), " var(--card-shadow-outline-color)");
  const umbra = toBoxShadow(shadow.umbra, "var(--card-shadow-umbra-color)");
  const penumbra = toBoxShadow(shadow.penumbra, "var(--card-shadow-penumbra-color)");
  const ambient = toBoxShadow(shadow.ambient, "var(--card-shadow-ambient-color)");
  return {
    boxShadow: "".concat(outline, ", ").concat(umbra, ", ").concat(penumbra, ", ").concat(ambient)
  };
}
function responsiveShadowStyle(props) {
  const {
    theme
  } = props;
  const {
    media,
    shadows
  } = theme.sanity;
  return _responsive(media, props.$shadow, shadow => shadowStyle(shadows[shadow]));
}
function textBaseStyle(props) {
  const {
    $accent,
    $muted,
    theme
  } = props;
  const {
    weights
  } = theme.sanity.fonts.text;
  return css(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral(["\n    color: var(--card-fg-color);\n\n    ", "\n\n    ", "\n\n    & code {\n      font-family: ", ";\n      border-radius: 1px;\n      background-color: var(--card-code-bg-color);\n      color: var(--card-code-fg-color);\n    }\n\n    & a {\n      text-decoration: none;\n      border-radius: 1px;\n      color: var(--card-link-color);\n      outline: none;\n\n      @media (hover: hover) {\n        &:hover {\n          text-decoration: underline;\n        }\n      }\n\n      &:focus {\n        box-shadow: 0 0 0 1px var(--card-bg-color), 0 0 0 3px var(--card-focus-ring-color);\n      }\n\n      &:focus:not(:focus-visible) {\n        box-shadow: none;\n      }\n    }\n\n    & strong {\n      font-weight: ", ";\n    }\n\n    & svg {\n      /* Certain popular CSS libraries changes the defaults for SVG display */\n      /* Make sure SVGs are rendered as inline elements */\n      display: inline;\n    }\n\n    & [data-sanity-icon] {\n      vertical-align: baseline;\n    }\n  "])), $accent && css(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral(["\n      color: var(--card-accent-fg-color);\n    "]))), $muted && css(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral(["\n      color: var(--card-muted-fg-color);\n    "]))), theme.sanity.fonts.code.family, weights.bold);
}
const Root$E = styled.div(responsiveTextFont, responsiveTextAlignStyle, textBaseStyle);
const SpanWithTextOverflow$2 = styled.span(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral(["\n  display: block;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden;\n"])));
const Text = forwardRef(function Text2(props, ref) {
  const {
    accent = false,
    align,
    children: childrenProp,
    muted = false,
    size = 2,
    textOverflow,
    weight,
    ...restProps
  } = props;
  let children = childrenProp;
  if (textOverflow === "ellipsis") {
    children = /* @__PURE__ */jsx(SpanWithTextOverflow$2, {
      children
    });
  }
  return /* @__PURE__ */jsx(Root$E, {
    "data-ui": "Text",
    ...restProps,
    $accent: accent,
    $align: useArrayProp(align),
    $muted: muted,
    ref,
    $size: useArrayProp(size),
    $weight: weight,
    children: /* @__PURE__ */jsx("span", {
      children
    })
  });
});
const avatarStyle = {
  root: avatarRootStyle,
  arrow: avatarArrowStyle,
  bgStroke: avatarBgStrokeStyle,
  stroke: avatarStrokeStyle,
  initials: avatarInitialsStyle
};
function avatarArrowStyle() {
  return {
    position: "absolute",
    boxSizing: "border-box",
    zIndex: 0,
    opacity: 0,
    transition: "all 0.2s linear",
    transform: "rotate(-90deg) translate3d(0, 6px, 0)",
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    "& > svg": {
      width: "11px",
      height: "7px",
      position: "absolute",
      top: "-5px",
      left: "50%",
      transform: "translateX(-6px)",
      "&:not([hidden])": {
        display: "block"
      }
    },
    "[data-arrow-position='inside'] > &": {
      transform: "rotate(-90deg) translate3d(0, 6px, 0)",
      opacity: 0
    },
    "[data-arrow-position='top'] > &": {
      opacity: 1,
      transform: "rotate(0deg)"
    },
    "[data-arrow-position='bottom'] > &": {
      opacity: 1,
      transform: "rotate(-180deg)"
    }
  };
}
function avatarRootStyle(props) {
  const {
    $color,
    theme
  } = props;
  const {
    focusRing
  } = theme.sanity;
  return {
    backgroundColor: $color,
    position: "relative",
    boxSizing: "border-box",
    userSelect: "none",
    boxShadow: "0 0 0 1px var(--card-bg-color)",
    '&[data-status="inactive"]': {
      opacity: 0.5
    },
    "&>svg": {
      "&:not([hidden])": {
        display: "block"
      }
    },
    /* &:is(button) */
    '&[data-as="button"]': {
      "-webkit-font-smoothing": "inherit",
      appearance: "none",
      margin: 0,
      padding: 0,
      border: 0,
      font: "inherit",
      color: "inherit",
      outline: "none",
      "&:focus": {
        boxShadow: focusRingStyle({
          focusRing
        })
      },
      "&:focus:not(:focus-visible)": {
        boxShadow: "none"
      }
    }
  };
}
function responsiveAvatarSizeStyle(props) {
  const {
    theme
  } = props;
  const {
    avatar,
    media
  } = theme.sanity;
  return _responsive(media, props.$size, size => {
    const avatarSize = avatar.sizes[size] || avatar.sizes[0];
    return {
      width: rem(avatarSize.size),
      height: rem(avatarSize.size),
      borderRadius: rem(avatarSize.size / 2),
      "&>svg": {
        width: rem(avatarSize.size),
        height: rem(avatarSize.size),
        borderRadius: rem(avatarSize.size / 2)
      }
    };
  });
}
function avatarInitialsStyle(props) {
  const {
    theme
  } = props;
  const {
    base
  } = theme.sanity.color;
  return {
    width: "100%",
    height: "100%",
    color: base.fg,
    alignItems: "center",
    justifyContent: "center",
    textTransform: "uppercase",
    textAlign: "center",
    borderRadius: "50%",
    "&:not([hidden])": {
      display: "flex"
    }
  };
}
function avatarBgStrokeStyle() {
  return {
    strokeWidth: "4px",
    stroke: "var(--card-bg-color)"
  };
}
function avatarStrokeStyle() {
  return {
    strokeWidth: "3px",
    '[data-status="editing"] &': {
      strokeSasharray: "2 4",
      strokeLinecap: "round"
    }
  };
}
const Root$D = styled.div(responsiveAvatarSizeStyle, avatarStyle.root);
const Arrow = styled.div(avatarStyle.arrow);
const BgStroke = styled.ellipse(avatarStyle.bgStroke);
const Stroke = styled.ellipse(avatarStyle.stroke);
const Initials = styled.div(avatarStyle.initials);
const Avatar = forwardRef(function Avatar2(props, ref) {
  const {
    as: asProp,
    color: colorKey = "gray",
    src,
    title,
    initials,
    onImageLoadError,
    arrowPosition: arrowPositionProp,
    animateArrowFrom,
    status = "online",
    size: sizeProp = 0,
    ...restProps
  } = props;
  const as = ReactIs.isValidElementType(asProp) ? asProp : "div";
  const size = useArrayProp(sizeProp);
  const theme = useTheme();
  const color = theme.sanity.color.spot[colorKey] || theme.sanity.color.spot.gray;
  const avatarSize = theme.sanity.avatar.sizes[size[0]] || theme.sanity.avatar.sizes[0];
  const _sizeRem = avatarSize.size;
  const _radius = _sizeRem / 2;
  const elementId = useId();
  const [arrowPosition, setArrowPosition] = useState(animateArrowFrom || arrowPositionProp || "inside");
  const [imageFailed, setImageFailed] = useState(false);
  const imageId = "avatar-image-".concat(elementId);
  useEffect(() => {
    if (arrowPosition === arrowPositionProp) return void 0;
    const raf = requestAnimationFrame(() => setArrowPosition(arrowPositionProp));
    return () => cancelAnimationFrame(raf);
  }, [arrowPosition, arrowPositionProp]);
  useEffect(() => {
    if (src) setImageFailed(false);
  }, [src]);
  const handleImageError = useCallback(() => {
    setImageFailed(true);
    if (onImageLoadError) {
      onImageLoadError(new Error("Avatar: the image failed to load"));
    }
  }, [onImageLoadError]);
  const initialsSize = useMemo(() => size.map(s => s === 0 ? 0 : s + 1), [size]);
  return /* @__PURE__ */jsxs(Root$D, {
    as,
    "data-as": typeof as === "string" ? as : void 0,
    "data-ui": "Avatar",
    ...restProps,
    $size: size,
    $color: color,
    "aria-label": title,
    "data-arrow-position": arrowPosition,
    "data-status": status,
    ref,
    title,
    children: [/* @__PURE__ */jsx(Arrow, {
      children: /* @__PURE__ */jsx("svg", {
        width: "11",
        height: "7",
        viewBox: "0 0 11 7",
        fill: "none",
        children: /* @__PURE__ */jsx("path", {
          d: "M6.67948 1.50115L11 7L0 7L4.32052 1.50115C4.92109 0.736796 6.07891 0.736795 6.67948 1.50115Z",
          fill: color
        })
      })
    }), !imageFailed && src && /* @__PURE__ */jsxs("svg", {
      viewBox: "0 0 ".concat(_sizeRem, " ").concat(_sizeRem),
      fill: "none",
      children: [/* @__PURE__ */jsx("defs", {
        children: /* @__PURE__ */jsx("pattern", {
          id: imageId,
          patternContentUnits: "objectBoundingBox",
          width: "1",
          height: "1",
          children: /* @__PURE__ */jsx("image", {
            href: src,
            width: "1",
            height: "1",
            onError: handleImageError
          })
        })
      }), /* @__PURE__ */jsx("circle", {
        cx: _radius,
        cy: _radius,
        r: _radius,
        fill: "url(#".concat(imageId, ")")
      }), /* @__PURE__ */jsx(BgStroke, {
        cx: _radius,
        cy: _radius,
        rx: _radius,
        ry: _radius,
        vectorEffect: "non-scaling-stroke"
      }), /* @__PURE__ */jsx(Stroke, {
        cx: _radius,
        cy: _radius,
        rx: _radius,
        ry: _radius,
        stroke: color,
        vectorEffect: "non-scaling-stroke"
      })]
    }), (imageFailed || !src) && initials && /* @__PURE__ */jsx(Fragment, {
      children: /* @__PURE__ */jsx(Initials, {
        children: /* @__PURE__ */jsx(Text, {
          as: "span",
          size: initialsSize,
          children: /* @__PURE__ */jsx("strong", {
            children: initials
          })
        })
      })
    })]
  });
});
function _responsiveAvatarCounterSizeStyle(props) {
  const {
    theme
  } = props;
  const {
    avatar,
    media
  } = theme.sanity;
  return _responsive(media, props.$size, size => {
    const avatarSize = avatar.sizes[size];
    if (!avatarSize) return EMPTY_RECORD;
    return {
      borderRadius: rem(avatarSize.size / 2),
      minWidth: rem(avatarSize.size),
      height: rem(avatarSize.size)
    };
  });
}
function _avatarCounterBaseStyle(props) {
  const {
    theme
  } = props;
  return css(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral(["\n    align-items: center;\n    justify-content: center;\n    box-sizing: border-box;\n    user-select: none;\n    color: inherit;\n    color: var(--card-fg-color);\n    background: var(--card-bg-color);\n    box-shadow: 0 0 0 1px var(--card-bg-color), inset 0 0 0 1.5px var(--card-hairline-hard-color);\n    padding: 0 ", ";\n\n    &:not([hidden]) {\n      display: flex;\n    }\n  "])), rem(theme.sanity.space[2]));
}
const Root$C = styled.div(_responsiveAvatarCounterSizeStyle, _avatarCounterBaseStyle);
const AvatarCounter = forwardRef(function AvatarCounter2(props, ref) {
  const {
    count,
    size: sizeProp = 0
  } = props;
  const size = useArrayProp(sizeProp);
  const counterSize = useMemo(() => size.map(s => s === 0 ? 0 : s + 1), [size]);
  return /* @__PURE__ */jsx(Root$C, {
    $size: size,
    "data-ui": "AvatarCounter",
    ref,
    children: /* @__PURE__ */jsx(Text, {
      as: "span",
      size: counterSize,
      children: /* @__PURE__ */jsx("strong", {
        children: count
      })
    })
  });
});
function childrenToElementArray(children) {
  const childrenArray = Array.isArray(children) ? children : [children];
  return childrenArray.filter(node => isElement$1(node) || isFragment(node) || typeof node === "string");
}
const BASE_STYLES = css(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral(["\n  white-space: nowrap;\n\n  & > div {\n    vertical-align: top;\n\n    &:not([hidden]) {\n      display: inline-block;\n    }\n  }\n"])));
function avatarStackStyle() {
  return BASE_STYLES;
}
function responsiveAvatarStackSizeStyle(props) {
  const {
    theme
  } = props;
  const {
    avatar,
    media
  } = theme.sanity;
  return _responsive(media, props.$size, size => {
    const avatarSize = avatar.sizes[size];
    if (!avatarSize) return EMPTY_RECORD;
    return {
      "& > div + div": {
        marginLeft: rem(avatarSize.distance)
      }
    };
  });
}
const Root$B = styled.div(responsiveAvatarStackSizeStyle, avatarStackStyle);
const AvatarStack = forwardRef(function AvatarStack2(props, ref) {
  const {
    children: childrenProp,
    maxLength: maxLengthProp = 4,
    size: sizeProp = 0,
    ...restProps
  } = props;
  const children = childrenToElementArray(childrenProp).filter(child => typeof child !== "string");
  const maxLength = Math.max(maxLengthProp, 0);
  const size = useArrayProp(sizeProp);
  const len = children.length;
  const visibleCount = maxLength - 1;
  const extraCount = len - visibleCount;
  const visibleChildren = extraCount > 1 ? children.slice(extraCount, len) : children;
  return /* @__PURE__ */jsxs(Root$B, {
    "data-ui": "AvatarStack",
    ...restProps,
    ref,
    $size: size,
    children: [len === 0 && /* @__PURE__ */jsx("div", {
      children: /* @__PURE__ */jsx(AvatarCounter, {
        count: len
      })
    }), len !== 0 && extraCount > 1 && /* @__PURE__ */jsx("div", {
      children: /* @__PURE__ */jsx(AvatarCounter, {
        count: extraCount,
        size
      })
    }), visibleChildren.map((child, childIndex) => /* @__PURE__ */jsx("div", {
      children: cloneElement(child, {
        size
      })
    }, String(childIndex)))]
  });
});
const Root$A = styled.div(boxStyle, flexItemStyle, responsiveBoxStyle, responsiveGridItemStyle, responsiveMarginStyle, responsivePaddingStyle);
const Box = forwardRef(function Box2(props, ref) {
  const {
    as: asProp = "div",
    column,
    columnStart,
    columnEnd,
    display = "block",
    flex,
    height,
    margin = 0,
    marginX,
    marginY,
    marginTop,
    marginRight,
    marginBottom,
    marginLeft,
    overflow,
    padding = 0,
    paddingX,
    paddingY,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft,
    row,
    rowStart,
    rowEnd,
    sizing,
    ...restProps
  } = props;
  return /* @__PURE__ */jsx(Root$A, {
    "data-as": typeof asProp === "string" ? asProp : void 0,
    "data-ui": "Box",
    ...restProps,
    $column: useArrayProp(column),
    $columnStart: useArrayProp(columnStart),
    $columnEnd: useArrayProp(columnEnd),
    $display: useArrayProp(display),
    $flex: useArrayProp(flex),
    $height: useArrayProp(height),
    $margin: useArrayProp(margin),
    $marginX: useArrayProp(marginX),
    $marginY: useArrayProp(marginY),
    $marginTop: useArrayProp(marginTop),
    $marginRight: useArrayProp(marginRight),
    $marginBottom: useArrayProp(marginBottom),
    $marginLeft: useArrayProp(marginLeft),
    $overflow: useArrayProp(overflow),
    $padding: useArrayProp(padding),
    $paddingX: useArrayProp(paddingX),
    $paddingY: useArrayProp(paddingY),
    $paddingTop: useArrayProp(paddingTop),
    $paddingRight: useArrayProp(paddingRight),
    $paddingBottom: useArrayProp(paddingBottom),
    $paddingLeft: useArrayProp(paddingLeft),
    $row: useArrayProp(row),
    $rowStart: useArrayProp(rowStart),
    $rowEnd: useArrayProp(rowEnd),
    $sizing: useArrayProp(sizing),
    as: asProp,
    ref,
    children: props.children
  });
});
function labelBaseStyle(props) {
  const {
    $accent,
    $muted,
    theme
  } = props;
  const {
    fonts
  } = theme.sanity;
  return css(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral(["\n    text-transform: uppercase;\n\n    ", "\n\n    ", "\n\n    & code {\n      font-family: ", ";\n      border-radius: 1px;\n    }\n\n    & a {\n      text-decoration: none;\n      border-radius: 1px;\n    }\n\n    & svg {\n      /* Certain popular CSS libraries changes the defaults for SVG display */\n      /* Make sure SVGs are rendered as inline elements */\n      display: inline;\n    }\n\n    & [data-sanity-icon] {\n      vertical-align: baseline;\n    }\n  "])), $accent && css(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral(["\n      color: var(--card-accent-fg-color);\n    "]))), $muted && css(_templateObject12 || (_templateObject12 = _taggedTemplateLiteral(["\n      color: var(--card-muted-fg-color);\n    "]))), fonts.code.family);
}
const Root$z = styled.div(responsiveLabelFont, responsiveTextAlignStyle, labelBaseStyle);
const SpanWithTextOverflow$1 = styled.span(_templateObject13 || (_templateObject13 = _taggedTemplateLiteral(["\n  display: block;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden;\n"])));
const Label = forwardRef(function Label2(props, ref) {
  const {
    accent,
    align,
    children: childrenProp,
    muted = false,
    size = 2,
    textOverflow,
    weight,
    ...restProps
  } = props;
  let children = childrenProp;
  if (textOverflow === "ellipsis") {
    children = /* @__PURE__ */jsx(SpanWithTextOverflow$1, {
      children
    });
  } else {
    children = /* @__PURE__ */jsx("span", {
      children
    });
  }
  return /* @__PURE__ */jsx(Root$z, {
    "data-ui": "Label",
    ...restProps,
    $accent: accent,
    $align: useArrayProp(align),
    $muted: muted,
    $size: useArrayProp(size),
    $weight: weight,
    ref,
    children
  });
});
function badgeStyle(props) {
  const {
    $mode,
    $tone,
    theme
  } = props;
  const palette = theme.sanity.color[$mode === "outline" ? "muted" : "solid"];
  const color = palette[$tone] || palette.default;
  return {
    backgroundColor: color.enabled.bg,
    color: color.enabled.fg,
    boxShadow: "inset 0 0 0 1px ".concat(color.enabled.border),
    cursor: "default",
    "&:not([hidden])": {
      display: "inline-block"
    }
  };
}
const Root$y = styled(Box)(responsiveRadiusStyle, badgeStyle);
const Badge = forwardRef(function Badge2(props, ref) {
  const {
    children,
    fontSize,
    mode = "default",
    padding = 1,
    radius = 2,
    tone = "default",
    ...restProps
  } = props;
  return /* @__PURE__ */jsx(Root$y, {
    "data-ui": "Badge",
    ...restProps,
    $mode: mode,
    $tone: tone,
    $radius: useArrayProp(radius),
    padding: useArrayProp(padding),
    ref,
    children: /* @__PURE__ */jsx(Label, {
      size: fontSize,
      children
    })
  });
});
const Root$x = styled(Box)(flexItemStyle, responsiveFlexStyle);
const Flex = forwardRef(function Flex2(props, ref) {
  const {
    align,
    as,
    direction = "row",
    gap,
    justify,
    wrap,
    ...restProps
  } = props;
  return /* @__PURE__ */jsx(Root$x, {
    "data-ui": "Flex",
    ...restProps,
    $align: useArrayProp(align),
    $direction: useArrayProp(direction),
    $gap: useArrayProp(gap),
    $justify: useArrayProp(justify),
    $wrap: useArrayProp(wrap),
    forwardedAs: as,
    ref
  });
});
const rotate$1 = keyframes(_templateObject14 || (_templateObject14 = _taggedTemplateLiteral(["\n  from {\n    transform: rotate(0deg);\n  }\n\n  to {\n    transform: rotate(360deg);\n  }\n"])));
const Root$w = styled(Text)(_templateObject15 || (_templateObject15 = _taggedTemplateLiteral(["\n  & > span > svg {\n    animation: ", " 500ms linear infinite;\n  }\n"])), rotate$1);
const Spinner = forwardRef(function Spinner2(props, ref) {
  return /* @__PURE__ */jsx(Root$w, {
    "data-ui": "Spinner",
    ...props,
    ref,
    children: /* @__PURE__ */jsx(SpinnerIcon, {})
  });
});
function _colorVarsStyle(base, color) {
  let checkered = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var _a, _b, _c, _d, _e, _f, _g, _h;
  return {
    // Base
    // @todo: rename to "--base-"?
    "--card-shadow-outline-color": base.shadow.outline,
    "--card-shadow-umbra-color": base.shadow.umbra,
    "--card-shadow-penumbra-color": base.shadow.penumbra,
    "--card-shadow-ambient-color": base.shadow.ambient,
    "--card-focus-ring-color": base.focusRing,
    // Card
    "--card-bg-color": color.bg,
    "--card-bg-image": checkered ? "repeating-conic-gradient(".concat(color.bg, " 0% 25%, ").concat(color.bg2 || color.bg, " 0% 50%)") : void 0,
    "--card-fg-color": color.fg,
    "--card-border-color": color.border,
    "--card-muted-fg-color": (_a = color.muted) == null ? void 0 : _a.fg,
    "--card-accent-fg-color": (_b = color.accent) == null ? void 0 : _b.fg,
    "--card-link-fg-color": (_c = color.link) == null ? void 0 : _c.fg,
    "--card-code-bg-color": (_d = color.code) == null ? void 0 : _d.bg,
    "--card-code-fg-color": (_e = color.code) == null ? void 0 : _e.fg,
    "--card-skeleton-color-from": (_f = color.skeleton) == null ? void 0 : _f.from,
    "--card-skeleton-color-to": (_g = color.skeleton) == null ? void 0 : _g.to,
    // @todo: deprecate
    "--card-link-color": (_h = color.link) == null ? void 0 : _h.fg,
    "--card-hairline-soft-color": color.border,
    "--card-hairline-hard-color": color.border
  };
}
function buttonBaseStyles() {
  return css(_templateObject16 || (_templateObject16 = _taggedTemplateLiteral(["\n    -webkit-font-smoothing: inherit;\n    appearance: none;\n    display: inline-flex;\n    align-items: center;\n    font: inherit;\n    border: 0;\n    outline: none;\n    user-select: none;\n    text-decoration: none;\n    border: 0;\n    box-sizing: border-box;\n    padding: 0;\n    margin: 0;\n    white-space: nowrap;\n    text-align: left;\n    position: relative;\n\n    & > span {\n      display: block;\n      flex: 1;\n      min-width: 0;\n      border-radius: inherit;\n    }\n\n    &::-moz-focus-inner {\n      border: 0;\n      padding: 0;\n    }\n  "])));
}
const buttonTheme = {
  border: {
    width: 1
  }
};
function buttonColorStyles(props) {
  var _a, _b;
  const {
    $mode,
    theme
  } = props;
  const {
    focusRing
  } = theme.sanity;
  const base = theme.sanity.color.base;
  const mode = theme.sanity.color.button[$mode] || theme.sanity.color.button.default;
  const color = mode[props.$tone] || mode.default;
  const border = {
    width: buttonTheme.border.width,
    color: "var(--card-border-color)"
  };
  return [_colorVarsStyle(base, color.enabled), {
    backgroundColor: "var(--card-bg-color)",
    color: "var(--card-fg-color)",
    boxShadow: focusRingBorderStyle(border),
    '&:disabled, &[data-disabled="true"]': _colorVarsStyle(base, color.disabled),
    "&:not([data-disabled='true'])": {
      "&:focus": {
        boxShadow: focusRingStyle({
          base,
          border,
          focusRing
        })
      },
      "&:focus:not(:focus-visible)": {
        boxShadow: focusRingBorderStyle(border)
      },
      "@media (hover: hover)": {
        "&:hover": _colorVarsStyle(base, color.hovered),
        "&:active": _colorVarsStyle(base, color.pressed)
      },
      "&[data-selected]": _colorVarsStyle(base, color.pressed)
    }
  }, (_b = (_a = theme.sanity.styles) == null ? void 0 : _a.button) == null ? void 0 : _b.root].filter(Boolean);
}
const Root$v = styled.button(responsiveRadiusStyle, buttonBaseStyles, buttonColorStyles);
const LoadingBox = styled.div(_templateObject17 || (_templateObject17 = _taggedTemplateLiteral(["\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background-color: var(--card-bg-color);\n  border-radius: inherit;\n  z-index: 1;\n  box-shadow: inherit;\n"])));
const Button = forwardRef(function Button2(props, ref) {
  const {
    children,
    disabled,
    fontSize,
    icon,
    iconRight,
    justify: justifyProp = "center",
    loading,
    mode = "default",
    padding: paddingProp = 3,
    paddingX: paddingXProp,
    paddingY: paddingYProp,
    paddingTop: paddingTopProp,
    paddingBottom: paddingBottomProp,
    paddingLeft: paddingLeftProp,
    paddingRight: paddingRightProp,
    radius: radiusProp = 2,
    selected,
    space: spaceProp = 3,
    text,
    textAlign,
    tone = "default",
    type = "button",
    ...restProps
  } = props;
  const justify = useArrayProp(justifyProp);
  const padding = useArrayProp(paddingProp);
  const paddingX = useArrayProp(paddingXProp);
  const paddingY = useArrayProp(paddingYProp);
  const paddingTop = useArrayProp(paddingTopProp);
  const paddingBottom = useArrayProp(paddingBottomProp);
  const paddingLeft = useArrayProp(paddingLeftProp);
  const paddingRight = useArrayProp(paddingRightProp);
  const radius = useArrayProp(radiusProp);
  const space = useArrayProp(spaceProp);
  const theme = useTheme();
  const boxProps = useMemo(() => ({
    // flex: 1,
    padding,
    paddingX,
    paddingY,
    paddingTop,
    paddingBottom,
    paddingLeft,
    paddingRight
  }), [padding, paddingX, paddingY, paddingTop, paddingBottom, paddingLeft, paddingRight]);
  return /* @__PURE__ */jsxs(Root$v, {
    "data-ui": "Button",
    ...restProps,
    $mode: mode,
    $radius: radius,
    $tone: tone,
    "data-disabled": Boolean(loading || disabled),
    "data-selected": selected ? "" : void 0,
    disabled: Boolean(loading || disabled),
    ref,
    type,
    children: [Boolean(loading) && /* @__PURE__ */jsx(LoadingBox, {
      children: /* @__PURE__ */jsx(Spinner, {})
    }), (icon || text || iconRight) && /* @__PURE__ */jsx(Box, {
      as: "span",
      ...boxProps,
      children: /* @__PURE__ */jsxs(Flex, {
        as: "span",
        justify,
        children: [icon && /* @__PURE__ */jsxs(Text, {
          size: fontSize,
          children: [isValidElement(icon) && icon, isValidElementType(icon) && createElement(icon)]
        }), text && /* @__PURE__ */jsx(Box, {
          flex: iconRight ? 1 : void 0,
          marginLeft: icon ? space : void 0,
          marginRight: iconRight ? space : void 0,
          children: /* @__PURE__ */jsx(Text, {
            align: textAlign,
            size: fontSize,
            textOverflow: "ellipsis",
            weight: theme.sanity.button.textWeight,
            children: text
          })
        }), iconRight && /* @__PURE__ */jsxs(Text, {
          size: fontSize,
          children: [isValidElement(iconRight) && iconRight, isValidElementType(iconRight) && createElement(iconRight)]
        })]
      })
    }), children && /* @__PURE__ */jsx(Box, {
      as: "span",
      ...boxProps,
      children
    })]
  });
});
function cardStyle(props) {
  return [cardBaseStyle(props), cardColorStyle(props)];
}
function cardBaseStyle(props) {
  const {
    $checkered,
    theme
  } = props;
  const space = theme.sanity.space;
  return css(_templateObject18 || (_templateObject18 = _taggedTemplateLiteral(["\n    ", "\n\n    &[data-as='button'] {\n      -webkit-font-smoothing: inherit;\n      appearance: none;\n      outline: none;\n      font: inherit;\n      text-align: inherit;\n      border: 0;\n      width: stretch;\n    }\n\n    /* &:is(a) */\n    &[data-as='a'] {\n      outline: none;\n      text-decoration: none;\n    }\n\n    /* &:is(pre) */\n    &[data-as='pre'] {\n      font: inherit;\n    }\n  "])), $checkered && css(_templateObject19 || (_templateObject19 = _taggedTemplateLiteral(["\n      background-size: ", "px ", "px;\n      background-position: 50% 50%;\n      background-image: var(--card-bg-image);\n    "])), space[3], space[3]));
}
function cardColorStyle(props) {
  var _a, _b;
  const {
    $checkered,
    $focusRing,
    theme
  } = props;
  const {
    focusRing
  } = theme.sanity;
  const {
    base,
    card,
    dark
  } = theme.sanity.color;
  const border = {
    width: 0,
    color: "var(--card-border-color)"
  };
  return css(_templateObject20 || (_templateObject20 = _taggedTemplateLiteral(["\n    color-scheme: ", ";\n\n    ", "\n\n    background-color: var(--card-bg-color);\n    color: var(--card-fg-color);\n\n    /* &:is(button) */\n    &[data-as='button'] {\n      --card-focus-ring-box-shadow: none;\n\n      cursor: default;\n      box-shadow: var(--card-focus-ring-box-shadow);\n\n      &:disabled {\n        ", "\n      }\n\n      &:not(:disabled) {\n        &[data-pressed] {\n          ", "\n        }\n\n        &[data-selected] {\n          ", "\n        }\n\n        @media (hover: hover) {\n          &:not([data-pressed]):not([data-selected]) {\n            &:hover {\n              ", "\n            }\n\n            &:active {\n              ", "\n            }\n          }\n        }\n\n        &:focus {\n          --card-focus-ring-box-shadow: ", ";\n        }\n\n        &:focus:not(:focus-visible) {\n          --card-focus-ring-box-shadow: ", ";\n        }\n      }\n    }\n\n    /* &:is(a) */\n    &[data-as='a'] {\n      cursor: pointer;\n      box-shadow: var(--card-focus-ring-box-shadow);\n\n      &[data-disabled] {\n        ", "\n      }\n\n      &:not([data-disabled]) {\n        &[data-pressed] {\n          ", "\n        }\n\n        &[data-selected] {\n          ", "\n        }\n\n        @media (hover: hover) {\n          &:not([data-pressed]):not([data-selected]) {\n            &:hover {\n              ", "\n            }\n\n            &:active {\n              ", "\n            }\n          }\n        }\n\n        &:focus {\n          --card-focus-ring-box-shadow: ", ";\n        }\n\n        &:focus:not(:focus-visible) {\n          --card-focus-ring-box-shadow: ", ";\n        }\n      }\n    }\n\n    ", "\n  "])), dark ? "dark" : "light", _colorVarsStyle(base, card.enabled, $checkered), _colorVarsStyle(base, card.disabled, $checkered), _colorVarsStyle(base, card.pressed, $checkered), _colorVarsStyle(base, card.selected, $checkered), _colorVarsStyle(base, card.hovered, $checkered), _colorVarsStyle(base, card.pressed, $checkered), $focusRing ? focusRingStyle({
    base,
    border,
    focusRing
  }) : void 0, $focusRing ? focusRingBorderStyle(border) : void 0, _colorVarsStyle(base, card.disabled, $checkered), _colorVarsStyle(base, card.pressed, $checkered), _colorVarsStyle(base, card.selected, $checkered), _colorVarsStyle(base, card.hovered, $checkered), _colorVarsStyle(base, card.pressed, $checkered), $focusRing ? focusRingStyle({
    base,
    border,
    focusRing
  }) : void 0, $focusRing ? focusRingBorderStyle(border) : void 0, (_b = (_a = theme.sanity.styles) == null ? void 0 : _a.card) == null ? void 0 : _b.root);
}
const Root$u = styled(Box)(responsiveBorderStyle, responsiveRadiusStyle, responsiveShadowStyle, cardStyle);
const Card = forwardRef(function Card2(props, ref) {
  const {
    __unstable_checkered: checkered = false,
    __unstable_focusRing: focusRing = false,
    as: asProp,
    border,
    borderTop,
    borderRight,
    borderBottom,
    borderLeft,
    pressed,
    radius = 0,
    scheme,
    selected,
    shadow,
    tone: toneProp = "default",
    ...restProps
  } = props;
  const as = isValidElementType(asProp) ? asProp : "div";
  const rootTheme = useRootTheme();
  const tone = toneProp === "inherit" ? rootTheme.tone : toneProp;
  return /* @__PURE__ */jsx(ThemeColorProvider, {
    scheme,
    tone,
    children: /* @__PURE__ */jsx(Root$u, {
      "data-as": typeof as === "string" ? as : void 0,
      "data-scheme": rootTheme.scheme,
      "data-ui": "Card",
      "data-tone": tone,
      ...restProps,
      $border: useArrayProp(border),
      $borderTop: useArrayProp(borderTop),
      $borderRight: useArrayProp(borderRight),
      $borderBottom: useArrayProp(borderBottom),
      $borderLeft: useArrayProp(borderLeft),
      $checkered: checkered,
      $focusRing: focusRing,
      $radius: useArrayProp(radius),
      $shadow: useArrayProp(shadow),
      $tone: tone,
      "data-checkered": checkered ? "" : void 0,
      "data-pressed": pressed ? "" : void 0,
      "data-selected": selected ? "" : void 0,
      forwardedAs: as,
      ref,
      selected
    })
  });
});
function checkboxBaseStyles() {
  return css(_templateObject21 || (_templateObject21 = _taggedTemplateLiteral(["\n    position: relative;\n    display: inline-block;\n  "])));
}
function inputElementStyles(props) {
  const {
    theme
  } = props;
  const color = theme.sanity.color.input;
  const {
    focusRing,
    input,
    radius
  } = theme.sanity;
  return css(_templateObject22 || (_templateObject22 = _taggedTemplateLiteral(["\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    outline: none;\n    opacity: 0;\n    z-index: 1;\n    padding: 0;\n    margin: 0;\n\n    & + span {\n      position: relative;\n      display: block;\n      height: ", ";\n      width: ", ";\n      box-sizing: border-box;\n      box-shadow: ", ";\n      border-radius: ", ";\n      line-height: 1;\n      background-color: ", ";\n\n      & > svg {\n        display: block;\n        position: absolute;\n        opacity: 0;\n        height: 100%;\n        width: 100%;\n\n        & > path {\n          vector-effect: non-scaling-stroke;\n          stroke-width: 2 !important;\n        }\n      }\n    }\n\n    &:not(:disabled):focus + span {\n      box-shadow: ", ";\n    }\n\n    &:not(:disabled):focus:not(:focus-visible) + span {\n      box-shadow: ", ";\n    }\n\n    &:checked + span > svg:first-child {\n      opacity: 1;\n    }\n\n    &[data-read-only] + span {\n      background-color: ", ";\n      box-shadow: ", ";\n      color: ", ";\n    }\n\n    &:not([data-read-only]):disabled + span {\n      background-color: ", ";\n      box-shadow: ", ";\n      color: ", ";\n    }\n\n    &:indeterminate + span > svg:last-child {\n      opacity: 1;\n    }\n  "])), rem(input.checkbox.size), rem(input.checkbox.size), focusRingBorderStyle({
    color: color.default.enabled.border,
    width: input.border.width
  }), rem(radius[2]), color.default.enabled.bg, focusRingStyle({
    border: {
      width: input.border.width,
      color: color.default.enabled.border
    },
    focusRing
  }), focusRingBorderStyle({
    color: color.default.enabled.border,
    width: input.border.width
  }), color.default.readOnly.bg, focusRingBorderStyle({
    width: input.border.width,
    color: color.default.readOnly.border
  }), color.default.readOnly.fg, color.default.disabled.bg, focusRingBorderStyle({
    width: input.border.width,
    color: color.default.disabled.border
  }), color.default.disabled.fg);
}
const Root$t = styled.div(checkboxBaseStyles);
const Input$5 = styled.input(inputElementStyles);
const Checkbox = forwardRef(function Checkbox2(props, forwardedRef) {
  const {
    checked,
    className,
    disabled,
    indeterminate,
    customValidity,
    readOnly,
    style,
    ...restProps
  } = props;
  const ref = useForwardedRef(forwardedRef);
  useCustomValidity(ref, customValidity);
  useEffect(() => {
    if (ref.current) {
      ref.current.indeterminate = indeterminate || false;
    }
  }, [indeterminate, ref]);
  return /* @__PURE__ */jsxs(Root$t, {
    className,
    "data-ui": "Checkbox",
    style,
    children: [/* @__PURE__ */jsx(Input$5, {
      "data-read-only": !disabled && readOnly ? "" : void 0,
      ...restProps,
      checked,
      disabled: disabled || readOnly,
      type: "checkbox",
      readOnly,
      ref
    }), /* @__PURE__ */jsxs("span", {
      children: [/* @__PURE__ */jsx(CheckmarkIcon, {}), /* @__PURE__ */jsx(RemoveIcon, {})]
    })]
  });
});
function codeSyntaxHighlightingStyle(_ref20) {
  let {
    theme
  } = _ref20;
  const color = theme.sanity.color.syntax;
  return {
    "&.atrule": {
      color: color.atrule
    },
    "&.attr-name": {
      color: color.attrName
    },
    "&.attr-value": {
      color: color.attrValue
    },
    "&.attribute": {
      color: color.attribute
    },
    "&.boolean": {
      color: color.boolean
    },
    "&.builtin": {
      color: color.builtin
    },
    "&.cdata": {
      color: color.cdata
    },
    "&.char": {
      color: color.char
    },
    "&.class": {
      color: color.class
    },
    "&.class-name": {
      color: color.className
    },
    "&.comment": {
      color: color.comment
    },
    "&.constant": {
      color: color.constant
    },
    "&.deleted": {
      color: color.deleted
    },
    "&.doctype": {
      color: color.doctype
    },
    "&.entity": {
      color: color.entity
    },
    "&.function": {
      color: color.function
    },
    "&.hexcode": {
      color: color.hexcode
    },
    "&.id": {
      color: color.id
    },
    "&.important": {
      color: color.important
    },
    "&.inserted": {
      color: color.inserted
    },
    "&.keyword": {
      color: color.keyword
    },
    "&.number": {
      color: color.number
    },
    "&.operator": {
      color: color.operator
    },
    "&.prolog": {
      color: color.prolog
    },
    "&.property": {
      color: color.property
    },
    "&.pseudo-class": {
      color: color.pseudoClass
    },
    "&.pseudo-element": {
      color: color.pseudoElement
    },
    "&.punctuation": {
      color: color.punctuation
    },
    "&.regex": {
      color: color.regex
    },
    "&.selector": {
      color: color.selector
    },
    "&.string": {
      color: color.string
    },
    "&.symbol": {
      color: color.symbol
    },
    "&.tag": {
      color: color.tag
    },
    "&.unit": {
      color: color.unit
    },
    "&.url": {
      color: color.url
    },
    "&.variable": {
      color: color.variable
    }
  };
}
function codeBaseStyle() {
  return css(_templateObject23 || (_templateObject23 = _taggedTemplateLiteral(["\n    color: var(--card-code-fg-color);\n\n    & code {\n      font-family: inherit;\n\n      &.refractor .token {\n        ", "\n      }\n    }\n\n    & a {\n      color: inherit;\n      text-decoration: underline;\n      border-radius: 1px;\n    }\n\n    & svg {\n      /* Certain popular CSS libraries changes the defaults for SVG display */\n      /* Make sure SVGs are rendered as inline elements */\n      display: inline;\n    }\n\n    & [data-sanity-icon] {\n      vertical-align: baseline;\n    }\n  "])), codeSyntaxHighlightingStyle);
}
const Root$s = styled.pre(codeBaseStyle, responsiveCodeFontStyle);
const Code = forwardRef(function Code2(props, ref) {
  const {
    children,
    language: languageProp,
    size = 2,
    weight,
    ...restProps
  } = props;
  const language = typeof languageProp === "string" ? languageProp : void 0;
  const registered = language ? Refractor.hasLanguage(language) : false;
  return /* @__PURE__ */jsxs(Root$s, {
    "data-ui": "Code",
    ...restProps,
    $size: useArrayProp(size),
    $weight: weight,
    ref,
    children: [!(language && registered) && /* @__PURE__ */jsx("code", {
      children
    }), language && registered && /* @__PURE__ */jsx(Refractor, {
      inline: true,
      language,
      value: String(children)
    })]
  });
});
const BASE_STYLE$1 = {
  width: "100%",
  margin: "0 auto"
};
function containerBaseStyle() {
  return BASE_STYLE$1;
}
function responsiveContainerWidthStyle(props) {
  const {
    theme
  } = props;
  const {
    container,
    media
  } = theme.sanity;
  return _responsive(media, props.$width, val => ({
    maxWidth: val === "auto" ? "none" : rem(container[val])
  }));
}
const Root$r = styled(Box)(containerBaseStyle, responsiveContainerWidthStyle);
const Container = forwardRef(function Container2(props, ref) {
  const {
    as,
    width = 2,
    ...restProps
  } = props;
  return /* @__PURE__ */jsx(Root$r, {
    "data-ui": "Container",
    ...restProps,
    $width: useArrayProp(width),
    forwardedAs: as,
    ref
  });
});
const Root$q = styled(Box)(responsiveGridStyle);
const Grid = forwardRef(function Grid2(props, ref) {
  const {
    as,
    autoRows,
    autoCols,
    autoFlow,
    columns,
    gap,
    gapX,
    gapY,
    rows,
    children,
    ...restProps
  } = props;
  return /* @__PURE__ */jsx(Root$q, {
    "data-as": typeof as === "string" ? as : void 0,
    "data-ui": "Grid",
    ...restProps,
    $autoRows: useArrayProp(autoRows),
    $autoCols: useArrayProp(autoCols),
    $autoFlow: useArrayProp(autoFlow),
    $columns: useArrayProp(columns),
    $gap: useArrayProp(gap),
    $gapX: useArrayProp(gapX),
    $gapY: useArrayProp(gapY),
    $rows: useArrayProp(rows),
    forwardedAs: as,
    ref,
    children
  });
});
function headingBaseStyle(props) {
  const {
    $accent,
    $muted,
    theme
  } = props;
  return css(_templateObject24 || (_templateObject24 = _taggedTemplateLiteral(["\n    ", "\n\n    ", "\n\n    & code {\n      font-family: ", ";\n      border-radius: 1px;\n    }\n\n    & a {\n      text-decoration: none;\n      border-radius: 1px;\n      color: var(--card-link-color);\n      outline: none;\n\n      @media (hover: hover) {\n        &:hover {\n          text-decoration: underline;\n        }\n      }\n\n      &:focus {\n        box-shadow: 0 0 0 1px var(--card-bg-color), 0 0 0 3px var(--card-focus-ring-color);\n      }\n\n      &:focus:not(:focus-visible) {\n        box-shadow: none;\n      }\n    }\n\n    & svg {\n      /* Certain popular CSS libraries changes the defaults for SVG display */\n      /* Make sure SVGs are rendered as inline elements */\n      display: inline;\n    }\n\n    & [data-sanity-icon] {\n      vertical-align: baseline;\n    }\n  "])), $accent && css(_templateObject25 || (_templateObject25 = _taggedTemplateLiteral(["\n      color: var(--card-accent-fg-color);\n    "]))), $muted && css(_templateObject26 || (_templateObject26 = _taggedTemplateLiteral(["\n      color: var(--card-muted-fg-color);\n    "]))), theme.sanity.fonts.code.family);
}
const Root$p = styled.div(headingBaseStyle, responsiveTextAlignStyle, responsiveHeadingFont);
const SpanWithTextOverflow = styled.span(_templateObject27 || (_templateObject27 = _taggedTemplateLiteral(["\n  display: block;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden;\n"])));
const Heading = forwardRef(function Heading2(props, ref) {
  const {
    accent = false,
    align,
    children: childrenProp,
    muted = false,
    size = 2,
    textOverflow,
    weight,
    ...restProps
  } = props;
  let children = childrenProp;
  if (textOverflow === "ellipsis") {
    children = /* @__PURE__ */jsx(SpanWithTextOverflow, {
      children
    });
  }
  return /* @__PURE__ */jsx(Root$p, {
    "data-ui": "Heading",
    ...restProps,
    $accent: accent,
    $align: useArrayProp(align),
    $muted: muted,
    $size: useArrayProp(size),
    $weight: weight,
    ref,
    children: /* @__PURE__ */jsx("span", {
      children
    })
  });
});
function inlineBaseStyle() {
  return {
    lineHeight: 0,
    "&&:not([hidden])": {
      display: "block"
    },
    "& > div": {
      display: "inline-block",
      verticalAlign: "middle"
    }
  };
}
function inlineSpaceStyle(props) {
  const {
    theme
  } = props;
  return _responsive(theme.sanity.media, props.$space, spaceIndex => {
    const space = rem(theme.sanity.space[spaceIndex]);
    return {
      margin: "-".concat(space, " 0 0 -").concat(space),
      "& > div": {
        padding: "".concat(space, " 0 0 ").concat(space)
      }
    };
  });
}
const Root$o = styled(Box)(inlineBaseStyle, inlineSpaceStyle);
const Inline = forwardRef(function Inline2(props, ref) {
  const {
    as,
    children: childrenProp,
    space,
    ...restProps
  } = props;
  const children = useMemo(() => childrenToElementArray(childrenProp).filter(Boolean).map((child, idx) => /* @__PURE__ */jsx("div", {
    children: child
  }, idx)), [childrenProp]);
  return /* @__PURE__ */jsx(Root$o, {
    "data-ui": "Inline",
    ...restProps,
    $space: useArrayProp(space),
    forwardedAs: as,
    ref,
    children
  });
});
function kbdStyle() {
  return css(_templateObject28 || (_templateObject28 = _taggedTemplateLiteral(["\n    background: var(--card-bg-color);\n    font: inherit;\n    box-shadow: inset 0 0 0 1px var(--card-hairline-hard-color);\n\n    &:not([hidden]) {\n      display: inline-block;\n    }\n  "])));
}
const Root$n = styled.kbd(responsiveRadiusStyle, kbdStyle);
const KBD = forwardRef(function KBD2(props, ref) {
  const {
    children,
    fontSize = 1,
    padding = 1,
    radius = 2,
    ...restProps
  } = props;
  return /* @__PURE__ */jsx(Root$n, {
    "data-ui": "KBD",
    ...restProps,
    $radius: useArrayProp(radius),
    ref,
    children: /* @__PURE__ */jsx(Box, {
      as: "span",
      padding,
      children: /* @__PURE__ */jsx(Code, {
        as: "span",
        muted: true,
        size: fontSize,
        children
      })
    })
  });
});
const key$6 = Symbol.for("@sanity/ui/context/boundaryElement");
globalScope[key$6] = globalScope[key$6] || createContext(null);
const BoundaryElementContext = globalScope[key$6];
function BoundaryElementProvider(props) {
  const {
    children,
    element
  } = props;
  const value = useMemo(() => ({
    version: 0,
    element
  }), [element]);
  return /* @__PURE__ */jsx(BoundaryElementContext.Provider, {
    value,
    children
  });
}
const DEFAULT_VALUE = {
  version: 0,
  element: null
};
function useBoundaryElement() {
  const value = useContext(BoundaryElementContext);
  if (value && (!isRecord(value) || value.version !== 0)) {
    throw new Error("useBoundaryElement(): the context value is not compatible");
  }
  return value || DEFAULT_VALUE;
}
function findMaxBreakpoints(media, width) {
  const ret = [];
  for (let i = 0; i < media.length; i += 1) {
    const bp = media[i];
    if (bp > width) {
      ret.push(i);
    }
  }
  return ret;
}
function findMinBreakpoints(media, width) {
  const ret = [];
  for (let i = 0; i < media.length; i += 1) {
    const bp = media[i];
    if (bp <= width) {
      ret.push(i);
    }
  }
  return ret;
}
const ElementQuery = forwardRef(function ElementQuery2(props, ref) {
  const theme = useTheme();
  const {
    children,
    media = theme.sanity.media,
    ...restProps
  } = props;
  const forwardedRef = useForwardedRef(ref);
  const [element, setElement] = useState(null);
  const elementSize = useElementSize(element);
  const width = useMemo(() => {
    var _a;
    return (_a = elementSize == null ? void 0 : elementSize.border.width) != null ? _a : window.innerWidth;
  }, [elementSize]);
  const max = useMemo(() => findMaxBreakpoints(media, width), [media, width]);
  const min = useMemo(() => findMinBreakpoints(media, width), [media, width]);
  const setRef = useCallback(el => {
    forwardedRef.current = el;
    setElement(el);
  }, [forwardedRef]);
  return /* @__PURE__ */jsx("div", {
    "data-ui": "ElementQuery",
    ...restProps,
    "data-eq-max": max.length ? max.join(" ") : void 0,
    "data-eq-min": min.length ? min.join(" ") : void 0,
    ref: setRef,
    children
  });
});
class ErrorBoundary extends Component {
  constructor() {
    super(...arguments);
    this.state = {
      error: null
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  componentDidCatch(error, info) {
    this.props.onCatch({
      error,
      info
    });
  }
  render() {
    const {
      error
    } = this.state;
    if (error) {
      const message = typeof (error == null ? void 0 : error.message) === "string" ? error.message : "Error";
      return /* @__PURE__ */jsx(Code, {
        children: message
      });
    }
    return this.props.children;
  }
}
const key$5 = Symbol.for("@sanity/ui/context/layer");
globalScope[key$5] = globalScope[key$5] || createContext(null);
const LayerContext = globalScope[key$5];
function useLayer() {
  const value = useContext(LayerContext);
  if (!value) {
    throw new Error("useLayer(): missing context value");
  }
  if (!isRecord(value) || value.version !== 0) {
    throw new Error("useLayer(): the context value is not compatible");
  }
  return value;
}
function LayerProvider(props) {
  const {
    children,
    zOffset: zOffsetProp = 0
  } = props;
  const parent = useContext(LayerContext);
  const zOffset = useArrayProp(zOffsetProp);
  const maxMediaIndex = zOffset.length - 1;
  const mediaIndex = Math.min(useMediaIndex(), maxMediaIndex);
  const zIndex = parent ? parent.zIndex + zOffset[mediaIndex] : zOffset[mediaIndex];
  const [size, setSize] = useState(0);
  const registerChild = useCallback(() => {
    setSize(v => v + 1);
    return () => setSize(v => v - 1);
  }, []);
  const parentRegisterChild = parent == null ? void 0 : parent.registerChild;
  useEffect(() => {
    if (!parentRegisterChild) return;
    return parentRegisterChild();
  }, [parentRegisterChild]);
  const value = useMemo(() => ({
    version: 0,
    isTopLayer: size === 0,
    registerChild,
    size,
    zIndex
  }), [size, registerChild, zIndex]);
  return /* @__PURE__ */jsx(LayerContext.Provider, {
    value,
    children
  });
}
const Root$m = styled.div(_templateObject29 || (_templateObject29 = _taggedTemplateLiteral(["\n  position: relative;\n"])));
const LayerChildren = forwardRef(function LayerChildren2(props, ref) {
  const {
    children,
    style = EMPTY_RECORD,
    ...restProps
  } = props;
  const {
    zIndex
  } = useLayer();
  return /* @__PURE__ */jsx(Root$m, {
    ...restProps,
    "data-ui": "Layer",
    ref,
    style: {
      ...style,
      zIndex
    },
    children
  });
});
const Layer = forwardRef(function Layer2(props, ref) {
  const {
    children,
    zOffset = 1,
    ...restProps
  } = props;
  return /* @__PURE__ */jsx(LayerProvider, {
    zOffset,
    children: /* @__PURE__ */jsx(LayerChildren, {
      ...restProps,
      ref,
      children
    })
  });
});
const key$4 = Symbol.for("@sanity/ui/context/portal");
const elementKey = Symbol.for("@sanity/ui/context/portal/element");
globalScope[elementKey] = null;
const defaultContextValue = {
  version: 0,
  boundaryElement: null,
  get element() {
    if (typeof document === "undefined") {
      return null;
    }
    if (globalScope[elementKey]) {
      return globalScope[elementKey];
    }
    globalScope[elementKey] = document.createElement("div");
    globalScope[elementKey].setAttribute("data-portal", "");
    document.body.appendChild(globalScope[elementKey]);
    return globalScope[elementKey];
  }
};
globalScope[key$4] = globalScope[key$4] || createContext(defaultContextValue);
const PortalContext = globalScope[key$4];
function usePortal() {
  const value = useContext(PortalContext);
  if (!value) {
    throw new Error("usePortal(): missing context value");
  }
  if (!isRecord(value) || value.version !== 0) {
    throw new Error("usePortal(): the context value is not compatible");
  }
  return value;
}
function Portal(props) {
  var _a;
  const {
    children,
    __unstable_name: name
  } = props;
  const portal = usePortal();
  const portalElement = (name ? portal.elements && portal.elements[name] : portal.element) || ((_a = portal.elements) == null ? void 0 : _a.default);
  if (!portalElement) {
    return null;
  }
  return createPortal(children, portalElement);
}
function useUnique(value) {
  const valueRef = useRef(value);
  if (!_isEqual(valueRef.current, value)) {
    valueRef.current = value;
  }
  return valueRef.current;
}
function _isEqual(objA, objB) {
  if (!objA || !objB) {
    return objA === objB;
  }
  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) {
    return false;
  }
  return keysA.every(key => objA[key] === objB[key]);
}
const __BROWSER__ = typeof document !== "undefined";
function PortalProvider(props) {
  const {
    boundaryElement,
    children,
    element,
    __unstable_elements: elementsProp
  } = props;
  const elements = useUnique(elementsProp);
  const value = useMemo(() => {
    return {
      version: 0,
      boundaryElement: boundaryElement || null,
      element: element || __BROWSER__ && document.body || null,
      elements
    };
  }, [boundaryElement, element, elements]);
  return /* @__PURE__ */jsx(PortalContext.Provider, {
    value,
    children
  });
}
const Root$l = styled.div(_templateObject30 || (_templateObject30 = _taggedTemplateLiteral(["\n  display: block;\n  width: 0;\n  height: 0;\n  position: absolute;\n  overflow: hidden;\n"])));
const SrOnly = forwardRef(function SrOnly2(props, ref) {
  const {
    as,
    children
  } = props;
  return /* @__PURE__ */jsx(Root$l, {
    "aria-hidden": true,
    as,
    "data-ui": "SrOnly",
    ref,
    children
  });
});
function _raf(fn) {
  const frameId = requestAnimationFrame(fn);
  return () => {
    cancelAnimationFrame(frameId);
  };
}
function _raf2(fn) {
  let innerDispose = null;
  const outerDispose = _raf(() => {
    innerDispose = _raf(fn);
  });
  return () => {
    if (innerDispose) innerDispose();
    outerDispose();
  };
}
function _isEnterToClickElement(element) {
  return isHTMLAnchorElement(element) || isHTMLButtonElement(element);
}
function isHTMLElement(node) {
  return node instanceof Node && node.nodeType === Node.ELEMENT_NODE;
}
function isHTMLAnchorElement(element) {
  return isHTMLElement(element) && element.nodeName === "A";
}
function isHTMLInputElement(element) {
  return isHTMLElement(element) && element.nodeName === "INPUT";
}
function isHTMLButtonElement(element) {
  return isHTMLElement(element) && element.nodeName === "BUTTON";
}
function isHTMLSelectElement(element) {
  return isHTMLElement(element) && element.nodeName === "SELECT";
}
function isHTMLTextAreaElement(element) {
  return isHTMLElement(element) && element.nodeName === "TEXTAREA";
}
function _hasFocus(element) {
  return Boolean(document.activeElement) && element.contains(document.activeElement);
}
function isFocusable(element) {
  if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
    return true;
  }
  if (isHTMLAnchorElement(element)) {
    return Boolean(element.href) && element.rel !== "ignore";
  }
  if (isHTMLInputElement(element)) {
    return element.type !== "hidden" && element.type !== "file" && !element.disabled;
  }
  if (isHTMLButtonElement(element) || isHTMLSelectElement(element) || isHTMLTextAreaElement(element)) {
    return !element.disabled;
  }
  return false;
}
function attemptFocus(element) {
  if (!isFocusable(element)) {
    return false;
  }
  try {
    element.focus();
  } catch (_) {}
  return document.activeElement === element;
}
function focusFirstDescendant(element) {
  for (let i = 0; i < element.childNodes.length; i++) {
    const child = element.childNodes[i];
    if (isHTMLElement(child) && (attemptFocus(child) || focusFirstDescendant(child))) {
      return true;
    }
  }
  return false;
}
function focusLastDescendant(element) {
  for (let i = element.childNodes.length - 1; i >= 0; i--) {
    const child = element.childNodes[i];
    if (isHTMLElement(child) && (attemptFocus(child) || focusLastDescendant(child))) {
      return true;
    }
  }
  return false;
}
function _isScrollable(el) {
  if (!(el instanceof Element)) return false;
  const style = window.getComputedStyle(el);
  return style.overflowX.includes("auto") || style.overflowX.includes("scroll") || style.overflowY.includes("auto") || style.overflowY.includes("scroll");
}
const Root$k = styled.div(_templateObject31 || (_templateObject31 = _taggedTemplateLiteral(["\n  position: relative;\n"])));
const ItemWrapper = styled.div(_templateObject32 || (_templateObject32 = _taggedTemplateLiteral(["\n  position: absolute;\n  left: 0;\n  right: 0;\n"])));
const VirtualList = forwardRef(function VirtualList2(props, ref) {
  const {
    as = "div",
    gap = 0,
    getItemKey,
    items = [],
    onChange,
    renderItem,
    ...restProps
  } = props;
  const {
    space
  } = useTheme().sanity;
  const forwardedRef = useForwardedRef(ref);
  const wrapperRef = useRef(null);
  const [scrollTop, setScrollTop] = useState(0);
  const [scrollHeight, setScrollHeight] = useState(0);
  const [itemHeight, setItemHeight] = useState(-1);
  useEffect(() => {
    if (!wrapperRef.current) return;
    const firstElement = wrapperRef.current.firstChild;
    if (firstElement instanceof HTMLElement) {
      setItemHeight(firstElement.offsetHeight);
    }
  }, [renderItem]);
  useEffect(() => {
    if (!forwardedRef.current) return;
    let _scrollEl = forwardedRef.current.parentNode;
    while (_scrollEl && !_isScrollable(_scrollEl)) {
      _scrollEl = _scrollEl.parentNode;
    }
    if (_scrollEl) {
      const scrollEl = _scrollEl;
      if (!(scrollEl instanceof HTMLElement)) return;
      const handleScroll2 = () => {
        setScrollTop(scrollEl.scrollTop);
      };
      scrollEl.addEventListener("scroll", handleScroll2, {
        passive: true
      });
      const ro = new _ResizeObserver(entries => {
        setScrollHeight(entries[0].contentRect.height);
      });
      ro.observe(scrollEl);
      handleScroll2();
      return () => {
        scrollEl.removeEventListener("scroll", handleScroll2);
        ro.unobserve(scrollEl);
        ro.disconnect();
      };
    }
    const handleScroll = () => {
      setScrollTop(window.scrollY);
    };
    const handleResize = () => {
      setScrollHeight(window.innerHeight);
    };
    window.addEventListener("scroll", handleScroll, {
      passive: true
    });
    window.addEventListener("resize", handleResize);
    setScrollHeight(window.innerHeight);
    handleScroll();
    return () => {
      window.removeEventListener("scroll", handleScroll);
      window.removeEventListener("resize", handleResize);
    };
  }, [forwardedRef]);
  const len = items.length;
  const height = itemHeight ? len * (itemHeight + space[gap]) - space[gap] : 0;
  const fromIndex = height ? Math.max(Math.floor(scrollTop / height * len) - 2, 0) : 0;
  const toIndex = height ? Math.ceil((scrollTop + scrollHeight) / height * len) + 1 : 0;
  useEffect(() => {
    if (!onChange) return;
    onChange({
      fromIndex,
      gap: space[gap],
      itemHeight,
      scrollHeight,
      scrollTop,
      toIndex
    });
  }, [fromIndex, gap, itemHeight, onChange, scrollHeight, scrollTop, space, toIndex]);
  const children = useMemo(() => {
    if (!renderItem || items.length === 0) return null;
    if (itemHeight === -1) {
      return [/* @__PURE__ */jsx(ItemWrapper, {
        children: renderItem(items[0])
      }, 0)];
    }
    return items.slice(fromIndex, toIndex).map((item, _itemIndex) => {
      const itemIndex = fromIndex + _itemIndex;
      const node = renderItem(item);
      const key = getItemKey ? getItemKey(item, itemIndex) : itemIndex;
      return /* @__PURE__ */jsx(ItemWrapper, {
        style: {
          top: itemIndex * (itemHeight + space[gap])
        },
        children: node
      }, key);
    });
  }, [fromIndex, gap, getItemKey, itemHeight, items, renderItem, space, toIndex]);
  const wrapperStyle = useMemo(() => ({
    height
  }), [height]);
  return /* @__PURE__ */jsx(Root$k, {
    as,
    "data-ui": "VirtualList",
    ...restProps,
    ref: forwardedRef,
    children: /* @__PURE__ */jsx("div", {
      ref: wrapperRef,
      style: wrapperStyle,
      children
    })
  });
});
const DEFAULT_POPOVER_DISTANCE = 4;
const DEFAULT_POPOVER_PADDING = 4;
const DEFAULT_POPOVER_ARROW_WIDTH = 27;
const DEFAULT_POPOVER_ARROW_HEIGHT = 11;
const DEFAULT_POPOVER_MARGINS = [0, 0, 0, 0];
function size(options) {
  const {
    apply,
    margins,
    padding = 0
  } = options;
  return {
    name: "@sanity/ui/size",
    async fn(args) {
      const {
        elements,
        placement,
        platform,
        rects
      } = args;
      const {
        floating,
        reference
      } = rects;
      const overflow = await detectOverflow(args, {
        altBoundary: true,
        boundary: options.boundaryElement || void 0,
        elementContext: "floating",
        padding,
        rootBoundary: "viewport"
      });
      let maxWidth = Infinity;
      let maxHeight = Infinity;
      const floatingW = floating.width;
      const floatingH = floating.height;
      if (placement.includes("top")) {
        maxWidth = floatingW - (overflow.left + overflow.right);
        maxHeight = floatingH - overflow.top;
      }
      if (placement.includes("right")) {
        maxWidth = floatingW - overflow.right;
        maxHeight = floatingH - (overflow.top + overflow.bottom);
      }
      if (placement.includes("bottom")) {
        maxWidth = floatingW - (overflow.left + overflow.right);
        maxHeight = floatingH - overflow.bottom;
      }
      if (placement.includes("left")) {
        maxWidth = floatingW - overflow.left;
        maxHeight = floatingH - (overflow.top + overflow.bottom);
      }
      apply({
        availableWidth: maxWidth - margins[1] - margins[3],
        availableHeight: maxHeight - margins[0] - margins[2],
        elements,
        referenceWidth: reference.width - margins[1] - margins[3]
      });
      const nextDimensions = await platform.getDimensions(elements.floating);
      const targetH = nextDimensions.height;
      const targetW = nextDimensions.width;
      if (floatingW !== targetW || floatingH !== targetH) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
}
const Root$j = styled.div(_templateObject33 || (_templateObject33 = _taggedTemplateLiteral(["\n  position: absolute;\n  pointer-events: none;\n  width: ", "px;\n  height: ", "px;\n  fill: none;\n\n  :empty + & {\n    display: none;\n  }\n\n  & > svg {\n    display: block;\n    transform-origin: ", "px ", "px;\n  }\n\n  [data-placement^='top'] > & {\n    bottom: -", "px;\n  }\n\n  [data-placement^='right'] > & {\n    left: -", "px;\n\n    & > svg {\n      transform: rotate(90deg);\n    }\n  }\n\n  [data-placement^='left'] > & {\n    right: -", "px;\n\n    & > svg {\n      transform: rotate(-90deg);\n    }\n  }\n\n  [data-placement^='bottom'] > & {\n    top: -", "px;\n\n    & > svg {\n      transform: rotate(180deg);\n    }\n  }\n"])), DEFAULT_POPOVER_ARROW_WIDTH, DEFAULT_POPOVER_ARROW_WIDTH, DEFAULT_POPOVER_ARROW_WIDTH / 2, DEFAULT_POPOVER_ARROW_WIDTH / 2, DEFAULT_POPOVER_ARROW_WIDTH, DEFAULT_POPOVER_ARROW_WIDTH, DEFAULT_POPOVER_ARROW_WIDTH, DEFAULT_POPOVER_ARROW_WIDTH);
const BorderPath = styled.path(_templateObject34 || (_templateObject34 = _taggedTemplateLiteral(["\n  fill: var(--card-shadow-outline-color);\n"])));
const ShapePath = styled.path(_templateObject35 || (_templateObject35 = _taggedTemplateLiteral(["\n  fill: var(--card-bg-color);\n"])));
const PopoverArrow = forwardRef(function PopoverArrow2(props, ref) {
  return /* @__PURE__ */jsx(Root$j, {
    "data-ui": "Popover__arrow",
    ...props,
    ref,
    children: /* @__PURE__ */jsxs("svg", {
      width: DEFAULT_POPOVER_ARROW_WIDTH,
      height: DEFAULT_POPOVER_ARROW_HEIGHT,
      viewBox: "0 0 27 11",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: [/* @__PURE__ */jsx(BorderPath, {
        d: "M1.18708 1C3.29803 1.0011 5.29585 1.95479 6.62414 3.59561L11.1683 9.20895C12.369 10.6922 14.631 10.6922 15.8317 9.20894L20.3759 3.59561C21.7042 1.95478 23.702 1.0011 25.8129 1H21.9436C21.0533 1.49255 20.2545 2.15618 19.5986 2.96641L15.0545 8.57975C14.254 9.56855 12.746 9.56855 11.9455 8.57975L7.40139 2.96642C6.74548 2.15618 5.94673 1.49255 5.05643 1H1.18708Z"
      }), /* @__PURE__ */jsx(ShapePath, {
        d: "M1.18342 0C3.59749 0 5.88246 1.0901 7.40138 2.96642L11.9455 8.57975C12.746 9.56855 14.254 9.56855 15.0545 8.57975L19.5986 2.96641C21.1175 1.0901 23.4025 0 25.8166 0H27H0H1.18342Z"
      })]
    })
  });
});
function popoverCardStyle(props) {
  const {
    $boundaryWidth
  } = props;
  return {
    "&:not([hidden])": {
      display: "flex"
    },
    flexDirection: "column",
    width: "max-content",
    minWidth: "min-content",
    maxWidth: typeof $boundaryWidth === "number" ? "".concat($boundaryWidth - DEFAULT_POPOVER_PADDING * 2, "px") : void 0
  };
}
const Root$i = memo(styled(Card)(popoverCardStyle));
const PopoverContainer = memo(styled(Container)(_templateObject36 || (_templateObject36 = _taggedTemplateLiteral(["\n  max-height: inherit;\n  max-width: inherit;\n"]))));
const PopoverCard = memo(forwardRef(function PopoverCard2(props, ref) {
  const {
    __unstable_margins: marginsProp,
    arrow,
    arrowRef,
    arrowX,
    arrowY,
    boundaryWidth,
    children,
    padding,
    placement,
    overflow,
    radius,
    scheme,
    shadow,
    strategy,
    style,
    tone,
    width = "auto",
    x: xProp,
    y: yProp,
    ...restProps
  } = props;
  const {
    zIndex
  } = useLayer();
  const margins = useMemo(() => marginsProp || DEFAULT_POPOVER_MARGINS, [marginsProp]);
  const x = (xProp != null ? xProp : 0) + margins[3];
  const y = (yProp != null ? yProp : 0) + margins[0];
  const rootStyle = useMemo(() => ({
    position: strategy,
    top: y,
    left: x,
    zIndex,
    ...style
  }), [strategy, style, x, y, zIndex]);
  const staticSide = placement && FLOATING_STATIC_SIDES[placement.split("-")[0]];
  const arrowStyle = useMemo(() => {
    const style2 = {
      left: arrowX !== null ? arrowX : void 0,
      top: arrowY !== null ? arrowY : void 0,
      right: void 0,
      bottom: void 0
    };
    if (staticSide) style2[staticSide] = 0 - DEFAULT_POPOVER_ARROW_WIDTH;
    return style2;
  }, [arrowX, arrowY, staticSide]);
  return /* @__PURE__ */jsxs(Root$i, {
    ...restProps,
    $boundaryWidth: boundaryWidth,
    "data-placement": placement,
    "data-ui": "Popover",
    radius,
    ref,
    scheme,
    shadow,
    sizing: "border",
    style: rootStyle,
    tone,
    children: [/* @__PURE__ */jsx(PopoverContainer, {
      "data-ui": "Popover__wrapper",
      flex: 1,
      overflow,
      padding,
      sizing: "border",
      width,
      children
    }), arrow && /* @__PURE__ */jsx(PopoverArrow, {
      ref: arrowRef,
      style: arrowStyle
    })]
  });
}));
PopoverCard.displayName = "PopoverCard";
const Popover = memo(forwardRef(function Popover2(props, ref) {
  var _a, _b, _c, _d, _e;
  const theme = useTheme();
  const boundaryElementContext = useBoundaryElement();
  const {
    __unstable_margins: margins = DEFAULT_POPOVER_MARGINS,
    arrow: arrowProp = true,
    boundaryElement = boundaryElementContext.element,
    children: childProp,
    constrainSize = false,
    content,
    disabled,
    fallbackPlacements,
    matchReferenceWidth: matchReferenceWidthProp,
    open,
    overflow = "hidden",
    padding: paddingProp,
    placement: placementProp = "bottom",
    portal,
    preventOverflow = true,
    radius: radiusProp = 3,
    referenceElement,
    scheme,
    shadow: shadowProp = 3,
    tone = "inherit",
    width: widthProp = "auto",
    zOffset: zOffsetProp = (_a = theme.sanity.layer) == null ? void 0 : _a.popover.zOffset,
    ...restProps
  } = props;
  const boundarySize = (_b = useElementSize(boundaryElement)) == null ? void 0 : _b.border;
  const padding = useArrayProp(paddingProp);
  const radius = useArrayProp(radiusProp);
  const shadow = useArrayProp(shadowProp);
  const width = useArrayProp(widthProp);
  const zOffset = useArrayProp(zOffsetProp);
  const forwardedRef = useForwardedRef(ref);
  const arrowRef = useRef(null);
  const rootBoundary = "viewport";
  const middleware = useMemo(() => {
    const ret = [];
    if (constrainSize || preventOverflow) {
      ret.push(flip({
        boundary: boundaryElement || void 0,
        fallbackPlacements,
        padding: DEFAULT_POPOVER_PADDING,
        rootBoundary
      }));
    }
    ret.push(offset({
      mainAxis: arrowProp ? DEFAULT_POPOVER_DISTANCE : 0
    }));
    if (constrainSize || matchReferenceWidthProp) {
      ret.push(size({
        apply(_ref21) {
          let {
            availableWidth,
            availableHeight,
            elements,
            referenceWidth
          } = _ref21;
          if (matchReferenceWidthProp) {
            elements.floating.style.width = "".concat(referenceWidth, "px");
          }
          if (constrainSize) {
            elements.floating.style.maxWidth = "".concat(availableWidth, "px");
            elements.floating.style.maxHeight = "".concat(availableHeight, "px");
          }
        },
        boundaryElement,
        constrainSize,
        margins,
        matchReferenceWidth: matchReferenceWidthProp,
        padding: DEFAULT_POPOVER_PADDING
      }));
    }
    if (preventOverflow) {
      ret.push(shift({
        boundary: boundaryElement || void 0,
        rootBoundary,
        padding: DEFAULT_POPOVER_PADDING
      }));
    }
    if (arrowProp) {
      ret.push(arrow({
        element: arrowRef,
        padding: DEFAULT_POPOVER_PADDING
      }));
    }
    ret.push(hide({
      boundary: boundaryElement || void 0,
      padding: DEFAULT_POPOVER_PADDING,
      strategy: "referenceHidden"
    }));
    return ret;
  }, [arrowProp, boundaryElement, constrainSize, fallbackPlacements, margins, matchReferenceWidthProp, preventOverflow]);
  const floatingProps = useMemo(() => ({
    middleware,
    placement: placementProp,
    whileElementsMounted: autoUpdate
  }), [middleware, placementProp]);
  const {
    x,
    y,
    placement,
    reference: referenceRef,
    floating: floatingRef,
    middlewareData,
    strategy
  } = useFloating(floatingProps);
  const referenceHidden = (_c = middlewareData.hide) == null ? void 0 : _c.referenceHidden;
  const arrowX = (_d = middlewareData.arrow) == null ? void 0 : _d.x;
  const arrowY = (_e = middlewareData.arrow) == null ? void 0 : _e.y;
  const setArrow = useCallback(arrowEl => {
    arrowRef.current = arrowEl;
  }, []);
  const setFloating = useCallback(node => {
    forwardedRef.current = node;
    floatingRef(node);
  }, [floatingRef, forwardedRef]);
  const setReference = useCallback(node => {
    referenceRef(node);
    const childRef = childProp == null ? void 0 : childProp.ref;
    if (typeof childRef === "function") {
      childRef(node);
    } else if (childRef) {
      childRef.current = node;
    }
  }, [childProp, referenceRef]);
  const child = useMemo(() => {
    if (!childProp || referenceElement) return null;
    return cloneElement(childProp, {
      ref: setReference
    });
  }, [childProp, referenceElement, setReference]);
  useEffect(() => {
    referenceRef(referenceElement || null);
  }, [referenceRef, referenceElement]);
  if (disabled) {
    return childProp || /* @__PURE__ */jsx(Fragment, {});
  }
  const popover = /* @__PURE__ */jsx(LayerProvider, {
    zOffset,
    children: /* @__PURE__ */jsx(PopoverCard, {
      ...restProps,
      __unstable_margins: margins,
      arrow: arrowProp,
      arrowRef: setArrow,
      arrowX,
      arrowY,
      boundaryWidth: preventOverflow ? boundarySize == null ? void 0 : boundarySize.width : void 0,
      hidden: referenceHidden,
      overflow,
      padding,
      placement,
      radius,
      ref: setFloating,
      scheme,
      shadow,
      strategy,
      tone,
      x,
      y,
      width,
      children: content
    })
  });
  return /* @__PURE__ */jsxs(Fragment, {
    children: [open && /* @__PURE__ */jsx(Fragment, {
      children: portal ? /* @__PURE__ */jsx(Portal, {
        __unstable_name: typeof portal === "string" ? portal : void 0,
        children: popover
      }) : popover
    }), child]
  });
}));
Popover.displayName = "Popover";
function radioBaseStyle() {
  return css(_templateObject37 || (_templateObject37 = _taggedTemplateLiteral(["\n    position: relative;\n\n    &:not([hidden]) {\n      display: inline-block;\n    }\n\n    &[data-read-only] {\n      outline: 1px solid red;\n    }\n  "])));
}
function inputElementStyle(props) {
  const {
    theme
  } = props;
  const {
    focusRing,
    input
  } = theme.sanity;
  const color = theme.sanity.color.input;
  const dist = (input.radio.size - input.radio.markSize) / 2;
  return css(_templateObject38 || (_templateObject38 = _taggedTemplateLiteral(["\n    appearance: none;\n    position: absolute;\n    top: 0;\n    left: 0;\n    opacity: 0;\n    height: 100%;\n    width: 100%;\n    outline: none;\n    z-index: 1;\n    padding: 0;\n    margin: 0;\n    border-radius: ", ";\n    border: none;\n\n    /* enabled */\n    & + span {\n      display: block;\n      position: relative;\n      height: ", ";\n      width: ", ";\n      border-radius: ", ";\n      background: ", ";\n      box-shadow: ", ";\n\n      &::after {\n        content: '';\n        position: absolute;\n        top: ", ";\n        left: ", ";\n        height: ", ";\n        width: ", ";\n        border-radius: ", ";\n        background: ", ";\n        opacity: 0;\n      }\n    }\n\n    /* focused */\n    &:not(:disabled):focus + span {\n      box-shadow: ", ";\n    }\n\n    &:not(:disabled):focus:not(:focus-visible) + span {\n      box-shadow: ", ";\n    }\n\n    &:checked + span::after {\n      opacity: 1;\n    }\n\n    /* read only */\n    &[data-read-only] + span {\n      box-shadow: 0 0 0 1px ", ";\n      background: ", ";\n\n      &::after {\n        background: ", ";\n      }\n    }\n\n    /* disabled */\n    &:not([data-read-only]):disabled + span {\n      box-shadow: 0 0 0 1px ", ";\n      background: ", ";\n\n      &::after {\n        background: ", ";\n      }\n    }\n  "])), rem(input.radio.size / 2), rem(input.radio.size), rem(input.radio.size), rem(input.radio.size / 2), color.default.enabled.bg, focusRingBorderStyle({
    color: color.default.enabled.border,
    width: input.border.width
  }), rem(dist), rem(dist), rem(input.radio.markSize), rem(input.radio.markSize), rem(input.radio.markSize / 2), color.default.enabled.fg, focusRingStyle({
    border: {
      width: input.border.width,
      color: color.default.enabled.border
    },
    focusRing
  }), focusRingBorderStyle({
    color: color.default.enabled.border,
    width: input.border.width
  }), color.default.readOnly.border, color.default.readOnly.bg, color.default.readOnly.fg, color.default.disabled.border, color.default.disabled.bg, color.default.disabled.fg);
}
const Root$h = styled.div(radioBaseStyle);
const Input$4 = styled.input(inputElementStyle);
const Radio = forwardRef(function Radio2(props, forwardedRef) {
  const {
    className,
    disabled,
    style,
    customValidity,
    readOnly,
    ...restProps
  } = props;
  const ref = useForwardedRef(forwardedRef);
  useCustomValidity(ref, customValidity);
  return /* @__PURE__ */jsxs(Root$h, {
    className,
    "data-ui": "Radio",
    style,
    children: [/* @__PURE__ */jsx(Input$4, {
      "data-read-only": !disabled && readOnly ? "" : void 0,
      ...restProps,
      disabled: disabled || readOnly,
      readOnly,
      ref,
      type: "radio"
    }), /* @__PURE__ */jsx("span", {})]
  });
});
function rootStyle() {
  return css(_templateObject39 || (_templateObject39 = _taggedTemplateLiteral(["\n    position: relative;\n    width: stretch;\n\n    &:not([hidden]) {\n      display: inline-block;\n    }\n  "])));
}
function inputBaseStyle(props) {
  const {
    theme
  } = props;
  const font = theme.sanity.fonts.text;
  return css(_templateObject40 || (_templateObject40 = _taggedTemplateLiteral(["\n    -webkit-font-smoothing: antialiased;\n    appearance: none;\n    border: 0;\n    font-family: ", ";\n    color: inherit;\n    width: 100%;\n    outline: none;\n    margin: 0;\n\n    &:disabled {\n      opacity: 1;\n    }\n  "])), font.family);
}
function inputColorStyle(props) {
  const {
    theme
  } = props;
  const {
    focusRing,
    input
  } = theme.sanity;
  const color = theme.sanity.color.input;
  return css(_templateObject41 || (_templateObject41 = _taggedTemplateLiteral(["\n    /* enabled */\n    background-color: ", ";\n    color: ", ";\n    box-shadow: ", ";\n\n    /* hovered */\n    @media (hover: hover) {\n      &:not(:disabled):hover {\n        background-color: ", ";\n        color: ", ";\n        box-shadow: ", ";\n      }\n    }\n\n    /* focused */\n    &:not(:disabled):focus {\n      box-shadow: ", ";\n    }\n\n    /* read-only */\n    &[data-read-only] {\n      background-color: ", ";\n      color: ", ";\n      box-shadow: ", ";\n    }\n\n    /* disabled */\n    &:not([data-read-only]):disabled {\n      background-color: ", ";\n      color: ", ";\n      box-shadow: ", ";\n    }\n  "])), color.default.enabled.bg, color.default.enabled.fg, focusRingBorderStyle({
    color: color.default.enabled.border,
    width: input.border.width
  }), color.default.hovered.bg, color.default.hovered.fg, focusRingBorderStyle({
    color: color.default.hovered.border,
    width: input.border.width
  }), focusRingStyle({
    border: {
      width: input.border.width,
      color: color.default.enabled.border
    },
    focusRing
  }), color.default.readOnly.bg, color.default.readOnly.fg, focusRingBorderStyle({
    color: color.default.readOnly.border,
    width: input.border.width
  }), color.default.disabled.bg, color.default.disabled.fg, focusRingBorderStyle({
    color: color.default.disabled.border,
    width: input.border.width
  }));
}
function textSize(size) {
  return {
    fontSize: rem(size.fontSize),
    lineHeight: rem(size.lineHeight)
  };
}
function inputTextSizeStyle(props) {
  const {
    theme,
    $fontSize
  } = props;
  const {
    sizes
  } = theme.sanity.fonts.text;
  return _responsive(theme.sanity.media, $fontSize, sizeIndex => textSize(sizes[sizeIndex] || sizes[2]));
}
function inputStyle() {
  return [responsiveRadiusStyle, inputBaseStyle, inputColorStyle, inputTextSizeStyle, responsiveInputPaddingIconRightStyle];
}
function iconBoxStyle(props) {
  const {
    theme
  } = props;
  const color = theme.sanity.color.input;
  return css(_templateObject42 || (_templateObject42 = _taggedTemplateLiteral(["\n    pointer-events: none;\n    position: absolute;\n    top: 0;\n    right: 0;\n\n    /* enabled */\n    --card-fg-color: ", ";\n\n    /* hover */\n    @media (hover: hover) {\n      select:not(disabled):not(:read-only):hover + && {\n        --card-fg-color: ", ";\n      }\n    }\n\n    /* disabled */\n    select:disabled + && {\n      --card-fg-color: ", ";\n    }\n\n    /* read-only */\n    select[data-read-only] + && {\n      --card-fg-color: ", ";\n    }\n  "])), color.default.enabled.fg, color.default.hovered.fg, color.default.disabled.fg, color.default.readOnly.fg);
}
const selectStyle = {
  root: rootStyle,
  input: inputStyle,
  iconBox: iconBoxStyle
};
const Root$g = styled.div(selectStyle.root);
const Input$3 = styled.select(selectStyle.input);
const IconBox = styled(Box)(selectStyle.iconBox);
const Select = forwardRef(function Select2(props, forwardedRef) {
  const {
    children,
    customValidity,
    disabled,
    fontSize = 2,
    padding = 3,
    radius = 1,
    readOnly,
    space = 3,
    ...restProps
  } = props;
  const ref = useForwardedRef(forwardedRef);
  useCustomValidity(ref, customValidity);
  return /* @__PURE__ */jsxs(Root$g, {
    "data-ui": "Select",
    children: [/* @__PURE__ */jsx(Input$3, {
      "data-read-only": !disabled && readOnly ? "" : void 0,
      "data-ui": "Select",
      ...restProps,
      $fontSize: useArrayProp(fontSize),
      $padding: useArrayProp(padding),
      $radius: useArrayProp(radius),
      $space: useArrayProp(space),
      disabled: disabled || readOnly,
      ref,
      children
    }), /* @__PURE__ */jsx(IconBox, {
      padding,
      children: /* @__PURE__ */jsx(Text, {
        size: fontSize,
        children: /* @__PURE__ */jsx(SelectIcon, {})
      })
    })]
  });
});
const BASE_STYLE = {
  "&&:not([hidden])": {
    display: "grid"
  },
  '&[data-as="ul"],&[data-as="ol"]': {
    listStyle: "none"
  },
  gridTemplateColumns: "minmax(0, 1fr)",
  gridAutoRows: "min-content"
};
function stackBaseStyle() {
  return BASE_STYLE;
}
function responsiveStackSpaceStyle(props) {
  const {
    theme
  } = props;
  const {
    media,
    space
  } = theme.sanity;
  return _responsive(media, props.$space, spaceIndex => ({
    gridGap: rem(space[spaceIndex])
  }));
}
const Root$f = styled(Box)(stackBaseStyle, responsiveStackSpaceStyle);
const Stack = forwardRef(function Stack2(props, ref) {
  const {
    as,
    space,
    ...restProps
  } = props;
  return /* @__PURE__ */jsx(Root$f, {
    "data-as": typeof as === "string" ? as : void 0,
    "data-ui": "Stack",
    ...restProps,
    $space: useArrayProp(space),
    forwardedAs: as,
    ref
  });
});
function switchBaseStyles() {
  return css(_templateObject43 || (_templateObject43 = _taggedTemplateLiteral(["\n    position: relative;\n    &:not([hidden]) {\n      display: inline-block;\n    }\n  "])));
}
function switchInputStyles() {
  return css(_templateObject44 || (_templateObject44 = _taggedTemplateLiteral(["\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    opacity: 0;\n    height: 100%;\n    width: 100%;\n    outline: none;\n    padding: 0;\n    margin: 0;\n\n    /* Place the input element above the representation element */\n    z-index: 1;\n  "])));
}
function switchRepresentationStyles(props) {
  const {
    theme
  } = props;
  const {
    focusRing,
    input
  } = theme.sanity;
  const color = theme.sanity.color.button.default;
  return css(_templateObject45 || (_templateObject45 = _taggedTemplateLiteral(["\n    --switch-bg-color: ", ";\n    --switch-fg-color: ", ";\n    --switch-box-shadow: none;\n\n    &:not([hidden]) {\n      display: block;\n    }\n    position: relative;\n    width: ", ";\n    height: ", ";\n    border-radius: ", ";\n\n    /* Make sure it\u2019s not possible to interact with the wrapper element */\n    pointer-events: none;\n\n    &:after {\n      content: '';\n      display: block;\n      position: absolute;\n      top: 0;\n      left: 0;\n      right: 0;\n      bottom: 0;\n      z-index: 1;\n      box-shadow: var(--switch-box-shadow);\n      border-radius: inherit;\n    }\n\n    /* Focus styles */\n    input:focus + && {\n      --switch-box-shadow: ", ";\n    }\n\n    input:focus:not(:focus-visible) + && {\n      --switch-box-shadow: none;\n    }\n\n    input:checked + && {\n      --switch-bg-color: ", ";\n      --switch-fg-color: ", ";\n    }\n\n    @media (hover: hover) {\n      input:not(:disabled):hover + && {\n        --switch-bg-color: ", ";\n        --switch-fg-color: ", ";\n      }\n\n      input:not(:disabled):checked:hover + && {\n        --switch-bg-color: ", ";\n        --switch-fg-color: ", ";\n      }\n    }\n\n    input:not([data-read-only]):disabled + && {\n      --switch-bg-color: ", ";\n      --switch-fg-color: ", ";\n    }\n  "])), color.default.enabled.bg, color.default.enabled.fg, rem(input.switch.width), rem(input.switch.height), rem(input.switch.height / 2), focusRingStyle({
    focusRing
  }), color.positive.enabled.bg, color.positive.enabled.fg, color.default.hovered.bg, color.default.hovered.fg, color.positive.hovered.bg, color.positive.hovered.fg, color.default.disabled.bg, color.default.disabled.fg);
}
function switchTrackStyles(props) {
  const {
    theme
  } = props;
  const {
    input
  } = theme.sanity;
  return css(_templateObject46 || (_templateObject46 = _taggedTemplateLiteral(["\n    &:not([hidden]) {\n      display: block;\n    }\n    background-color: var(--switch-bg-color);\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: ", ";\n    height: ", ";\n    border-radius: ", ";\n  "])), rem(input.switch.width), rem(input.switch.height), rem(input.switch.height / 2));
}
function switchThumbStyles(props) {
  const {
    $indeterminate,
    theme
  } = props;
  const {
    input
  } = theme.sanity;
  const trackWidth = input.switch.width;
  const trackHeight = input.switch.height;
  const trackPadding = input.switch.padding;
  const size = trackHeight - input.switch.padding * 2;
  const checkedOffset = trackWidth - trackPadding * 2 - size;
  const indeterminateOffset = trackWidth / 2 - size / 2 - trackPadding;
  const checked = $indeterminate !== true && props.$checked === true;
  return css(_templateObject47 || (_templateObject47 = _taggedTemplateLiteral(["\n    &:not([hidden]) {\n      display: block;\n    }\n    position: absolute;\n    left: ", ";\n    top: ", ";\n    height: ", ";\n    width: ", ";\n    border-radius: ", ";\n    transition-property: transform;\n    transition-duration: ", "ms;\n    transition-timing-function: ", ";\n    background: var(--switch-fg-color);\n    transform: translate3d(0, 0, 0);\n\n    ", "\n\n    ", "\n  "])), rem(trackPadding), rem(trackPadding), rem(size), rem(size), rem(size / 2), input.switch.transitionDurationMs, input.switch.transitionTimingFunction, checked && css(_templateObject48 || (_templateObject48 = _taggedTemplateLiteral(["\n      transform: translate3d(", "px, 0, 0);\n    "])), checkedOffset), $indeterminate && css(_templateObject49 || (_templateObject49 = _taggedTemplateLiteral(["\n      transform: translate3d(", "px, 0, 0);\n    "])), indeterminateOffset));
}
const Root$e = styled.span(switchBaseStyles);
const Input$2 = styled.input(switchInputStyles);
const Representation = styled.span(switchRepresentationStyles);
const Track = styled.span(switchTrackStyles);
const Thumb = styled.span(switchThumbStyles);
const Switch = forwardRef(function Switch2(props, forwardedRef) {
  const {
    checked,
    className,
    disabled,
    indeterminate,
    readOnly,
    style,
    ...restProps
  } = props;
  const ref = useForwardedRef(forwardedRef);
  useEffect(() => {
    if (ref.current) {
      ref.current.indeterminate = indeterminate || false;
    }
  }, [indeterminate, ref]);
  return /* @__PURE__ */jsxs(Root$e, {
    className,
    "data-ui": "Switch",
    style,
    children: [/* @__PURE__ */jsx(Input$2, {
      "data-read-only": !disabled && readOnly ? "" : void 0,
      ...restProps,
      checked: indeterminate !== true && checked,
      disabled: disabled || readOnly,
      type: "checkbox",
      ref
    }), /* @__PURE__ */jsxs(Representation, {
      "aria-hidden": true,
      "data-name": "representation",
      children: [/* @__PURE__ */jsx(Track, {}), /* @__PURE__ */jsx(Thumb, {
        $checked: checked,
        $indeterminate: indeterminate
      })]
    })]
  });
});
const Root$d = styled.span(textInputRootStyle);
const InputRoot$1 = styled.span(_templateObject50 || (_templateObject50 = _taggedTemplateLiteral(["\n  flex: 1;\n  min-width: 0;\n  display: block;\n  position: relative;\n"])));
const Input$1 = styled.textarea(responsiveInputPaddingStyle, textInputBaseStyle, textInputFontSizeStyle);
const Presentation$1 = styled.div(responsiveRadiusStyle, textInputRepresentationStyle);
const TextArea = forwardRef(function TextArea2(props, forwardedRef) {
  const {
    border = true,
    customValidity,
    disabled = false,
    fontSize = 2,
    padding = 3,
    radius = 1,
    weight,
    ...restProps
  } = props;
  const ref = useForwardedRef(forwardedRef);
  const rootTheme = useRootTheme();
  useCustomValidity(ref, customValidity);
  return /* @__PURE__ */jsx(Root$d, {
    "data-ui": "TextArea",
    children: /* @__PURE__ */jsxs(InputRoot$1, {
      children: [/* @__PURE__ */jsx(Input$1, {
        "data-as": "textarea",
        "data-scheme": rootTheme.scheme,
        "data-tone": rootTheme.tone,
        ...restProps,
        $fontSize: useArrayProp(fontSize),
        $padding: useArrayProp(padding),
        $scheme: rootTheme.scheme,
        $space: useArrayProp(0),
        $tone: rootTheme.tone,
        $weight: weight,
        disabled,
        ref
      }), /* @__PURE__ */jsx(Presentation$1, {
        $radius: useArrayProp(radius),
        $scheme: rootTheme.scheme,
        $tone: rootTheme.tone,
        "data-border": border ? "" : void 0,
        "data-scheme": rootTheme.scheme,
        "data-tone": rootTheme.tone
      })]
    })
  });
});
const CLEAR_BUTTON_BOX_STYLE = {
  zIndex: 2
};
const Root$c = styled(Card).attrs({
  forwardedAs: "span"
})(textInputRootStyle);
const InputRoot = styled.span(_templateObject51 || (_templateObject51 = _taggedTemplateLiteral(["\n  flex: 1;\n  min-width: 0;\n  display: block;\n  position: relative;\n"])));
const Prefix = styled(Card).attrs({
  forwardedAs: "span"
})(_templateObject52 || (_templateObject52 = _taggedTemplateLiteral(["\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n\n  & > span {\n    display: block;\n    margin: -1px;\n  }\n"])));
const Suffix = styled(Card).attrs({
  forwardedAs: "span"
})(_templateObject53 || (_templateObject53 = _taggedTemplateLiteral(["\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n\n  & > span {\n    display: block;\n    margin: -1px;\n  }\n"])));
const Input = styled.input(responsiveInputPaddingStyle, textInputBaseStyle, textInputFontSizeStyle);
const Presentation = styled.span(responsiveRadiusStyle, textInputRepresentationStyle);
const LeftBox = styled(Box)(_templateObject54 || (_templateObject54 = _taggedTemplateLiteral(["\n  position: absolute;\n  top: 0;\n  left: 0;\n"])));
const RightBox = styled(Box)(_templateObject55 || (_templateObject55 = _taggedTemplateLiteral(["\n  position: absolute;\n  top: 0;\n  right: 0;\n"])));
const RightCard = styled(Card)(_templateObject56 || (_templateObject56 = _taggedTemplateLiteral(["\n  background-color: transparent;\n  position: absolute;\n  top: 0;\n  right: 0;\n"])));
const TextInput = forwardRef(function TextInput2(props, forwardedRef) {
  const {
    border = true,
    clearButton,
    disabled = false,
    fontSize: fontSizeProp = 2,
    icon,
    iconRight,
    onClear,
    padding: paddingProp = 3,
    prefix,
    radius: radiusProp = 1,
    readOnly,
    space: spaceProp = 3,
    suffix,
    customValidity,
    type = "text",
    weight,
    ...restProps
  } = props;
  const ref = useForwardedRef(forwardedRef);
  const rootTheme = useRootTheme();
  const fontSize = useArrayProp(fontSizeProp);
  const padding = useArrayProp(paddingProp);
  const radius = useArrayProp(radiusProp);
  const space = useArrayProp(spaceProp);
  const $hasClearButton = Boolean(clearButton);
  const $hasIcon = Boolean(icon);
  const $hasIconRight = Boolean(iconRight);
  const $hasSuffix = Boolean(suffix);
  const $hasPrefix = Boolean(prefix);
  useCustomValidity(ref, customValidity);
  const handleClearMouseDown = useCallback(event => {
    event.preventDefault();
    event.stopPropagation();
  }, []);
  const handleClearClick = useCallback(event => {
    var _a;
    event.preventDefault();
    event.stopPropagation();
    if (onClear) onClear();
    (_a = ref.current) == null ? void 0 : _a.focus();
  }, [onClear, ref]);
  const prefixNode = useMemo(() => prefix && /* @__PURE__ */jsx(Prefix, {
    borderTop: true,
    borderLeft: true,
    borderBottom: true,
    radius,
    sizing: "border",
    tone: "inherit",
    children: /* @__PURE__ */jsx("span", {
      children: prefix
    })
  }), [prefix, radius]);
  const presentationNode = useMemo(() => /* @__PURE__ */jsxs(Presentation, {
    $hasPrefix,
    $hasSuffix,
    $radius: radius,
    $scheme: rootTheme.scheme,
    $tone: rootTheme.tone,
    "data-border": border ? "" : void 0,
    "data-scheme": rootTheme.scheme,
    "data-tone": rootTheme.tone,
    children: [icon && /* @__PURE__ */jsx(LeftBox, {
      padding,
      children: /* @__PURE__ */jsxs(Text, {
        size: fontSize,
        children: [isValidElement(icon) && icon, isValidElementType(icon) && createElement(icon)]
      })
    }), !$hasClearButton && iconRight && /* @__PURE__ */jsx(RightBox, {
      padding,
      children: /* @__PURE__ */jsxs(Text, {
        size: fontSize,
        children: [isValidElement(iconRight) && iconRight, isValidElementType(iconRight) && createElement(iconRight)]
      })
    })]
  }), [border, fontSize, icon, iconRight, padding, radius, rootTheme, $hasClearButton, $hasPrefix, $hasSuffix]);
  const clearButtonBoxPadding = useMemo(() => padding.map(v => {
    if (v === 0) return 0;
    if (v === 1) return 1;
    if (v === 2) return 1;
    return v - 2;
  }), [padding]);
  const clearButtonPadding = useMemo(() => padding.map(v => {
    if (v === 0) return 0;
    if (v === 1) return 0;
    if (v === 2) return 1;
    return v - 1;
  }), [padding]);
  const clearButtonProps = useMemo(() => typeof clearButton === "object" ? clearButton : EMPTY_RECORD, [clearButton]);
  const clearButtonNode = useMemo(() => !disabled && !readOnly && clearButton && /* @__PURE__ */jsx(RightCard, {
    forwardedAs: "span",
    padding: clearButtonBoxPadding,
    style: CLEAR_BUTTON_BOX_STYLE,
    tone: customValidity ? "critical" : "inherit",
    children: /* @__PURE__ */jsx(Button, {
      "aria-label": "Clear",
      "data-qa": "clear-button",
      fontSize,
      icon: CloseIcon,
      mode: "bleed",
      padding: clearButtonPadding,
      radius,
      ...clearButtonProps,
      onClick: handleClearClick,
      onMouseDown: handleClearMouseDown
    })
  }), [clearButton, clearButtonBoxPadding, clearButtonPadding, clearButtonProps, customValidity, disabled, fontSize, handleClearClick, handleClearMouseDown, radius, readOnly]);
  const suffixNode = useMemo(() => suffix && /* @__PURE__ */jsx(Suffix, {
    borderTop: true,
    borderRight: true,
    borderBottom: true,
    radius,
    sizing: "border",
    tone: "inherit",
    children: /* @__PURE__ */jsx("span", {
      children: suffix
    })
  }), [radius, suffix]);
  return /* @__PURE__ */jsxs(Root$c, {
    "data-ui": "TextInput",
    tone: rootTheme.tone,
    children: [prefixNode, /* @__PURE__ */jsxs(InputRoot, {
      children: [/* @__PURE__ */jsx(Input, {
        "data-as": "input",
        "data-scheme": rootTheme.scheme,
        "data-tone": rootTheme.tone,
        ...restProps,
        $fontSize: fontSize,
        $iconLeft: $hasIcon,
        $iconRight: $hasIconRight || $hasClearButton,
        $padding: padding,
        $scheme: rootTheme.scheme,
        $space: space,
        $tone: rootTheme.tone,
        $weight: weight,
        disabled,
        readOnly,
        ref,
        type
      }), presentationNode, clearButtonNode]
    }), suffixNode]
  });
});
const Root$b = styled.div(_templateObject57 || (_templateObject57 = _taggedTemplateLiteral(["\n  position: absolute;\n  pointer-events: none;\n  width: 15px;\n  height: 15px;\n  fill: none;\n\n  :empty + & {\n    display: none;\n  }\n\n  & > svg {\n    display: block;\n    transform-origin: 7.5px 7.5px;\n  }\n\n  /* position: absolute;\n  width: 15px;\n  height: 15px;\n  fill: none;\n\n  :empty + & {\n    display: none;\n  }\n\n  & > svg {\n    &:not([hidden]) {\n      display: block;\n    }\n    transform-origin: 7.5px 7.5px;\n  } */\n\n  [data-placement^='top'] > & {\n    bottom: -27px;\n  }\n\n  [data-placement^='right'] > & {\n    left: -27px;\n\n    & > svg {\n      transform: rotate(90deg);\n    }\n  }\n\n  [data-placement^='left'] > & {\n    right: -27px;\n\n    & > svg {\n      transform: rotate(-90deg);\n    }\n  }\n\n  [data-placement^='bottom'] > & {\n    top: -27px;\n\n    & > svg {\n      transform: rotate(180deg);\n    }\n  }\n"])));
const Border = styled.path(_templateObject58 || (_templateObject58 = _taggedTemplateLiteral(["\n  fill: var(--card-shadow-outline-color);\n"])));
const Shape = styled.path(_templateObject59 || (_templateObject59 = _taggedTemplateLiteral(["\n  fill: var(--card-bg-color);\n"])));
const TooltipArrow = forwardRef(function TooltipArrow2(props, ref) {
  const {
    ...restProps
  } = props;
  return /* @__PURE__ */jsx(Root$b, {
    "data-ui": "Tooltip__arrow",
    ...restProps,
    ref,
    children: /* @__PURE__ */jsxs("svg", {
      width: "15",
      height: "15",
      viewBox: "0 0 15 15",
      children: [/* @__PURE__ */jsx(Border, {
        d: "M11.5266 1C11.032 1.32802 10.5837 1.73105 10.1995 2.20057L9.04792 3.6081C8.24771 4.58614 6.7523 4.58614 5.95209 3.6081L4.80047 2.20057C4.41632 1.73105 3.96796 1.32802 3.47341 1H0.156727C1.65639 1 3.07687 1.67313 4.02651 2.83381L5.17813 4.24134C6.37844 5.70839 8.62156 5.70839 9.82187 4.24134L10.9735 2.83381C11.9231 1.67313 13.3436 1 14.8433 1H11.5266Z"
      }), /* @__PURE__ */jsx(Shape, {
        d: "M0.156725 0C1.95632 0 3.66089 0.80776 4.80047 2.20057L5.95209 3.6081C6.75229 4.58614 8.24771 4.58614 9.04791 3.6081L10.1995 2.20057C11.3391 0.80776 13.0437 0 14.8433 0H15H0H0.156725Z"
      })]
    })
  });
});
const Root$a = styled(Layer)(_templateObject60 || (_templateObject60 = _taggedTemplateLiteral(["\n  pointer-events: none;\n"])));
const Tooltip = forwardRef(function Tooltip2(props, ref) {
  var _a, _b, _c;
  const boundaryElementContext = useBoundaryElement();
  const theme = useTheme();
  const {
    boundaryElement = boundaryElementContext == null ? void 0 : boundaryElementContext.element,
    children: childProp,
    content,
    disabled,
    fallbackPlacements: fallbackPlacementsProp,
    padding,
    placement: placementProp = "bottom",
    portal,
    scheme,
    shadow = 2,
    zOffset = (_a = theme.sanity.layer) == null ? void 0 : _a.tooltip.zOffset,
    ...restProps
  } = props;
  const fallbackPlacements = useArrayProp(fallbackPlacementsProp);
  const forwardedRef = useForwardedRef(ref);
  const [referenceElement, setReferenceElement] = useState(null);
  const arrowRef = useRef(null);
  const rootBoundary = "viewport";
  const middleware = useMemo(() => {
    const ret = [];
    ret.push(flip({
      boundary: boundaryElement || void 0,
      fallbackPlacements,
      padding: 4,
      rootBoundary
    }));
    ret.push(offset({
      mainAxis: 3
    }));
    ret.push(shift({
      boundary: boundaryElement || void 0,
      rootBoundary,
      padding: 4
    }));
    ret.push(arrow({
      element: arrowRef,
      padding: 2
    }));
    return ret;
  }, [boundaryElement, fallbackPlacements]);
  const {
    x,
    y,
    placement,
    reference,
    floating,
    middlewareData,
    update,
    strategy
  } = useFloating({
    middleware,
    placement: placementProp,
    whileElementsMounted: autoUpdate
  });
  const rootStyle = useMemo(() => ({
    position: strategy,
    top: y != null ? y : 0,
    left: x != null ? x : 0
  }), [strategy, x, y]);
  const staticSide = placement && FLOATING_STATIC_SIDES[placement.split("-")[0]];
  const arrowX = (_b = middlewareData.arrow) == null ? void 0 : _b.x;
  const arrowY = (_c = middlewareData.arrow) == null ? void 0 : _c.y;
  const arrowStyle = useMemo(() => {
    const style = {
      left: arrowX !== null ? arrowX : void 0,
      top: arrowY !== null ? arrowY : void 0,
      right: void 0,
      bottom: void 0
    };
    if (staticSide) style[staticSide] = -15;
    return style;
  }, [arrowX, arrowY, staticSide]);
  const [isOpen, setIsOpen] = useState(false);
  const handleBlur = useCallback(() => setIsOpen(false), []);
  const handleFocus = useCallback(() => setIsOpen(true), []);
  const handleMouseEnter = useCallback(() => setIsOpen(true), []);
  const handleMouseLeave = useCallback(() => setIsOpen(false), []);
  useEffect(() => {
    if (!isOpen) return;
    function handleWindowMouseMove(event) {
      if (!referenceElement) return;
      const isHoveringReference = referenceElement === event.target || event.target instanceof Node && referenceElement.contains(event.target);
      if (!isHoveringReference) {
        setIsOpen(false);
        window.removeEventListener("mousemove", handleWindowMouseMove);
      }
    }
    window.addEventListener("mousemove", handleWindowMouseMove);
    return () => {
      window.removeEventListener("mousemove", handleWindowMouseMove);
    };
  }, [isOpen, referenceElement]);
  useEffect(() => {
    if (disabled) setIsOpen(false);
  }, [disabled]);
  useEffect(() => {
    if (!content) setIsOpen(false);
  }, [content]);
  useEffect(() => reference(referenceElement), [reference, referenceElement]);
  const setArrow = useCallback(arrowEl => {
    arrowRef.current = arrowEl;
    update();
  }, [update]);
  const setFloating = useCallback(node => {
    forwardedRef.current = node;
    floating(node);
  }, [floating, forwardedRef]);
  const childRef = childProp == null ? void 0 : childProp.ref;
  const setReference = useCallback(node => {
    if (typeof childRef === "function") {
      childRef(node);
    } else if (childRef) {
      childRef.current = node;
    }
    setReferenceElement(node);
  }, [childRef]);
  const child = useMemo(() => {
    if (!childProp) return null;
    return cloneElement(childProp, {
      onBlur: handleBlur,
      onFocus: handleFocus,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      ref: setReference
    });
  }, [childProp, handleBlur, handleFocus, handleMouseEnter, handleMouseLeave, setReference]);
  if (!child) return /* @__PURE__ */jsx(Fragment, {});
  if (disabled) return child;
  const root = /* @__PURE__ */jsx(Root$a, {
    "data-ui": "Tooltip",
    ...restProps,
    ref: setFloating,
    style: rootStyle,
    zOffset,
    children: /* @__PURE__ */jsxs(Card, {
      "data-ui": "Tooltip__card",
      "data-placement": placement,
      padding,
      radius: 2,
      scheme,
      shadow,
      children: [content, /* @__PURE__ */jsx(TooltipArrow, {
        ref: setArrow,
        style: arrowStyle
      })]
    })
  });
  return /* @__PURE__ */jsxs(Fragment, {
    children: [child, isOpen && /* @__PURE__ */jsx(Fragment, {
      children: portal ? /* @__PURE__ */jsx(Portal, {
        __unstable_name: typeof portal === "string" ? portal : void 0,
        children: root
      }) : root
    })]
  });
});
const Root$9 = styled.div(_templateObject61 || (_templateObject61 = _taggedTemplateLiteral(["\n  line-height: 0;\n"])));
const ListBox = styled(Box)(_templateObject62 || (_templateObject62 = _taggedTemplateLiteral(["\n  & > ul {\n    list-style: none;\n    padding: 0;\n    margin: 0;\n  }\n"])));
const rotate = keyframes(_templateObject63 || (_templateObject63 = _taggedTemplateLiteral(["\n  from {\n    transform: rotate(0deg);\n  }\n\n  to {\n    transform: rotate(360deg);\n  }\n"])));
const AnimatedSpinnerIcon = styled(SpinnerIcon)(_templateObject64 || (_templateObject64 = _taggedTemplateLiteral(["\n  animation: ", " 500ms linear infinite;\n"])), rotate);
function AutocompleteOption(props) {
  const {
    children,
    id,
    onSelect,
    selected,
    value
  } = props;
  const handleClick = useCallback(() => {
    setTimeout(() => {
      onSelect(value);
    }, 0);
  }, [onSelect, value]);
  const handleKeyDown = useCallback(event => {
    if (event.key === "Enter" && !_isEnterToClickElement(event.currentTarget)) {
      handleClick();
    }
  }, [handleClick]);
  return /* @__PURE__ */jsx("li", {
    "aria-selected": selected,
    "data-ui": "AutocompleteOption",
    id,
    role: "option",
    onClick: handleClick,
    onKeyDown: handleKeyDown,
    children
  });
}
function autocompleteReducer(state, msg) {
  if (msg.type === "input/change") {
    return {
      ...state,
      activeValue: null,
      focused: true,
      query: msg.query
    };
  }
  if (msg.type === "input/focus") {
    return {
      ...state,
      focused: true
    };
  }
  if (msg.type === "root/blur") {
    return {
      ...state,
      focused: false,
      query: null
    };
  }
  if (msg.type === "root/clear") {
    return {
      ...state,
      activeValue: null,
      query: null,
      value: null
    };
  }
  if (msg.type === "root/escape") {
    return {
      ...state,
      focused: false,
      query: null
    };
  }
  if (msg.type === "root/open") {
    return {
      ...state,
      query: state.query || msg.query
    };
  }
  if (msg.type === "root/setActiveValue") {
    return {
      ...state,
      activeValue: msg.value,
      listFocused: msg.listFocused || state.listFocused
    };
  }
  if (msg.type === "root/setListFocused") {
    return {
      ...state,
      listFocused: msg.listFocused
    };
  }
  if (msg.type === "value/change") {
    return {
      ...state,
      activeValue: msg.value,
      query: null,
      value: msg.value
    };
  }
  return state;
}
const AUTOCOMPLETE_LISTBOX_IGNORE_KEYS = ["Control", "Shift", "Alt", "Enter", "Home", "End", "PageUp", "PageDown", "Meta", "Tab", "CapsLock"];
const AUTOCOMPLETE_POPOVER_PLACEMENT = "bottom-start";
const AUTOCOMPLETE_POPOVER_FALLBACK_PLACEMENTS = ["bottom-start", "top-start"];
const DEFAULT_RENDER_VALUE = (value, option) => option ? option.value : value;
const DEFAULT_FILTER_OPTION = (query, option) => option.value.toLowerCase().indexOf(query.toLowerCase()) > -1;
const InnerAutocomplete = forwardRef(function InnerAutocomplete2(props, ref) {
  const {
    border = true,
    customValidity,
    disabled,
    filterOption: filterOptionProp,
    fontSize = 2,
    icon,
    id,
    listBox = EMPTY_RECORD,
    loading,
    onBlur,
    onChange,
    onFocus,
    onQueryChange,
    onSelect,
    openButton,
    options: optionsProp,
    padding: paddingProp = 3,
    popover = EMPTY_RECORD,
    prefix,
    radius = 3,
    readOnly,
    relatedElements,
    renderOption: renderOptionProp,
    renderPopover,
    renderValue = DEFAULT_RENDER_VALUE,
    suffix,
    value: valueProp,
    ...restProps
  } = props;
  const [state, dispatch] = useReducer(autocompleteReducer, {
    activeValue: valueProp || null,
    focused: false,
    listFocused: false,
    query: null,
    value: valueProp || null
  });
  const {
    activeValue,
    focused,
    listFocused,
    query,
    value
  } = state;
  const defaultRenderOption = useCallback(_ref22 => {
    let {
      value: value2
    } = _ref22;
    return /* @__PURE__ */jsx(Card, {
      "data-as": "button",
      padding: paddingProp,
      radius: 2,
      tone: "inherit",
      children: /* @__PURE__ */jsx(Text, {
        size: fontSize,
        textOverflow: "ellipsis",
        children: value2
      })
    });
  }, [fontSize, paddingProp]);
  const renderOption = typeof renderOptionProp === "function" ? renderOptionProp : defaultRenderOption;
  const filterOption = typeof filterOptionProp === "function" ? filterOptionProp : DEFAULT_FILTER_OPTION;
  const rootElementRef = useRef(null);
  const resultsPopoverElementRef = useRef(null);
  const inputElementRef = useRef(null);
  const listBoxElementRef = useRef(null);
  const listFocusedRef = useRef(false);
  const valueRef = useRef(value);
  const valuePropRef = useRef(valueProp);
  const popoverMouseWithinRef = useRef(false);
  const forwardedRef = useForwardedRef(ref);
  const listBoxId = "".concat(id, "-listbox");
  const options = Array.isArray(optionsProp) ? optionsProp : EMPTY_ARRAY;
  const padding = useArrayProp(paddingProp);
  const currentOption = useMemo(() => value !== null ? options.find(o => o.value === value) : void 0, [options, value]);
  const filteredOptions = useMemo(() => options.filter(option => query ? filterOption(query, option) : true), [filterOption, options, query]);
  const filteredOptionsLen = filteredOptions.length;
  const activeItemId = activeValue ? "".concat(id, "-option-").concat(activeValue) : void 0;
  const expanded = query !== null && loading || focused && query !== null;
  const handleRootBlur = useCallback(event => {
    setTimeout(() => {
      if (popoverMouseWithinRef.current) {
        return;
      }
      const elements = (relatedElements || []).concat(rootElementRef.current ? [rootElementRef.current] : [], resultsPopoverElementRef.current ? [resultsPopoverElementRef.current] : []);
      let focusInside = false;
      if (document.activeElement) {
        for (const e of elements) {
          if (e === document.activeElement || e.contains(document.activeElement)) {
            focusInside = true;
            break;
          }
        }
      }
      if (focusInside === false) {
        dispatch({
          type: "root/blur"
        });
        popoverMouseWithinRef.current = false;
        if (onQueryChange) onQueryChange(null);
        if (onBlur) onBlur(event);
      }
    }, 0);
  }, [onBlur, onQueryChange, relatedElements]);
  const handleRootFocus = useCallback(event => {
    const listBoxElement = listBoxElementRef.current;
    const focusedElement = event.target instanceof HTMLElement ? event.target : null;
    const listFocused2 = (listBoxElement == null ? void 0 : listBoxElement.contains(focusedElement)) || false;
    if (listFocused2 !== listFocusedRef.current) {
      listFocusedRef.current = listFocused2;
      dispatch({
        type: "root/setListFocused",
        listFocused: listFocused2
      });
    }
  }, []);
  const handleOptionSelect = useCallback(v => {
    var _a;
    dispatch({
      type: "value/change",
      value: v
    });
    popoverMouseWithinRef.current = false;
    if (onSelect) onSelect(v);
    valueRef.current = v;
    if (onChange) onChange(v);
    if (onQueryChange) onQueryChange(null);
    (_a = inputElementRef.current) == null ? void 0 : _a.focus();
  }, [onChange, onSelect, onQueryChange]);
  const handleRootKeyDown = useCallback(event => {
    var _a, _b;
    if (event.key === "ArrowDown") {
      event.preventDefault();
      if (!filteredOptionsLen) return;
      const activeOption = filteredOptions.find(o => o.value === activeValue);
      const activeIndex = activeOption ? filteredOptions.indexOf(activeOption) : -1;
      const nextActiveOption = filteredOptions[(activeIndex + 1) % filteredOptionsLen];
      if (nextActiveOption) {
        dispatch({
          type: "root/setActiveValue",
          value: nextActiveOption.value,
          listFocused: true
        });
      }
      return;
    }
    if (event.key === "ArrowUp") {
      event.preventDefault();
      if (!filteredOptionsLen) return;
      const activeOption = filteredOptions.find(o => o.value === activeValue);
      const activeIndex = activeOption ? filteredOptions.indexOf(activeOption) : -1;
      const nextActiveOption = filteredOptions[activeIndex === -1 ? filteredOptionsLen - 1 : (filteredOptionsLen + activeIndex - 1) % filteredOptionsLen];
      if (nextActiveOption) {
        dispatch({
          type: "root/setActiveValue",
          value: nextActiveOption.value,
          listFocused: true
        });
      }
      return;
    }
    if (event.key === "Escape") {
      dispatch({
        type: "root/escape"
      });
      popoverMouseWithinRef.current = false;
      if (onQueryChange) onQueryChange(null);
      (_a = inputElementRef.current) == null ? void 0 : _a.focus();
      return;
    }
    const target = event.target;
    const listEl = listBoxElementRef.current;
    if ((listEl === target || (listEl == null ? void 0 : listEl.contains(target))) && !AUTOCOMPLETE_LISTBOX_IGNORE_KEYS.includes(event.key)) {
      (_b = inputElementRef.current) == null ? void 0 : _b.focus();
      return;
    }
  }, [activeValue, filteredOptions, filteredOptionsLen, onQueryChange]);
  const handleInputChange = useCallback(event => {
    const nextQuery = event.currentTarget.value;
    dispatch({
      type: "input/change",
      query: nextQuery
    });
    if (onQueryChange) onQueryChange(nextQuery);
  }, [onQueryChange]);
  const handleInputFocus = useCallback(event => {
    if (!focused) {
      dispatch({
        type: "input/focus"
      });
      if (onFocus) onFocus(event);
    }
  }, [focused, onFocus]);
  const handlePopoverMouseEnter = useCallback(() => {
    popoverMouseWithinRef.current = true;
  }, []);
  const handlePopoverMouseLeave = useCallback(() => {
    popoverMouseWithinRef.current = false;
  }, []);
  const handleClearButtonClick = useCallback(() => {
    var _a;
    dispatch({
      type: "root/clear"
    });
    valueRef.current = "";
    if (onChange) onChange("");
    if (onQueryChange) onQueryChange(null);
    (_a = inputElementRef.current) == null ? void 0 : _a.focus();
  }, [onChange, onQueryChange]);
  const handleClearButtonFocus = useCallback(() => {
    dispatch({
      type: "input/focus"
    });
  }, []);
  useEffect(() => {
    if (valueProp !== valuePropRef.current) {
      valuePropRef.current = valueProp;
      if (valueProp !== void 0) {
        dispatch({
          type: "value/change",
          value: valueProp
        });
        valueRef.current = valueProp;
      }
      return;
    }
    if (valueProp !== valueRef.current) {
      valueRef.current = valueProp || null;
      dispatch({
        type: "value/change",
        value: valueProp || null
      });
    }
  }, [valueProp]);
  useEffect(() => {
    if (!focused && valueRef.current) {
      dispatch({
        type: "root/setActiveValue",
        value: valueRef.current
      });
    }
  }, [focused]);
  useEffect(() => {
    const listElement = listBoxElementRef.current;
    if (!listElement) return;
    const activeOption = filteredOptions.find(o => o.value === activeValue);
    if (activeOption) {
      const activeIndex = filteredOptions.indexOf(activeOption);
      const activeItemElement = listElement.childNodes[activeIndex];
      if (activeItemElement) {
        if (_hasFocus(activeItemElement)) {
          return;
        }
        focusFirstDescendant(activeItemElement);
      }
    }
  }, [activeValue, filteredOptions]);
  const setRef = useCallback(el => {
    inputElementRef.current = el;
    forwardedRef.current = el;
  }, [forwardedRef]);
  const clearButton = useMemo(() => {
    if (!loading && !disabled && value) {
      return {
        "aria-label": "Clear",
        onFocus: handleClearButtonFocus
      };
    }
    return void 0;
  }, [disabled, handleClearButtonFocus, loading, value]);
  const openButtonBoxPadding = useMemo(() => padding.map(v => {
    if (v === 0) return 0;
    if (v === 1) return 1;
    if (v === 2) return 1;
    return v - 2;
  }), [padding]);
  const openButtonPadding = useMemo(() => padding.map(v => Math.max(v - 1, 0)), [padding]);
  const openButtonProps = useMemo(() => typeof openButton === "object" ? openButton : EMPTY_RECORD, [openButton]);
  const handleOpenClick = useCallback(event => {
    dispatch({
      type: "root/open",
      query: value ? renderValue(value, currentOption) : ""
    });
    if (openButtonProps.onClick) openButtonProps.onClick(event);
    _raf(() => {
      var _a;
      return (_a = inputElementRef.current) == null ? void 0 : _a.focus();
    });
  }, [currentOption, openButtonProps, renderValue, value]);
  const openButtonNode = useMemo(() => !disabled && !readOnly && openButton ? /* @__PURE__ */jsx(Box, {
    "aria-hidden": expanded,
    padding: openButtonBoxPadding,
    children: /* @__PURE__ */jsx(Button, {
      "aria-label": "Open",
      disabled: expanded,
      fontSize,
      icon: ChevronDownIcon,
      mode: "bleed",
      padding: openButtonPadding,
      ...openButtonProps,
      onClick: handleOpenClick
    })
  }) : void 0, [disabled, expanded, fontSize, handleOpenClick, openButton, openButtonBoxPadding, openButtonPadding, openButtonProps, readOnly]);
  const inputValue = useMemo(() => {
    if (query === null) {
      if (value !== null) {
        return renderValue(value, currentOption);
      }
      return "";
    }
    return query;
  }, [currentOption, query, renderValue, value]);
  const input = /* @__PURE__ */jsx(TextInput, {
    ...restProps,
    "aria-activedescendant": activeItemId,
    "aria-autocomplete": "list",
    "aria-expanded": expanded,
    "aria-owns": listBoxId,
    autoCapitalize: "off",
    autoComplete: "off",
    autoCorrect: "off",
    border,
    clearButton,
    customValidity,
    disabled,
    fontSize,
    icon,
    iconRight: loading && AnimatedSpinnerIcon,
    id,
    inputMode: "search",
    onChange: handleInputChange,
    onClear: handleClearButtonClick,
    onFocus: handleInputFocus,
    padding,
    prefix,
    radius,
    readOnly,
    ref: setRef,
    role: "combobox",
    spellCheck: false,
    suffix: suffix || openButtonNode,
    value: inputValue
  });
  const handleListBoxKeyDown = useCallback(event => {
    var _a;
    if (event.key === "Tab") {
      if (listFocused) (_a = inputElementRef.current) == null ? void 0 : _a.focus();
    }
  }, [listFocused]);
  const content = useMemo(() => {
    if (filteredOptions.length === 0) return null;
    return /* @__PURE__ */jsx(ListBox, {
      "data-ui": "AutoComplete__results",
      onKeyDown: handleListBoxKeyDown,
      padding: 1,
      ...listBox,
      tabIndex: -1,
      children: /* @__PURE__ */jsx(Stack, {
        as: "ul",
        "aria-multiselectable": false,
        "data-ui": "AutoComplete__resultsList",
        id: listBoxId,
        ref: listBoxElementRef,
        role: "listbox",
        space: 1,
        children: filteredOptions.map(option => {
          const active = activeValue !== null ? option.value === activeValue : currentOption === option;
          return /* @__PURE__ */jsx(AutocompleteOption, {
            id: "".concat(id, "-option-").concat(option.value),
            onSelect: handleOptionSelect,
            selected: active,
            value: option.value,
            children: cloneElement(renderOption(option), {
              disabled: loading,
              selected: active,
              tabIndex: listFocused && active ? 0 : -1
            })
          }, option.value);
        })
      })
    });
  }, [activeValue, currentOption, filteredOptions, handleOptionSelect, handleListBoxKeyDown, id, listBox, listBoxId, listFocused, loading, renderOption]);
  const results = useMemo(() => {
    if (renderPopover) {
      return renderPopover({
        content,
        hidden: !expanded,
        inputElement: inputElementRef.current,
        onMouseEnter: handlePopoverMouseEnter,
        onMouseLeave: handlePopoverMouseLeave
      }, resultsPopoverElementRef);
    }
    if (filteredOptionsLen === 0) {
      return null;
    }
    return /* @__PURE__ */jsx(Popover, {
      arrow: false,
      constrainSize: true,
      content,
      fallbackPlacements: AUTOCOMPLETE_POPOVER_FALLBACK_PLACEMENTS,
      matchReferenceWidth: true,
      onMouseEnter: handlePopoverMouseEnter,
      onMouseLeave: handlePopoverMouseLeave,
      open: expanded,
      overflow: "auto",
      placement: AUTOCOMPLETE_POPOVER_PLACEMENT,
      portal: true,
      radius,
      ref: resultsPopoverElementRef,
      referenceElement: inputElementRef.current,
      ...popover
    });
  }, [content, expanded, filteredOptionsLen, handlePopoverMouseEnter, handlePopoverMouseLeave, popover, radius, renderPopover]);
  return /* @__PURE__ */jsxs(Root$9, {
    "data-ui": "Autocomplete",
    onBlur: handleRootBlur,
    onFocus: handleRootFocus,
    onKeyDown: handleRootKeyDown,
    ref: rootElementRef,
    children: [input, results]
  });
});
const Autocomplete = InnerAutocomplete;
const Root$8 = styled.ol(_templateObject65 || (_templateObject65 = _taggedTemplateLiteral(["\n  margin: 0;\n  padding: 0;\n  display: flex;\n  list-style: none;\n  align-items: center;\n  white-space: nowrap;\n  line-height: 0;\n"])));
const ExpandButton = styled(Button)(_templateObject66 || (_templateObject66 = _taggedTemplateLiteral(["\n  appearance: none;\n  margin: -4px;\n"])));
const Breadcrumbs = forwardRef(function Breadcrumbs2(props, ref) {
  const {
    children,
    maxLength,
    separator,
    space: spaceRaw = 2,
    ...restProps
  } = props;
  const space = useArrayProp(spaceRaw);
  const [open, setOpen] = useState(false);
  const [expandElement, setExpandElement] = useState(null);
  const [popoverElement, setPopoverElement] = useState(null);
  const collapse = useCallback(() => setOpen(false), []);
  const expand = useCallback(() => setOpen(true), []);
  useClickOutside(collapse, [expandElement, popoverElement]);
  const rawItems = useMemo(() => Children.toArray(children).filter(child => {
    return isValidElement(child);
  }), [children]);
  const items = useMemo(() => {
    const len = rawItems.length;
    if (maxLength && len > maxLength) {
      const beforeLength = Math.ceil(maxLength / 2);
      const afterLength = Math.floor(maxLength / 2);
      return [...rawItems.slice(0, beforeLength - 1), /* @__PURE__ */jsx(Popover, {
        constrainSize: true,
        content: /* @__PURE__ */jsx(Stack, {
          as: "ol",
          overflow: "auto",
          padding: space,
          space,
          children: rawItems.slice(beforeLength - 1, len - afterLength)
        }),
        open,
        placement: "top",
        portal: true,
        ref: setPopoverElement,
        children: /* @__PURE__ */jsx(ExpandButton, {
          fontSize: 1,
          mode: "bleed",
          onClick: open ? collapse : expand,
          padding: 1,
          ref: setExpandElement,
          selected: open,
          text: "\u2026"
        })
      }, "button"), ...rawItems.slice(len - afterLength)];
    }
    return rawItems;
  }, [collapse, expand, maxLength, open, rawItems, space]);
  return /* @__PURE__ */jsx(Root$8, {
    "data-ui": "Breadcrumbs",
    ...restProps,
    ref,
    children: items.map((item, itemIndex) => /* @__PURE__ */jsxs(Fragment$1, {
      children: [itemIndex > 0 && /* @__PURE__ */jsx(Box, {
        "aria-hidden": true,
        as: "li",
        paddingX: space,
        children: separator || /* @__PURE__ */jsx(Text, {
          muted: true,
          children: "/"
        })
      }), /* @__PURE__ */jsx(Box, {
        as: "li",
        children: item
      })]
    }, itemIndex))
  });
});
function dialogStyle(_ref23) {
  let {
    theme
  } = _ref23;
  const color = theme.sanity.color.base;
  return {
    "&:not([hidden])": {
      display: "flex"
    },
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    alignItems: "center",
    justifyContent: "center",
    outline: "none",
    background: color.shadow.umbra
  };
}
function responsiveDialogPositionStyle(props) {
  const {
    theme
  } = props;
  const {
    media
  } = theme.sanity;
  return _responsive(media, props.$position, position => ({
    "&&": {
      position
    }
  }));
}
const key$3 = Symbol.for("@sanity/ui/context/dialog");
globalScope[key$3] = globalScope[key$3] || createContext({
  version: 0
});
const DialogContext = globalScope[key$3];
function useDialog() {
  return useContext(DialogContext);
}
const Root$7 = styled(Layer)(responsivePaddingStyle, dialogStyle, responsiveDialogPositionStyle);
const DialogContainer = styled(Container)(_templateObject67 || (_templateObject67 = _taggedTemplateLiteral(["\n  &:not([hidden]) {\n    display: flex;\n  }\n  width: 100%;\n  height: 100%;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n"])));
const DialogCardRoot = styled(Card)(_templateObject68 || (_templateObject68 = _taggedTemplateLiteral(["\n  &:not([hidden]) {\n    display: flex;\n  }\n  width: 100%;\n  min-height: 0;\n  max-height: 100%;\n  overflow: hidden;\n"])));
const DialogLayout = styled(Flex)(_templateObject69 || (_templateObject69 = _taggedTemplateLiteral(["\n  flex: 1;\n  min-height: 0;\n  width: 100%;\n"])));
const DialogHeader = styled(Card)(_templateObject70 || (_templateObject70 = _taggedTemplateLiteral(["\n  position: relative;\n  z-index: 2;\n\n  &:after {\n    content: '';\n    display: block;\n    position: absolute;\n    left: 0;\n    right: 0;\n    bottom: -1px;\n    border-bottom: 1px solid var(--card-hairline-soft-color);\n  }\n"])));
const DialogContent = styled(Box)(_templateObject71 || (_templateObject71 = _taggedTemplateLiteral(["\n  position: relative;\n  z-index: 1;\n  overflow: auto;\n  outline: none;\n"])));
const DialogFooter = styled(Box)(_templateObject72 || (_templateObject72 = _taggedTemplateLiteral(["\n  position: relative;\n  z-index: 3;\n  border-top: 1px solid var(--card-hairline-soft-color);\n"])));
const DialogCard = forwardRef(function DialogCard2(props, ref) {
  const {
    __unstable_autoFocus: autoFocus,
    __unstable_hideCloseButton: hideCloseButton,
    children,
    contentRef,
    footer,
    header,
    id,
    onClickOutside,
    onClose,
    radius: radiusProp,
    scheme,
    shadow: shadowProp,
    width: widthProp
  } = props;
  const radius = useArrayProp(radiusProp);
  const shadow = useArrayProp(shadowProp);
  const width = useArrayProp(widthProp);
  const forwardedRef = useForwardedRef(ref);
  const [rootElement, setRootElement] = useState(null);
  const localContentRef = useRef(null);
  const layer = useLayer();
  const {
    isTopLayer
  } = layer;
  const labelId = "".concat(id, "_label");
  const showCloseButton = Boolean(onClose) && hideCloseButton === false;
  const showHeader = Boolean(header) || showCloseButton;
  useEffect(() => {
    if (!autoFocus) return;
    if (forwardedRef.current) {
      focusFirstDescendant(forwardedRef.current);
    }
  }, [autoFocus, forwardedRef]);
  useGlobalKeyDown(useCallback(event => {
    if (!isTopLayer || !onClose) return;
    if (event.key === "Escape") {
      event.preventDefault();
      event.stopPropagation();
      onClose();
    }
  }, [isTopLayer, onClose]));
  useClickOutside(useCallback(() => {
    if (!isTopLayer || !onClickOutside) return;
    onClickOutside();
  }, [isTopLayer, onClickOutside]), [rootElement]);
  const setRef = useCallback(el => {
    setRootElement(el);
    forwardedRef.current = el;
  }, [forwardedRef]);
  const setContentRef = useCallback(el => {
    localContentRef.current = el;
    if (typeof contentRef === "function") contentRef(el);else if (contentRef) contentRef.current = el;
  }, [contentRef]);
  return /* @__PURE__ */jsx(DialogContainer, {
    "data-ui": "DialogCard",
    width,
    children: /* @__PURE__ */jsx(DialogCardRoot, {
      radius,
      ref: setRef,
      scheme,
      shadow,
      children: /* @__PURE__ */jsxs(DialogLayout, {
        direction: "column",
        children: [showHeader && /* @__PURE__ */jsx(DialogHeader, {
          children: /* @__PURE__ */jsxs(Flex, {
            children: [/* @__PURE__ */jsx(Box, {
              flex: 1,
              padding: 4,
              children: header && /* @__PURE__ */jsx(Text, {
                id: labelId,
                weight: "semibold",
                children: header
              })
            }), showCloseButton && /* @__PURE__ */jsx(Box, {
              padding: 2,
              children: /* @__PURE__ */jsx(Button, {
                "aria-label": "Close dialog",
                disabled: !onClose,
                icon: CloseIcon,
                mode: "bleed",
                onClick: onClose,
                padding: 3
              })
            })]
          })
        }), /* @__PURE__ */jsx(DialogContent, {
          flex: 1,
          ref: setContentRef,
          tabIndex: -1,
          children
        }), footer && /* @__PURE__ */jsx(DialogFooter, {
          children: footer
        })]
      })
    })
  });
});
const Dialog = forwardRef(function Dialog2(props, ref) {
  var _a;
  const dialog = useDialog();
  const theme = useTheme();
  const {
    __unstable_autoFocus: autoFocus = true,
    __unstable_hideCloseButton: hideCloseButton = false,
    cardRadius: cardRadiusProp = 3,
    cardShadow = 4,
    children,
    contentRef,
    footer,
    header,
    id,
    onClickOutside,
    onClose,
    padding: paddingProp = 4,
    portal,
    position: positionProp = dialog.position || "fixed",
    scheme,
    width: widthProp = 0,
    zOffset: zOffsetProp = dialog.zOffset || ((_a = theme.sanity.layer) == null ? void 0 : _a.dialog.zOffset),
    ...restProps
  } = props;
  const cardRadius = useArrayProp(cardRadiusProp);
  const padding = useArrayProp(paddingProp);
  const position = useArrayProp(positionProp);
  const width = useArrayProp(widthProp);
  const zOffset = useArrayProp(zOffsetProp);
  const preDivRef = useRef(null);
  const postDivRef = useRef(null);
  const cardRef = useRef(null);
  const handleFocus = useCallback(event => {
    const target = event.target;
    const cardElement = cardRef.current;
    if (!cardElement) {
      return;
    }
    if (target === preDivRef.current) {
      focusLastDescendant(cardElement);
      return;
    }
    if (target === postDivRef.current) {
      focusFirstDescendant(cardElement);
      return;
    }
  }, []);
  const labelId = "".concat(id, "_label");
  return /* @__PURE__ */jsx(Portal, {
    __unstable_name: portal,
    children: /* @__PURE__ */jsxs(Root$7, {
      ...restProps,
      $padding: padding,
      $position: position,
      "aria-labelledby": labelId,
      "aria-modal": true,
      "data-ui": "Dialog",
      id,
      onFocus: handleFocus,
      ref,
      role: "dialog",
      zOffset,
      children: [/* @__PURE__ */jsx("div", {
        ref: preDivRef,
        tabIndex: 0
      }), /* @__PURE__ */jsx(DialogCard, {
        __unstable_autoFocus: autoFocus,
        __unstable_hideCloseButton: hideCloseButton,
        contentRef,
        footer,
        header,
        id,
        onClickOutside,
        onClose,
        radius: cardRadius,
        ref: cardRef,
        scheme,
        shadow: cardShadow,
        width,
        children
      }), /* @__PURE__ */jsx("div", {
        ref: postDivRef,
        tabIndex: 0
      })]
    })
  });
});
function DialogProvider(props) {
  const {
    children,
    position,
    zOffset
  } = props;
  const contextValue = useMemo(() => ({
    version: 0,
    position,
    zOffset
  }), [position, zOffset]);
  return /* @__PURE__ */jsx(DialogContext.Provider, {
    value: contextValue,
    children
  });
}
const Root$6 = styled.kbd(_templateObject73 || (_templateObject73 = _taggedTemplateLiteral(["\n  &:not([hidden]) {\n    display: block;\n  }\n  font: inherit;\n"])));
const Key = styled(KBD)(_templateObject74 || (_templateObject74 = _taggedTemplateLiteral(["\n  &:not([hidden]) {\n    display: block;\n  }\n"])));
const Hotkeys = forwardRef(function Hotkeys2(props, ref) {
  const {
    fontSize,
    keys,
    padding,
    radius,
    space: spaceProp = 1,
    ...restProps
  } = props;
  const space = useArrayProp(spaceProp);
  if (!keys || keys.length === 0) {
    return /* @__PURE__ */jsx(Fragment, {});
  }
  return /* @__PURE__ */jsx(Root$6, {
    "data-ui": "Hotkeys",
    ...restProps,
    ref,
    children: /* @__PURE__ */jsx(Inline, {
      as: "span",
      space,
      children: keys.map((key, i) => /* @__PURE__ */jsx(Key, {
        fontSize,
        padding,
        radius,
        children: key
      }, i))
    })
  });
});
const key$2 = Symbol.for("@sanity/ui/context/menu");
globalScope[key$2] = globalScope[key$2] || createContext(null);
const MenuContext = globalScope[key$2];
function _isFocusable(element) {
  return isHTMLAnchorElement(element) && element.getAttribute("data-disabled") !== "true" || isHTMLButtonElement(element) && !element.disabled;
}
function _getFocusableElements(elements) {
  return elements.filter(_isFocusable);
}
function _getDOMPath(rootElement, el) {
  const path = [];
  let e = el;
  while (e !== rootElement) {
    const parentElement = e.parentElement;
    if (!parentElement) return path;
    const children = Array.from(parentElement.childNodes);
    const index = children.indexOf(e);
    path.unshift(index);
    if (parentElement === rootElement) {
      return path;
    }
    e = parentElement;
  }
  return path;
}
const EMPTY_PATH = [];
function _sortElements(rootElement, elements) {
  if (!rootElement) return;
  const map = /* @__PURE__ */new WeakMap();
  for (const el of elements) {
    map.set(el, _getDOMPath(rootElement, el));
  }
  const _sort = (a, b) => {
    const _a = map.get(a) || EMPTY_PATH;
    const _b = map.get(b) || EMPTY_PATH;
    const len = Math.max(_a.length, _b.length);
    for (let i = 0; i < len; i += 1) {
      const aIndex = _a[i] || -1;
      const bIndex = _b[i] || -1;
      if (aIndex !== bIndex) {
        return aIndex - bIndex;
      }
    }
    return 0;
  };
  elements.sort(_sort);
}
function useMenuController(props) {
  const {
    onKeyDown,
    originElement,
    shouldFocus
  } = props;
  const elementsRef = useRef([]);
  const [rootElement, setRootElement] = useState(null);
  const [activeIndex, _setActiveIndex] = useState(-1);
  const activeIndexRef = useRef(activeIndex);
  const activeElement = elementsRef.current[activeIndex] || null;
  const mounted = Boolean(rootElement);
  const setActiveIndex = useCallback(nextActiveIndex => {
    _setActiveIndex(nextActiveIndex);
    activeIndexRef.current = nextActiveIndex;
  }, []);
  const mount = useCallback((element, selected) => {
    if (!element) return () => void 0;
    if (elementsRef.current.indexOf(element) === -1) {
      elementsRef.current.push(element);
      _sortElements(rootElement, elementsRef.current);
    }
    if (selected) {
      const selectedIndex = elementsRef.current.indexOf(element);
      setActiveIndex(selectedIndex);
    }
    return () => {
      const idx = elementsRef.current.indexOf(element);
      if (idx > -1) {
        elementsRef.current.splice(idx, 1);
      }
    };
  }, [rootElement, setActiveIndex]);
  const handleKeyDown = useCallback(event => {
    if (event.key === "Tab") {
      if (originElement) {
        originElement.focus();
      }
      return;
    }
    if (event.key === "Home") {
      event.preventDefault();
      event.stopPropagation();
      const focusableElements = _getFocusableElements(elementsRef.current);
      const el = focusableElements[0];
      if (!el) return;
      const currentIndex = elementsRef.current.indexOf(el);
      setActiveIndex(currentIndex);
      return;
    }
    if (event.key === "End") {
      event.preventDefault();
      event.stopPropagation();
      const focusableElements = _getFocusableElements(elementsRef.current);
      const el = focusableElements[focusableElements.length - 1];
      if (!el) return;
      const currentIndex = elementsRef.current.indexOf(el);
      setActiveIndex(currentIndex);
      return;
    }
    if (event.key === "ArrowUp") {
      event.preventDefault();
      event.stopPropagation();
      const focusableElements = _getFocusableElements(elementsRef.current);
      const focusableLen = focusableElements.length;
      if (focusableLen === 0) return;
      const focusedElement = elementsRef.current[activeIndexRef.current];
      let focusedIndex = focusableElements.indexOf(focusedElement);
      focusedIndex = (focusedIndex - 1 + focusableLen) % focusableLen;
      const el = focusableElements[focusedIndex];
      const currentIndex = elementsRef.current.indexOf(el);
      setActiveIndex(currentIndex);
      return;
    }
    if (event.key === "ArrowDown") {
      event.preventDefault();
      event.stopPropagation();
      const focusableElements = _getFocusableElements(elementsRef.current);
      const focusableLen = focusableElements.length;
      if (focusableLen === 0) return;
      const focusedElement = elementsRef.current[activeIndexRef.current];
      let focusedIndex = focusableElements.indexOf(focusedElement);
      focusedIndex = (focusedIndex + 1) % focusableLen;
      const el = focusableElements[focusedIndex];
      const currentIndex = elementsRef.current.indexOf(el);
      setActiveIndex(currentIndex);
      return;
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  }, [onKeyDown, originElement, setActiveIndex]);
  const handleItemMouseEnter = useCallback(event => {
    const element = event.currentTarget;
    const currentIndex = elementsRef.current.indexOf(element);
    setActiveIndex(currentIndex);
  }, [setActiveIndex]);
  const handleItemMouseLeave = useCallback(() => {
    rootElement == null ? void 0 : rootElement.focus();
    setActiveIndex(-1);
  }, [rootElement, setActiveIndex]);
  useEffect(() => {
    if (!mounted) return;
    const rafId = window.requestAnimationFrame(() => {
      const _activeIndex = activeIndexRef.current;
      if (_activeIndex === -1) {
        if (shouldFocus === "first") {
          const focusableElements = _getFocusableElements(elementsRef.current);
          const el = focusableElements[0];
          if (el) {
            const currentIndex = elementsRef.current.indexOf(el);
            setActiveIndex(currentIndex);
            activeIndexRef.current = currentIndex;
          }
        }
        if (shouldFocus === "last") {
          const focusableElements = _getFocusableElements(elementsRef.current);
          const el = focusableElements[focusableElements.length - 1];
          if (el) {
            const currentIndex = elementsRef.current.indexOf(el);
            setActiveIndex(currentIndex);
            activeIndexRef.current = currentIndex;
          }
        }
        return;
      }
      const element = elementsRef.current[_activeIndex] || null;
      element == null ? void 0 : element.focus();
    });
    return () => {
      window.cancelAnimationFrame(rafId);
    };
  }, [activeIndex, mounted, setActiveIndex, shouldFocus]);
  return {
    activeElement,
    activeIndex,
    handleItemMouseEnter,
    handleItemMouseLeave,
    handleKeyDown,
    mount,
    rootElement,
    setRootElement
  };
}
const Root$5 = styled(Box)(_templateObject75 || (_templateObject75 = _taggedTemplateLiteral(["\n  outline: none;\n  overflow: auto;\n"])));
const Menu = forwardRef(function Menu2(props, ref) {
  const {
    children,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    focusFirst,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    focusLast,
    onClickOutside,
    onEscape,
    onItemClick,
    onItemSelect,
    onKeyDown,
    originElement,
    padding = 1,
    registerElement,
    shouldFocus = props.focusFirst && "first" || props.focusLast && "last" || null,
    space = 1,
    ...restProps
  } = props;
  const forwardedRef = useForwardedRef(ref);
  const {
    isTopLayer
  } = useLayer();
  const {
    activeElement,
    activeIndex,
    handleItemMouseEnter,
    handleItemMouseLeave,
    handleKeyDown,
    mount,
    rootElement,
    setRootElement
  } = useMenuController({
    onKeyDown,
    originElement,
    shouldFocus
  });
  const handleRefChange = useCallback(el => {
    setRootElement(el);
    forwardedRef.current = el;
  }, [forwardedRef, setRootElement]);
  useEffect(() => {
    if (onItemSelect) onItemSelect(activeIndex);
  }, [activeIndex, onItemSelect]);
  useClickOutside(useCallback(event => isTopLayer && onClickOutside && onClickOutside(event), [isTopLayer, onClickOutside]), [rootElement]);
  useGlobalKeyDown(useCallback(event => {
    if (!isTopLayer) return;
    if (event.key === "Escape") {
      event.stopPropagation();
      if (onEscape) onEscape();
    }
  }, [isTopLayer, onEscape]));
  useEffect(() => {
    if (!rootElement || !registerElement) return;
    return registerElement(rootElement);
  }, [registerElement, rootElement]);
  const value = useMemo(() => ({
    version: 0,
    activeElement,
    activeIndex,
    mount,
    onClickOutside,
    onEscape,
    onItemClick,
    onItemMouseEnter: handleItemMouseEnter,
    onItemMouseLeave: handleItemMouseLeave,
    registerElement,
    // deprecated
    onMouseEnter: handleItemMouseEnter,
    onMouseLeave: handleItemMouseLeave
  }), [activeElement, activeIndex, mount, handleItemMouseEnter, handleItemMouseLeave, onClickOutside, onEscape, onItemClick, registerElement]);
  return /* @__PURE__ */jsx(MenuContext.Provider, {
    value,
    children: /* @__PURE__ */jsx(Root$5, {
      "data-ui": "Menu",
      ...restProps,
      onKeyDown: handleKeyDown,
      padding,
      ref: handleRefChange,
      role: "menu",
      tabIndex: -1,
      children: /* @__PURE__ */jsx(Stack, {
        space,
        children
      })
    })
  });
});
const MenuButton = forwardRef(function MenuButton2(props, ref) {
  const {
    __unstable_disableRestoreFocusOnClose: disableRestoreFocusOnClose = false,
    boundaryElement: deprecated_boundaryElement,
    button: buttonProp,
    id,
    menu: menuProp,
    onClose,
    placement: deprecated_placement,
    popoverScheme: deprecated_popoverScheme,
    portal: deprecated_portal = true,
    popover,
    popoverRadius: deprecated_popoverRadius,
    preventOverflow: deprecated_preventOverflow
  } = props;
  const [open, setOpen] = useState(false);
  const [shouldFocus, setShouldFocus] = useState(null);
  const [buttonElement, setButtonElement] = useState(null);
  const [menuElements, setChildMenuElements] = useState([]);
  const openRef = useRef(open);
  useEffect(() => {
    if (onClose && !open && openRef.current) {
      onClose();
    }
  }, [onClose, open]);
  useEffect(() => {
    openRef.current = open;
  }, [open]);
  const handleButtonClick = useCallback(() => {
    setOpen(v => !v);
    setShouldFocus(null);
  }, []);
  const handleButtonKeyDown = useCallback(event => {
    if (event.key === "ArrowDown" || event.key === "Enter" || event.key === " ") {
      event.preventDefault();
      setOpen(true);
      setShouldFocus("first");
      return;
    }
    if (event.key === "ArrowUp") {
      event.preventDefault();
      setOpen(true);
      setShouldFocus("last");
      return;
    }
  }, []);
  const handleMenuClickOutside = useCallback(event => {
    const target = event.target;
    if (!(target instanceof Node)) {
      return;
    }
    if (buttonElement && (target === buttonElement || buttonElement.contains(target))) {
      return;
    }
    for (const el of menuElements) {
      if (target === el || el.contains(target)) {
        return;
      }
    }
    setOpen(false);
  }, [buttonElement, menuElements]);
  const handleMenuEscape = useCallback(() => {
    setOpen(false);
    if (disableRestoreFocusOnClose) return;
    if (buttonElement) buttonElement.focus();
  }, [buttonElement, disableRestoreFocusOnClose]);
  const handleBlur = useCallback(event => {
    const target = event.relatedTarget;
    if (!(target instanceof Node)) {
      return;
    }
    for (const el of menuElements) {
      if (el === target || el.contains(target)) {
        return;
      }
    }
    setOpen(false);
  }, [menuElements]);
  const handleItemClick = useCallback(() => {
    setOpen(false);
    if (disableRestoreFocusOnClose) return;
    if (buttonElement) buttonElement.focus();
  }, [buttonElement, disableRestoreFocusOnClose]);
  const registerElement = useCallback(el => {
    setChildMenuElements(els => els.concat([el]));
    return () => {
      setChildMenuElements(els => {
        return els.filter(_el => _el !== el);
      });
    };
  }, []);
  const menuProps = useMemo(() => ({
    "aria-labelledby": id,
    onBlurCapture: handleBlur,
    onClickOutside: handleMenuClickOutside,
    onEscape: handleMenuEscape,
    onItemClick: handleItemClick,
    originElement: buttonElement,
    registerElement,
    shouldFocus
  }), [buttonElement, handleMenuClickOutside, handleMenuEscape, handleItemClick, id, handleBlur, registerElement, shouldFocus]);
  const menu = isElement$1(menuProp) ? cloneElement(menuProp, menuProps) : null;
  const setButtonRef = useCallback(el => {
    if (typeof ref === "function") {
      ref(el);
    } else if (ref) {
      ref.current = el;
    }
    setButtonElement(el);
  }, [ref]);
  const button = useMemo(() => isElement$1(buttonProp) ? cloneElement(buttonProp, {
    "data-ui": "MenuButton",
    id,
    onClick: handleButtonClick,
    onKeyDown: handleButtonKeyDown,
    "aria-haspopup": true,
    "aria-expanded": open,
    ref: setButtonRef,
    selected: open
  }) : null, [buttonProp, handleButtonClick, handleButtonKeyDown, id, open, setButtonRef]);
  const popoverProps = useMemo(() => ({
    boundaryElement: deprecated_boundaryElement,
    overflow: "auto",
    placement: deprecated_placement,
    portal: deprecated_portal,
    preventOverflow: deprecated_preventOverflow,
    radius: deprecated_popoverRadius,
    scheme: deprecated_popoverScheme,
    ...(popover || {})
  }), [deprecated_boundaryElement, deprecated_placement, deprecated_popoverRadius, deprecated_popoverScheme, deprecated_portal, deprecated_preventOverflow, popover]);
  return /* @__PURE__ */jsx(Popover, {
    "data-ui": "MenuButton__popover",
    ...popoverProps,
    content: menu,
    open,
    children: button || /* @__PURE__ */jsx(Fragment, {})
  });
});
const MenuDivider = styled.hr(_templateObject76 || (_templateObject76 = _taggedTemplateLiteral(["\n  height: 1px;\n  border: 0;\n  background: var(--card-hairline-soft-color);\n  margin: 0;\n"])));
function selectableBaseStyle() {
  return css(_templateObject77 || (_templateObject77 = _taggedTemplateLiteral(["\n    background-color: inherit;\n    color: inherit;\n\n    &[data-as='button'] {\n      -webkit-font-smoothing: inherit;\n      appearance: none;\n      outline: none;\n      font: inherit;\n      text-align: inherit;\n      border: 0;\n      width: stretch;\n    }\n\n    /* &:is(a) */\n    &[data-as='a'] {\n      text-decoration: none;\n    }\n  "])));
}
function selectableColorStyle(props) {
  var _a, _b;
  const {
    $tone,
    theme
  } = props;
  const {
    base,
    muted,
    selectable
  } = theme.sanity.color;
  const tone = selectable ? selectable[$tone] || selectable.default : muted[$tone] || muted.default;
  return css(_templateObject78 || (_templateObject78 = _taggedTemplateLiteral(["\n    ", "\n\n    background-color: var(--card-bg-color);\n    color: var(--card-fg-color);\n    outline: none;\n\n    /* &:is(button) */\n    &[data-as='button'] {\n      &:disabled {\n        ", "\n      }\n\n      &:not(:disabled) {\n        &[aria-pressed='true'] {\n          ", "\n        }\n\n        &[data-selected],\n        &[aria-selected='true'] > & {\n          ", "\n        }\n\n        @media (hover: hover) {\n          &:not([data-selected]) {\n            &:hover {\n              ", "\n            }\n\n            &:active {\n              ", "\n            }\n          }\n        }\n      }\n    }\n\n    /* &:is(a) */\n    &[data-as='a'] {\n      &[data-disabled] {\n        ", "\n      }\n\n      &:not([data-disabled]) {\n        &[data-pressed] {\n          ", "\n        }\n\n        &[data-selected] {\n          ", "\n        }\n\n        @media (hover: hover) {\n          &:not([data-selected]) {\n            &:hover {\n              ", "\n            }\n\n            &:active {\n              ", "\n            }\n          }\n        }\n      }\n    }\n\n    ", "\n  "])), _colorVarsStyle(base, tone.enabled), _colorVarsStyle(base, tone.disabled), _colorVarsStyle(base, tone.pressed), _colorVarsStyle(base, tone.selected), _colorVarsStyle(base, tone.hovered), _colorVarsStyle(base, tone.pressed), _colorVarsStyle(base, tone.disabled), _colorVarsStyle(base, tone.pressed), _colorVarsStyle(base, tone.selected), _colorVarsStyle(base, tone.hovered), _colorVarsStyle(base, tone.pressed), (_b = (_a = theme.sanity.styles) == null ? void 0 : _a.card) == null ? void 0 : _b.root);
}
const Selectable = styled(Box)(responsiveRadiusStyle, selectableBaseStyle, selectableColorStyle);
function useMenu() {
  const value = useContext(MenuContext);
  if (!value) {
    throw new Error("useMenu(): missing context value");
  }
  if (!isRecord(value) || value.version !== 0) {
    throw new Error("useMenu(): the context value is not compatible");
  }
  return value;
}
function MenuGroup(props) {
  const {
    as = "button",
    children,
    fontSize,
    icon,
    onClick,
    padding = 3,
    popover,
    radius = 2,
    space = 3,
    text,
    tone = "default",
    ...restProps
  } = props;
  const menu = useMenu();
  const {
    activeElement,
    mount,
    onClickOutside,
    onEscape,
    onItemClick,
    onItemMouseEnter = menu.onMouseEnter,
    registerElement
  } = menu;
  const [rootElement, setRootElement] = useState(null);
  const [open, setOpen] = useState(false);
  const shouldFocusRef = useRef(null);
  const active = Boolean(activeElement) && activeElement === rootElement;
  const [withinMenu, setWithinMenu] = useState(false);
  const handleMouseEnter = useCallback(event => {
    setWithinMenu(false);
    onItemMouseEnter(event);
    setOpen(true);
  }, [onItemMouseEnter]);
  const handleMenuKeyDown = useCallback(event => {
    if (event.key === "ArrowLeft") {
      event.stopPropagation();
      setOpen(false);
      requestAnimationFrame(() => {
        rootElement == null ? void 0 : rootElement.focus();
      });
    }
  }, [rootElement]);
  const handleClick = useCallback(event => {
    if (onClick) onClick(event);
    shouldFocusRef.current = "first";
    setOpen(true);
    requestAnimationFrame(() => {
      shouldFocusRef.current = null;
    });
  }, [onClick]);
  const handleChildItemClick = useCallback(() => {
    setOpen(false);
    if (onItemClick) onItemClick();
  }, [onItemClick]);
  const handleMenuMouseEnter = useCallback(() => setWithinMenu(true), []);
  useEffect(() => mount(rootElement), [mount, rootElement]);
  useEffect(() => {
    if (!active) setOpen(false);
  }, [active]);
  useEffect(() => {
    if (!open) setWithinMenu(false);
  }, [open]);
  const childMenu = /* @__PURE__ */jsx(Menu, {
    onClickOutside,
    onEscape,
    onItemClick: handleChildItemClick,
    onKeyDown: handleMenuKeyDown,
    onMouseEnter: handleMenuMouseEnter,
    registerElement,
    shouldFocus: shouldFocusRef.current,
    children
  });
  const handleKeyDown = useCallback(event => {
    const target = event.currentTarget;
    if (document.activeElement !== target) {
      return;
    }
    if (event.key === "ArrowRight") {
      shouldFocusRef.current = "first";
      setOpen(true);
      setWithinMenu(true);
      requestAnimationFrame(() => {
        shouldFocusRef.current = null;
      });
      return;
    }
  }, []);
  return /* @__PURE__ */jsx(Popover, {
    ...popover,
    content: childMenu,
    "data-ui": "MenuGroup__popover",
    open,
    children: /* @__PURE__ */jsx(Selectable, {
      "data-as": as,
      "data-ui": "MenuGroup",
      forwardedAs: as,
      ...restProps,
      "aria-pressed": as === "button" ? withinMenu : void 0,
      "data-pressed": as !== "button" ? withinMenu : void 0,
      "data-selected": !withinMenu && active ? "" : void 0,
      $radius: useArrayProp(radius),
      $tone: tone,
      onClick: handleClick,
      onKeyDown: handleKeyDown,
      onMouseEnter: handleMouseEnter,
      ref: setRootElement,
      tabIndex: -1,
      type: as === "button" ? "button" : void 0,
      children: /* @__PURE__ */jsx(Box, {
        padding,
        children: /* @__PURE__ */jsxs(Flex, {
          children: [icon && /* @__PURE__ */jsxs(Text, {
            size: fontSize,
            children: [isValidElement(icon) && icon, isValidElementType(icon) && createElement(icon)]
          }), /* @__PURE__ */jsx(Box, {
            flex: 1,
            marginLeft: icon ? space : void 0,
            children: /* @__PURE__ */jsx(Text, {
              size: fontSize,
              textOverflow: "ellipsis",
              children: text
            })
          }), /* @__PURE__ */jsx(Box, {
            marginLeft: space,
            children: /* @__PURE__ */jsx(Text, {
              size: fontSize,
              children: /* @__PURE__ */jsx(ChevronRightIcon, {})
            })
          })]
        })
      })
    })
  });
}
const MenuItem = forwardRef(function MenuItem2(props, forwardedRef) {
  const {
    as = "button",
    children,
    disabled,
    fontSize = 2,
    hotkeys,
    icon,
    iconRight,
    onClick,
    padding = 3,
    paddingX,
    paddingY,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft,
    pressed,
    radius = 2,
    selected: selectedProp,
    space = 3,
    text,
    tone = "default",
    ...restProps
  } = props;
  const menu = useMenu();
  const {
    activeElement,
    mount,
    onItemClick,
    onItemMouseEnter = menu.onMouseEnter,
    onItemMouseLeave = menu.onMouseLeave
  } = menu;
  const [rootElement, setRootElement] = useState(null);
  const active = Boolean(activeElement) && activeElement === rootElement;
  useEffect(() => mount(rootElement, selectedProp), [mount, rootElement, selectedProp]);
  const ref = useForwardedRef(forwardedRef);
  const handleClick = useCallback(event => {
    if (disabled) return;
    if (onClick) onClick(event);
    if (onItemClick) onItemClick();
  }, [disabled, onClick, onItemClick]);
  const paddingProps = useMemo(() => ({
    padding,
    paddingX,
    paddingY,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft
  }), [padding, paddingX, paddingY, paddingTop, paddingRight, paddingBottom, paddingLeft]);
  const setRef = useCallback(el => {
    ref.current = el;
    setRootElement(el);
  }, [ref]);
  return /* @__PURE__ */jsxs(Selectable, {
    "data-ui": "MenuItem",
    ...restProps,
    "aria-pressed": as === "button" && pressed,
    "data-pressed": as !== "button" && pressed ? "" : void 0,
    "data-selected": active ? "" : void 0,
    "data-disabled": disabled ? "" : void 0,
    forwardedAs: as,
    $radius: useArrayProp(radius),
    $padding: useArrayProp(0),
    $tone: tone,
    disabled,
    onClick: handleClick,
    onMouseEnter: onItemMouseEnter,
    onMouseLeave: onItemMouseLeave,
    ref: setRef,
    role: "menuitem",
    tabIndex: -1,
    type: as === "button" ? "button" : void 0,
    children: [(icon || text || iconRight) && /* @__PURE__ */jsx(Box, {
      as: "span",
      ...paddingProps,
      children: /* @__PURE__ */jsxs(Flex, {
        as: "span",
        children: [icon && /* @__PURE__ */jsxs(Text, {
          size: fontSize,
          children: [isValidElement(icon) && icon, isValidElementType(icon) && createElement(icon)]
        }), text && /* @__PURE__ */jsx(Box, {
          flex: 1,
          marginLeft: icon ? space : void 0,
          marginRight: iconRight ? space : void 0,
          children: /* @__PURE__ */jsx(Text, {
            size: fontSize,
            textOverflow: "ellipsis",
            children: text
          })
        }), hotkeys && /* @__PURE__ */jsx(Box, {
          marginLeft: space,
          style: {
            marginTop: -4,
            marginBottom: -4
          },
          children: /* @__PURE__ */jsx(Hotkeys, {
            fontSize,
            keys: hotkeys
          })
        }), iconRight && /* @__PURE__ */jsxs(Text, {
          size: fontSize,
          children: [isValidElement(iconRight) && iconRight, isValidElementType(iconRight) && createElement(iconRight)]
        })]
      })
    }), children && /* @__PURE__ */jsx(Box, {
      as: "span",
      ...paddingProps,
      children
    })]
  });
});
const keyframe = keyframes(_templateObject79 || (_templateObject79 = _taggedTemplateLiteral(["\n  0% {\n    background-position: 100%;\n  }\n  100% {\n    background-position: -100%;\n  }\n"])));
const animation = css(_templateObject80 || (_templateObject80 = _taggedTemplateLiteral(["\n  background-image: linear-gradient(\n    to right,\n    var(--card-skeleton-color-from),\n    var(--card-skeleton-color-to),\n    var(--card-skeleton-color-from),\n    var(--card-skeleton-color-from),\n    var(--card-skeleton-color-from)\n  );\n  background-position: 100%;\n  background-size: 200% 100%;\n  background-attachment: fixed;\n  animation-name: ", ";\n  animation-timing-function: ease-in-out;\n  animation-iteration-count: infinite;\n  animation-duration: 2000ms;\n"])), keyframe);
const skeletonStyle = css(_templateObject81 || (_templateObject81 = _taggedTemplateLiteral(["\n  opacity: ", ";\n  transition: opacity 200ms ease-in;\n\n  @media screen and (prefers-reduced-motion: no-preference) {\n    ", "\n  }\n\n  @media screen and (prefers-reduced-motion: reduce) {\n    background-color: var(--card-skeleton-color-from);\n  }\n"])), _ref24 => {
  let {
    $visible
  } = _ref24;
  return $visible ? 1 : 0;
}, _ref25 => {
  let {
    $animated
  } = _ref25;
  return $animated ? animation : css(_templateObject82 || (_templateObject82 = _taggedTemplateLiteral(["\n            background-color: var(--card-skeleton-color-from);\n          "])));
});
const Root$4 = styled(Box)(responsiveRadiusStyle, skeletonStyle);
const Skeleton = forwardRef(function Skeleton2(props, ref) {
  const {
    animated = false,
    delay,
    radius,
    ...restProps
  } = props;
  const [visible, setVisible] = useState(delay ? false : true);
  useEffect(() => {
    if (!delay) {
      return setVisible(true);
    }
    const timeout = setTimeout(() => {
      setVisible(true);
    }, delay);
    return () => {
      clearTimeout(timeout);
    };
  }, [delay]);
  return /* @__PURE__ */jsx(Root$4, {
    ...restProps,
    $animated: animated,
    $radius: useArrayProp(radius),
    $visible: visible,
    ref
  });
});
const Root$3 = styled(Skeleton)(_ref26 => {
  let {
    $size,
    $style,
    theme
  } = _ref26;
  const {
    media
  } = theme.sanity;
  const font = theme.sanity.fonts[$style];
  const styles = _responsive(media, $size, sizeIndex => {
    const fontSize = font.sizes[sizeIndex];
    const capHeight = fontSize.lineHeight - fontSize.ascenderHeight - fontSize.descenderHeight;
    return {
      height: capHeight
    };
  });
  return styles;
});
const TextSkeleton = forwardRef(function TextSkeleton2(props, ref) {
  const {
    size = 2,
    ...restProps
  } = props;
  const $size = useArrayProp(size);
  return /* @__PURE__ */jsx(Root$3, {
    ...restProps,
    $size,
    ref,
    $style: "text"
  });
});
const LabelSkeleton = forwardRef(function TextSkeleton3(props, ref) {
  const {
    size = 2,
    ...restProps
  } = props;
  const $size = useArrayProp(size);
  return /* @__PURE__ */jsx(Root$3, {
    ...restProps,
    $size,
    ref,
    $style: "label"
  });
});
const HeadingSkeleton = forwardRef(function TextSkeleton4(props, ref) {
  const {
    size = 2,
    ...restProps
  } = props;
  const $size = useArrayProp(size);
  return /* @__PURE__ */jsx(Root$3, {
    ...restProps,
    $size,
    ref,
    $style: "heading"
  });
});
const CodeSkeleton = forwardRef(function TextSkeleton5(props, ref) {
  const {
    size = 2,
    ...restProps
  } = props;
  const $size = useArrayProp(size);
  return /* @__PURE__ */jsx(Root$3, {
    ...restProps,
    $size,
    ref,
    $style: "code"
  });
});
const Tab = forwardRef(function Tab2(props, forwardedRef) {
  const {
    icon,
    id,
    focused,
    fontSize,
    label,
    onClick,
    onFocus,
    padding = 2,
    selected,
    ...restProps
  } = props;
  const elementRef = useRef(null);
  const focusedRef = useRef(false);
  const handleBlur = useCallback(() => {
    focusedRef.current = false;
  }, []);
  const handleFocus = useCallback(event => {
    focusedRef.current = true;
    if (onFocus) onFocus(event);
  }, [onFocus]);
  const ref = useForwardedRef(forwardedRef);
  useEffect(() => {
    if (focused && !focusedRef.current) {
      if (elementRef.current) elementRef.current.focus();
      focusedRef.current = true;
    }
  }, [focused]);
  const setRef = el => {
    elementRef.current = el;
    ref.current = el;
  };
  return /* @__PURE__ */jsx(Button, {
    "data-ui": "Tab",
    ...restProps,
    "aria-selected": selected ? "true" : "false",
    fontSize,
    icon,
    id,
    mode: "bleed",
    onClick,
    onBlur: handleBlur,
    onFocus: handleFocus,
    padding,
    ref: setRef,
    role: "tab",
    selected,
    tabIndex: selected ? 0 : -1,
    text: label,
    type: "button"
  });
});
function _isReactElement(node) {
  return Boolean(node);
}
const TabList = forwardRef(function TabList2(props, ref) {
  const {
    children: childrenProp,
    ...restProps
  } = props;
  const [focusedIndex, setFocusedIndex] = useState(-1);
  const children = useMemo(() => childrenProp.filter(_isReactElement), [childrenProp]);
  const tabs = children.map((child, childIndex) => cloneElement(child, {
    focused: focusedIndex === childIndex,
    key: childIndex,
    onFocus: () => handleTabFocus(childIndex)
  }));
  const numTabs = tabs.length;
  const handleTabFocus = useCallback(tabIdx => {
    setFocusedIndex(tabIdx);
  }, []);
  const handleKeyDown = useCallback(event => {
    if (event.key === "ArrowLeft") {
      setFocusedIndex(prevIndex => (prevIndex + numTabs - 1) % numTabs);
    }
    if (event.key === "ArrowRight") {
      setFocusedIndex(prevIndex => (prevIndex + 1) % numTabs);
    }
  }, [numTabs]);
  return /* @__PURE__ */jsx(Inline, {
    "data-ui": "TabList",
    ...restProps,
    onKeyDown: handleKeyDown,
    ref,
    role: "tablist",
    children: tabs
  });
});
const TabPanel = forwardRef(function TabPanel2(props, ref) {
  const {
    flex,
    ...restProps
  } = props;
  return /* @__PURE__ */jsx(Box, {
    "data-ui": "TabPanel",
    ...restProps,
    flex,
    ref,
    role: "tabpanel",
    tabIndex: props.tabIndex === void 0 ? 0 : props.tabIndex,
    children: props.children
  });
});
const STATUS_CARD_TONE = {
  error: "critical",
  warning: "caution",
  success: "positive",
  info: "primary"
};
const ROLES = {
  error: "alert",
  warning: "alert",
  success: "alert",
  info: "alert"
};
const Root$2 = styled(Card)(_templateObject83 || (_templateObject83 = _taggedTemplateLiteral(["\n  pointer-events: all;\n"])));
const TextBox = styled(Flex)(_templateObject84 || (_templateObject84 = _taggedTemplateLiteral(["\n  overflow-x: auto;\n"])));
function Toast(props) {
  const {
    closable,
    description,
    onClose,
    title,
    status,
    ...restProps
  } = props;
  const cardTone = status ? STATUS_CARD_TONE[status] : "default";
  const role = status ? ROLES[status] : "status";
  return /* @__PURE__ */jsx(Root$2, {
    "data-ui": "Toast",
    role,
    ...restProps,
    marginTop: 3,
    radius: 2,
    shadow: 2,
    tone: cardTone,
    children: /* @__PURE__ */jsxs(Flex, {
      align: "flex-start",
      children: [/* @__PURE__ */jsx(TextBox, {
        flex: 1,
        padding: 3,
        children: /* @__PURE__ */jsxs(Stack, {
          space: 3,
          children: [title && /* @__PURE__ */jsx(Text, {
            weight: "semibold",
            children: title
          }), description && /* @__PURE__ */jsx(Text, {
            muted: true,
            size: 1,
            children: description
          })]
        })
      }), closable && /* @__PURE__ */jsx(Box, {
        padding: 1,
        children: /* @__PURE__ */jsx(Button, {
          as: "button",
          icon: CloseIcon,
          mode: "bleed",
          padding: 2,
          onClick: onClose,
          style: {
            verticalAlign: "top"
          }
        })
      })]
    })
  });
}
function useMounted() {
  const [mounted, mount] = useReducer(() => true, false);
  useEffect(mount, [mount]);
  return mounted;
}
const key$1 = Symbol.for("@sanity/ui/context/toast");
globalScope[key$1] = globalScope[key$1] || createContext(null);
const ToastContext = globalScope[key$1];
const Root$1 = styled(Layer)(_templateObject85 || (_templateObject85 = _taggedTemplateLiteral(["\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  pointer-events: none;\n"])));
const ToastContainer = styled.div(_templateObject86 || (_templateObject86 = _taggedTemplateLiteral(["\n  box-sizing: border-box;\n  position: absolute;\n  right: 0;\n  bottom: 0;\n  max-width: 420px;\n  width: 100%;\n"])));
let toastId = 0;
function ToastProvider(props) {
  const {
    children,
    padding = 4,
    paddingX,
    paddingY,
    zOffset
  } = props;
  const [state, _setState] = useState([]);
  const toastsRef = useRef({});
  const push = useCallback(params => {
    const setState = state2 => startTransition(() => _setState(state2));
    const id = params.id || String(toastId++);
    const duration = params.duration || 5e3;
    const dismiss = () => {
      var _a;
      const timeoutId = (_a = toastsRef.current[id]) == null ? void 0 : _a.timeoutId;
      setState(prevState => {
        const idx = prevState.findIndex(t => t.id === id);
        if (idx > -1) {
          const toasts = prevState.slice(0);
          toasts.splice(idx, 1);
          return toasts;
        }
        return prevState;
      });
      if (timeoutId !== void 0) {
        clearTimeout(timeoutId);
        delete toastsRef.current[id];
      }
    };
    setState(prevState => {
      return prevState.filter(t => t.id !== id).concat([{
        dismiss,
        id,
        params: {
          ...params,
          duration
        }
      }]);
    });
    if (toastsRef.current[id]) {
      clearTimeout(toastsRef.current[id].timeoutId);
      delete toastsRef.current[id];
    }
    toastsRef.current[id] = {
      timeoutId: setTimeout(dismiss, duration)
    };
    return id;
  }, []);
  useEffect(() => () => {
    for (const {
      timeoutId
    } of Object.values(toastsRef.current)) {
      clearTimeout(timeoutId);
    }
    toastsRef.current = {};
  }, []);
  const value = useMemo(() => ({
    version: 0,
    push
  }), [push]);
  const mounted = useMounted();
  return /* @__PURE__ */jsxs(ToastContext.Provider, {
    value,
    children: [children, mounted && /* @__PURE__ */jsx(Root$1, {
      "data-ui": "ToastProvider",
      zOffset,
      children: /* @__PURE__ */jsx(ToastContainer, {
        children: /* @__PURE__ */jsx(Box, {
          padding,
          paddingX,
          paddingY,
          children: /* @__PURE__ */jsx(AnimatePresence, {
            initial: false,
            children: state.map(_ref27 => {
              let {
                dismiss,
                id,
                params
              } = _ref27;
              return /* @__PURE__ */jsx(motion.div, {
                animate: {
                  opacity: 1,
                  y: 0,
                  scale: 1
                },
                exit: {
                  opacity: 0,
                  scale: 0.5,
                  transition: {
                    duration: 0.2
                  }
                },
                initial: {
                  opacity: 0,
                  y: 32,
                  scale: 0.25
                },
                layout: "position",
                transition: {
                  type: "spring",
                  damping: 30,
                  stiffness: 400
                },
                children: /* @__PURE__ */jsx(Toast, {
                  closable: params.closable,
                  description: params.description,
                  onClose: dismiss,
                  status: params.status,
                  title: params.title
                })
              }, id);
            })
          })
        })
      })
    })]
  });
}
function useToast() {
  const value = useContext(ToastContext);
  if (!value) {
    throw new Error("useToast(): missing context value");
  }
  if (!isRecord(value) || value.version !== 0) {
    throw new Error("useToast(): the context value is not compatible");
  }
  return value;
}
function _findPrevItemElement(state, itemElements, focusedElement) {
  var _a;
  const idx = itemElements.indexOf(focusedElement);
  const els = itemElements.slice(0, idx);
  const len = els.length;
  for (let i = len - 1; i >= 0; i -= 1) {
    const itemKey = els[i].getAttribute("data-tree-key");
    if (!itemKey) {
      continue;
    }
    const segments = itemKey.split("/");
    segments.pop();
    const p = [];
    let expanded = true;
    for (let j = 0; j < segments.length; j += 1) {
      p.push(segments[j]);
      const k = p.join("/");
      if (!((_a = state[k]) == null ? void 0 : _a.expanded)) {
        expanded = false;
        break;
      }
    }
    if (expanded) {
      return els[i];
    }
  }
  return null;
}
function _findNextItemElement(state, itemElements, focusedElement) {
  var _a;
  const idx = itemElements.indexOf(focusedElement);
  const els = itemElements.slice(idx);
  const len = itemElements.length;
  for (let i = 1; i < len; i += 1) {
    if (!els[i]) {
      continue;
    }
    const itemKey = els[i].getAttribute("data-tree-key");
    if (!itemKey) {
      continue;
    }
    const segments = itemKey.split("/");
    segments.pop();
    const p = [];
    let expanded = true;
    for (let j = 0; j < segments.length; j += 1) {
      p.push(segments[j]);
      const k = p.join("/");
      if (!((_a = state[k]) == null ? void 0 : _a.expanded)) {
        expanded = false;
        break;
      }
    }
    if (expanded) {
      return els[i];
    }
  }
  return null;
}
function _focusItemElement(el) {
  if (el.getAttribute("role") === "treeitem") {
    el.focus();
  }
  if (el.getAttribute("role") === "none") {
    const firstChild = el.firstChild;
    if (firstChild && firstChild instanceof HTMLElement) {
      firstChild.focus();
    }
  }
}
const key = Symbol.for("@sanity/ui/context/tree");
globalScope[key] = globalScope[key] || createContext(null);
const TreeContext = globalScope[key];
const Tree = memo(forwardRef(function Tree2(props, ref) {
  const {
    children,
    space = 1,
    ...restProps
  } = props;
  const forwardedRef = useForwardedRef(ref);
  const [focusedElement, setFocusedElement] = useState(null);
  const focusedElementRef = useRef(focusedElement);
  const path = useMemo(() => [], []);
  const [itemElements, setItemElements] = useState([]);
  const [state, setState] = useState({});
  const stateRef = useRef(state);
  useEffect(() => {
    focusedElementRef.current = focusedElement;
  }, [focusedElement]);
  useEffect(() => {
    stateRef.current = state;
  }, [state]);
  const registerItem = useCallback((element, path2, expanded, selected) => {
    setState(s => ({
      ...s,
      [path2]: {
        element,
        expanded
      }
    }));
    if (selected) {
      setFocusedElement(element);
    }
    return () => {
      setState(s => {
        const newState = {
          ...s
        };
        delete newState[path2];
        return newState;
      });
    };
  }, []);
  const setExpanded = useCallback((path2, expanded) => {
    setState(s => {
      const itemState = s[path2];
      if (!itemState) return s;
      return {
        ...s,
        [path2]: {
          ...itemState,
          expanded
        }
      };
    });
  }, []);
  const contextValue = useMemo(() => ({
    version: 0,
    focusedElement: focusedElement || itemElements[0] || null,
    level: 0,
    path,
    registerItem,
    setExpanded,
    setFocusedElement,
    space,
    state
  }), [focusedElement, itemElements, path, registerItem, setExpanded, space, state]);
  const handleKeyDown = useCallback(event => {
    var _a;
    if (!focusedElementRef.current) return;
    if (event.key === "ArrowDown") {
      event.preventDefault();
      const nextEl = _findNextItemElement(stateRef.current, itemElements, focusedElementRef.current);
      if (nextEl) {
        _focusItemElement(nextEl);
        setFocusedElement(nextEl);
      }
      return;
    }
    if (event.key === "ArrowUp") {
      event.preventDefault();
      const prevEl = _findPrevItemElement(stateRef.current, itemElements, focusedElementRef.current);
      if (prevEl) {
        _focusItemElement(prevEl);
        setFocusedElement(prevEl);
      }
      return;
    }
    if (event.key === "ArrowLeft") {
      event.preventDefault();
      const itemKey = focusedElementRef.current.getAttribute("data-tree-key");
      if (!itemKey) return;
      const itemState = stateRef.current[itemKey];
      if (!itemState) return;
      if (itemState.expanded) {
        setState(s => {
          const itemState2 = s[itemKey];
          if (!itemState2) return s;
          return {
            ...s,
            [itemKey]: {
              ...itemState2,
              expanded: false
            }
          };
        });
      } else {
        const itemPath = itemKey.split("/");
        itemPath.pop();
        const parentKey = itemPath.join("/");
        const parentState = parentKey && stateRef.current[parentKey];
        if (parentState) {
          parentState.element.focus();
          setFocusedElement(parentState.element);
        }
      }
      return;
    }
    if (event.key === "ArrowRight") {
      event.preventDefault();
      const focusedKey = focusedElementRef.current.getAttribute("data-tree-key");
      if (!focusedKey) return;
      if (!((_a = stateRef.current[focusedKey]) == null ? void 0 : _a.expanded)) {
        setState(s => {
          const itemState = s[focusedKey];
          if (!itemState) return s;
          return {
            ...s,
            [focusedKey]: {
              ...itemState,
              expanded: true
            }
          };
        });
      }
      return;
    }
  }, [itemElements]);
  useEffect(() => {
    if (!forwardedRef.current) return;
    const _itemElements = Array.from(forwardedRef.current.querySelectorAll('[data-ui="TreeItem"]'));
    setItemElements(_itemElements);
  }, [children, forwardedRef]);
  return /* @__PURE__ */jsx(TreeContext.Provider, {
    value: contextValue,
    children: /* @__PURE__ */jsx(Stack, {
      as: "ul",
      "data-ui": "Tree",
      ...restProps,
      onKeyDown: handleKeyDown,
      ref: forwardedRef,
      role: "tree",
      space,
      children
    })
  });
}));
Tree.displayName = "Tree";
function treeItemRootStyle() {
  return css(_templateObject87 || (_templateObject87 = _taggedTemplateLiteral(["\n    &[role='none'] > [role='treeitem'] {\n      outline: none;\n      cursor: default;\n      border-radius: 3px;\n\n      &:focus {\n        position: relative;\n      }\n    }\n\n    &[role='treeitem'] {\n      outline: none;\n\n      & > div {\n        cursor: default;\n        border-radius: 3px;\n      }\n\n      &:focus > div {\n        position: relative;\n      }\n    }\n  "])));
}
function treeItemRootColorStyle(props) {
  const {
    theme
  } = props;
  const $tone = "default";
  const {
    base,
    muted,
    selectable
  } = theme.sanity.color;
  const tone = selectable ? selectable[$tone] || selectable.default : muted[$tone] || muted.default;
  return css(_templateObject88 || (_templateObject88 = _taggedTemplateLiteral(["\n    /* <div role=\"none\"><a data-ui=\"TreeItem__box\" role=\"treeitem\" tabIndex=\"0\"></div> */\n    &[role='none'] {\n      & > [role='treeitem'] {\n        ", "\n\n        background-color: var(--card-bg-color);\n        color: var(--treeitem-fg-color);\n      }\n\n      &[data-selected] > [role='treeitem'] {\n        ", "\n      }\n\n      @media (hover: hover) {\n        &:not([data-selected]) > [role='treeitem']:not(:focus):hover {\n          ", "\n        }\n\n        & > [role='treeitem']:focus {\n          ", "\n        }\n      }\n    }\n\n    /* <div role=\"treeitem\" tabIndex=\"0\"><div data-ui=\"TreeItem__box\"></div> */\n    &[role='treeitem'] {\n      & > [data-ui='TreeItem__box'] {\n        ", "\n\n        background-color: var(--card-bg-color);\n        color: var(--card-fg-color);\n      }\n\n      &[data-selected] > [data-ui='TreeItem__box'] {\n        ", "\n      }\n\n      @media (hover: hover) {\n        &:not([data-selected]):not(:focus) > [data-ui='TreeItem__box']:hover {\n          ", "\n        }\n\n        &:focus > [data-ui='TreeItem__box'] {\n          ", "\n        }\n      }\n    }\n  "])), _colorVarsStyle(base, tone.enabled), _colorVarsStyle(base, tone.pressed), _colorVarsStyle(base, tone.hovered), _colorVarsStyle(base, tone.selected), _colorVarsStyle(base, tone.enabled), _colorVarsStyle(base, tone.pressed), _colorVarsStyle(base, tone.hovered), _colorVarsStyle(base, tone.selected));
}
function treeItemBoxStyle(props) {
  const {
    $level,
    theme
  } = props;
  const {
    space
  } = theme.sanity;
  return css(_templateObject89 || (_templateObject89 = _taggedTemplateLiteral(["\n    padding-left: ", ";\n\n    &[data-as='a'] {\n      text-decoration: none;\n    }\n  "])), rem(space[2] * $level));
}
function useTree() {
  const tree = useContext(TreeContext);
  if (!tree) {
    throw new Error("Tree: missing context value");
  }
  return tree;
}
const TreeGroup = memo(function TreeGroup2(props) {
  const {
    children,
    expanded = false,
    ...restProps
  } = props;
  const tree = useTree();
  return /* @__PURE__ */jsx(Stack, {
    as: "ul",
    "data-ui": "TreeGroup",
    ...restProps,
    hidden: !expanded,
    marginTop: tree.space,
    role: "group",
    space: tree.space,
    children
  });
});
const Root = memo(styled.li(treeItemRootStyle, treeItemRootColorStyle));
const TreeItemBox = styled(Box).attrs({
  forwardedAs: "a"
})(treeItemBoxStyle);
const ToggleArrowText = styled(Text)(_templateObject90 || (_templateObject90 = _taggedTemplateLiteral(["\n  & > svg {\n    transition: transform 100ms;\n  }\n"])));
const TreeItem = memo(function TreeItem2(props) {
  const {
    children,
    expanded: expandedProp = false,
    fontSize,
    href,
    icon,
    id: idProp,
    muted,
    onClick,
    padding = 3,
    selected = false,
    space = 2,
    text,
    weight,
    ...restProps
  } = props;
  const rootRef = useRef(null);
  const treeitemRef = useRef(null);
  const tree = useTree();
  const {
    path,
    registerItem,
    setExpanded,
    setFocusedElement
  } = tree;
  const _id = useId();
  const id = idProp || _id;
  const itemPath = useMemo(() => path.concat([id || ""]), [id, path]);
  const itemKey = itemPath.join("/");
  const itemState = tree.state[itemKey];
  const focused = tree.focusedElement === rootRef.current;
  const expanded = (itemState == null ? void 0 : itemState.expanded) === void 0 ? expandedProp : (itemState == null ? void 0 : itemState.expanded) || false;
  const tabIndex = tree.focusedElement && tree.focusedElement === rootRef.current ? 0 : -1;
  const contextValue = useMemo(() => ({
    ...tree,
    level: tree.level + 1,
    path: itemPath
  }), [itemPath, tree]);
  const handleClick = useCallback(event => {
    if (onClick) onClick(event);
    const target = event.target;
    if (target instanceof HTMLElement && (target.getAttribute("data-ui") === "TreeItem__box" || target.closest('[data-ui="TreeItem__box"]'))) {
      event.stopPropagation();
      setExpanded(itemKey, !expanded);
      setFocusedElement(rootRef.current);
    }
  }, [expanded, itemKey, onClick, setExpanded, setFocusedElement]);
  const handleKeyDown = useCallback(event => {
    if (focused && event.key === "Enter") {
      const el = treeitemRef.current || rootRef.current;
      el == null ? void 0 : el.click();
    }
  }, [focused]);
  useEffect(() => {
    if (!rootRef.current) return;
    return registerItem(rootRef.current, itemPath.join("/"), expanded, selected);
  }, [expanded, itemPath, registerItem, selected]);
  const content = /* @__PURE__ */jsxs(Flex, {
    padding,
    children: [/* @__PURE__ */jsxs(Box, {
      marginRight: space,
      style: {
        visibility: icon || children ? "visible" : "hidden",
        pointerEvents: "none"
      },
      children: [icon && /* @__PURE__ */jsx(Text, {
        muted,
        size: fontSize,
        weight,
        children: createElement(icon)
      }), !icon && /* @__PURE__ */jsx(ToggleArrowText, {
        muted,
        size: fontSize,
        weight,
        children: /* @__PURE__ */jsx(ToggleArrowRightIcon, {
          style: {
            transform: expanded ? "rotate(90deg)" : void 0
          }
        })
      })]
    }), /* @__PURE__ */jsx(Box, {
      flex: 1,
      children: /* @__PURE__ */jsx(Text, {
        muted,
        size: fontSize,
        textOverflow: "ellipsis",
        weight,
        children: text
      })
    })]
  });
  if (href) {
    return /* @__PURE__ */jsxs(Root, {
      "data-selected": selected ? "" : void 0,
      "data-tree-id": id,
      "data-tree-key": itemKey,
      "data-ui": "TreeItem",
      ...restProps,
      onClick: handleClick,
      ref: rootRef,
      role: "none",
      children: [/* @__PURE__ */jsx(TreeItemBox, {
        $level: tree.level,
        "aria-expanded": expanded,
        "data-ui": "TreeItem__box",
        href,
        ref: treeitemRef,
        role: "treeitem",
        tabIndex,
        children: content
      }), /* @__PURE__ */jsx(TreeContext.Provider, {
        value: contextValue,
        children: children && /* @__PURE__ */jsx(TreeGroup, {
          hidden: !expanded,
          children
        })
      })]
    });
  }
  return /* @__PURE__ */jsxs(Root, {
    "data-selected": selected ? "" : void 0,
    "data-ui": "TreeItem",
    "data-tree-id": id,
    "data-tree-key": itemKey,
    ...restProps,
    "aria-expanded": expanded,
    onClick: handleClick,
    onKeyDown: handleKeyDown,
    ref: rootRef,
    role: "treeitem",
    tabIndex,
    children: [/* @__PURE__ */jsx(TreeItemBox, {
      $level: tree.level,
      as: "div",
      "data-ui": "TreeItem__box",
      children: content
    }), /* @__PURE__ */jsx(TreeContext.Provider, {
      value: contextValue,
      children: children && /* @__PURE__ */jsx(TreeGroup, {
        expanded,
        children
      })
    })]
  });
});
export { Autocomplete, Avatar, AvatarCounter, AvatarStack, Badge, BoundaryElementProvider, Box, Breadcrumbs, Button, Card, Checkbox, Code, CodeSkeleton, Container, Dialog, DialogContext, DialogProvider, ElementQuery, ErrorBoundary, Flex, Grid, Heading, HeadingSkeleton, Hotkeys, Inline, KBD, Label, LabelSkeleton, Layer, LayerProvider, Menu, MenuButton, MenuDivider, MenuGroup, MenuItem, Popover, Portal, PortalProvider, Radio, Select, Skeleton, Spinner, SrOnly, Stack, Switch, Tab, TabList, TabPanel, Text, TextArea, TextInput, TextSkeleton, ThemeColorProvider, ThemeProvider, Toast, ToastProvider, Tooltip, Tree, TreeItem, VirtualList, _ResizeObserver, _elementSizeObserver, _fillCSSObject, _getArrayProp, _getResponsiveSpace, _hasFocus, _isEnterToClickElement, _isScrollable, _raf, _raf2, _responsive, attemptFocus, createColorTheme, focusFirstDescendant, focusLastDescendant, hexToRgb, hslToRgb, isFocusable, isHTMLAnchorElement, isHTMLButtonElement, isHTMLElement, isHTMLInputElement, isHTMLSelectElement, isHTMLTextAreaElement, multiply$1 as multiply, parseColor, rem, responsiveCodeFontStyle, responsiveHeadingFont, responsiveLabelFont, responsiveTextAlignStyle, responsiveTextFont, rgbToHex, rgbToHsl, rgba, screen$1 as screen, studioTheme, useArrayProp, useBoundaryElement, useClickOutside, useCustomValidity, useDialog, useElementRect, useElementSize, useForwardedRef, useGlobalKeyDown, useLayer, useMediaIndex, usePortal, usePrefersDark, useRootTheme, useTheme, useToast, useTree };
//# sourceMappingURL=index.esm.js.map

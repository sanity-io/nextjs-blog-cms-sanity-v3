"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setLocation = exports.reportLocations = exports.globalPresence$ = exports.documentPresenceUsers = exports.documentPresence = exports.debugPresenceParam$ = exports.SESSION_ID = void 0;
var _uniqBy2 = _interopRequireDefault(require("lodash/uniqBy"));
var _uniq2 = _interopRequireDefault(require("lodash/uniq"));
var _omit2 = _interopRequireDefault(require("lodash/omit"));
var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));
var _groupBy2 = _interopRequireDefault(require("lodash/groupBy"));
var _flatten2 = _interopRequireDefault(require("lodash/flatten"));
var _rxjs = require("rxjs");
var _operators = require("rxjs/operators");
var _nanoid = require("nanoid");
var _user = _interopRequireDefault(require("../user"));
var _bifur = require("../../client/bifur");
var _connectionStatusStore = require("../connection-status/connection-status-store");
var _debugParams = require("../debugParams");
var _mockEvents = require("./mock-events");
var _bifurTransport = require("./message-transports/bifurTransport");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
var KEY = 'presence_session_id';
var generate = () => (0, _nanoid.nanoid)(16);

// We're keeping the session id in sessionStorage as it will survive page reloads.
// todo:
//  There's a potential issue with window.open(...) here as it inherits the top level session storage and thus will
//  re-use session ids:
//    > Opening a page in a new tab or window creates a new session with the value of the top-level browsing context,
//      which differs from how session cookies work.
//      More at https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage
//  This is _probably_ a quite marginal case and not going to be much of a issue in practice
function getSessionId() {
  try {
    return window.sessionStorage.getItem(KEY);
  } catch (err) {
    // We don't want to fail hard if session storage can't be accessed for some reason
  }
  return null;
}
function setSessionId(id) {
  try {
    window.sessionStorage.setItem(KEY, id);
  } catch (err) {
    // We don't want to fail hard if session storage can't be accessed for some reason
  }
  return id;
}
var SESSION_ID = getSessionId() || setSessionId(generate());
exports.SESSION_ID = SESSION_ID;
var _createBifurTransport = (0, _bifurTransport.createBifurTransport)(_bifur.getBifur, SESSION_ID),
  _createBifurTransport2 = _slicedToArray(_createBifurTransport, 2),
  presenceEvents$ = _createBifurTransport2[0],
  sendMessage = _createBifurTransport2[1];
var currentLocation$ = new _rxjs.BehaviorSubject([]);
var locationChange$ = currentLocation$.pipe((0, _operators.distinctUntilChanged)());
var setLocation = nextLocation => {
  currentLocation$.next(nextLocation);
};
exports.setLocation = setLocation;
var reportLocations = locations => sendMessage({
  type: 'state',
  locations: locations
});
exports.reportLocations = reportLocations;
var requestRollCall = () => sendMessage({
  type: 'rollCall'
});
var rollCallRequests$ = presenceEvents$.pipe((0, _operators.filter)(event => event.type === 'rollCall'),
// do not respond to my own rollcall requests
(0, _operators.filter)(event => event.sessionId !== SESSION_ID));
var REPORT_MIN_INTERVAL = 30000;

// Interval to report my own location at
var reportLocationInterval$ = (0, _rxjs.timer)(0, REPORT_MIN_INTERVAL);
var reportLocation$ = (0, _rxjs.defer)(() => (0, _rxjs.merge)(locationChange$, rollCallRequests$)).pipe((0, _operators.switchMap)(() => reportLocationInterval$), (0, _operators.withLatestFrom)(currentLocation$), (0, _operators.map)(_ref => {
  var _ref2 = _slicedToArray(_ref, 2),
    locations = _ref2[1];
  return locations;
}), (0, _operators.auditTime)(200), (0, _operators.switchMap)(locations => reportLocations(locations)), (0, _operators.mergeMapTo)(_rxjs.EMPTY), (0, _operators.share)());

// This represents my rollcall request to other clients
// Note: We are requesting a rollcall whenever we (re)connect
var myRollCall$ = (0, _rxjs.defer)(() => requestRollCall()).pipe((0, _operators.mergeMapTo)(_rxjs.EMPTY));
var connectionChange$ = _connectionStatusStore.connectionStatus$.pipe((0, _operators.map)(status => status.type), (0, _operators.filter)(statusType => statusType === 'connected' || statusType === 'error'), (0, _operators.distinctUntilChanged)());
var debugPresenceParam$ = _debugParams.debugParams$.pipe((0, _operators.map)(args => args.find(arg => arg.startsWith('presence='))), (0, _operators.map)(arg => (arg === null || arg === void 0 ? void 0 : arg.split('presence=')[1].split(',').map(r => r.trim())) || []));
exports.debugPresenceParam$ = debugPresenceParam$;
var useMock$ = debugPresenceParam$.pipe((0, _operators.filter)(args => args.includes('fake_others')), (0, _operators.tap)(() => {
  // eslint-disable-next-line no-console
  console.log('Faking other users present in the studio. They will hang out in the document with _type: "presence" and _id: "presence-debug"');
}), (0, _operators.switchMapTo)(_mockEvents.mock$));
var debugIntrospect$ = debugPresenceParam$.pipe((0, _operators.map)(args => args.includes('show_own')));
var syncEvent$ = (0, _rxjs.merge)(myRollCall$, presenceEvents$).pipe((0, _operators.filter)(event => event.type === 'state' || event.type === 'disconnect'));
var stateEventToSession = stateEvent => {
  return {
    lastActiveAt: stateEvent.timestamp,
    locations: stateEvent.locations,
    sessionId: stateEvent.sessionId,
    userId: stateEvent.userId
  };
};
var states$ = (0, _rxjs.merge)(syncEvent$, useMock$).pipe((0, _operators.scan)((keyed, event) => event.type === 'disconnect' ? (0, _omit2.default)(keyed, event.sessionId) : _objectSpread(_objectSpread({}, keyed), {}, {
  [event.sessionId]: stateEventToSession(event)
}), {}));
var allSessions$ = connectionChange$.pipe((0, _operators.switchMap)(status => status === 'connected' ? (0, _rxjs.merge)(states$, reportLocation$) : _rxjs.NEVER), (0, _operators.map)(keyedSessions => Object.values(keyedSessions)), (0, _operators.switchMap)(sessions => {
  var userIds = (0, _uniq2.default)(sessions.map(sess => sess.userId));
  return (0, _rxjs.from)(_user.default.getUsers(userIds)).pipe((0, _operators.map)(users => sessions.map(session => ({
    // eslint-disable-next-line max-nested-callbacks
    user: users.find(res => res.id === session.userId),
    session: session
  }))
  // If we failed to find a user profile for a session, remove it
  .filter(userSessionPairHasUser)));
}), (0, _operators.takeUntil)((0, _rxjs.fromEvent)(window, 'beforeunload').pipe((0, _operators.switchMap)(() => sendMessage({
  type: 'disconnect'
})))), (0, _operators.shareReplay)({
  refCount: true,
  bufferSize: 1
}));
function userSessionPairHasUser(pair) {
  return Boolean(pair.user && pair.session);
}
var globalPresence$ = allSessions$.pipe((0, _operators.map)(sessions => {
  var grouped = (0, _groupBy2.default)(sessions.map(s => s.session), e => e.userId);
  return Object.keys(grouped).map(userId => {
    var _sessions$find;
    return {
      user: (_sessions$find = sessions.find(s => s.user.id === userId)) === null || _sessions$find === void 0 ? void 0 : _sessions$find.user,
      sessions: grouped[userId]
    };
  });
}), (0, _operators.withLatestFrom)(debugIntrospect$), (0, _operators.map)(_ref3 => {
  var _ref4 = _slicedToArray(_ref3, 2),
    userAndSessions = _ref4[0],
    debugIntrospect = _ref4[1];
  return userAndSessions.filter(userAndSession => {
    if (debugIntrospect) {
      return true;
    }
    var isCurrent = userAndSession.sessions.some(sess => sess.sessionId === SESSION_ID);
    return !isCurrent;
  });
}), (0, _operators.map)(userAndSessions => userAndSessions.map(userAndSession => {
  var _userAndSession$sessi;
  return {
    user: userAndSession.user,
    status: 'online',
    lastActiveAt: (_userAndSession$sessi = userAndSession.sessions.sort()[0]) === null || _userAndSession$sessi === void 0 ? void 0 : _userAndSession$sessi.lastActiveAt,
    locations: (0, _flatten2.default)((userAndSession.sessions || []).map(session => session.locations || [])).map(location => ({
      type: location.type,
      documentId: location.documentId,
      path: location.path,
      lastActiveAt: location.lastActiveAt
    })).reduce((prev, curr) => prev.concat(curr), [])
  };
}).sort((a, b) => a.user.id.localeCompare(b.user.id))));
exports.globalPresence$ = globalPresence$;
var documentPresence = documentId => {
  return allSessions$.pipe((0, _operators.withLatestFrom)(debugIntrospect$), (0, _operators.switchMap)(_ref5 => {
    var _ref6 = _slicedToArray(_ref5, 2),
      userAndSessions = _ref6[0],
      debugIntrospect = _ref6[1];
    return (0, _rxjs.from)(userAndSessions).pipe((0, _operators.filter)(userAndSession => debugIntrospect || userAndSession.session.sessionId !== SESSION_ID), (0, _operators.mergeMap)(userAndSession => (userAndSession.session.locations || []).filter(item => item.documentId === documentId).map(location => ({
      user: userAndSession.user,
      lastActiveAt: userAndSession.session.lastActiveAt,
      path: location.path || []
    }))), (0, _operators.toArray)());
  }));
};
exports.documentPresence = documentPresence;
var documentPresenceUsers = documentId => {
  return allSessions$.pipe((0, _operators.withLatestFrom)(debugIntrospect$), (0, _operators.map)(_ref7 => {
    var _ref8 = _slicedToArray(_ref7, 2),
      userAndSessions = _ref8[0],
      debugIntrospect = _ref8[1];
    var relevant = userAndSessions.filter(_ref9 => {
      var _session$locations;
      var session = _ref9.session;
      var includeUser = debugIntrospect || session.sessionId !== SESSION_ID;
      var isInDocument = (_session$locations = session.locations) === null || _session$locations === void 0 ? void 0 : _session$locations.some(location => location.documentId === documentId);
      return includeUser && isInDocument;
    });
    return (0, _uniqBy2.default)(relevant, _ref10 => {
      var user = _ref10.user;
      return user.id;
    }).map(_ref11 => {
      var user = _ref11.user;
      return user;
    }).sort((a, b) => a.id > b.id ? 1 : -1);
  }), (0, _operators.distinctUntilChanged)(_isEqual2.default));
};
exports.documentPresenceUsers = documentPresenceUsers;
import React, { createContext, useContext, useCallback, useRef, useMemo, useState, useEffect, useLayoutEffect, forwardRef } from 'react';
import { Subject, defer, of, EMPTY } from 'rxjs';
import { tap, concatMap, share, switchMap } from 'rxjs/operators';
import { randomKey } from '@sanity/util/content';
import { Element as Element$1, Text, Editor, Transforms, Range, Node, Path, Operation, createEditor } from 'slate';
import { isObject, uniq, flatten as flatten$1, isEqual, omitBy, isUndefined, get, findIndex, clone, omit, isString, debounce, throttle } from 'lodash';
import { ReactEditor, Slate, withReact, useSlateStatic, useSelected, Editable } from '@sanity/slate-react';
import Schema from '@sanity/schema';
import * as DMP from 'diff-match-patch';
import debug$i from 'debug';
import { isKeySegment } from '@sanity/types';
import styled from 'styled-components';
import isHotkey from 'is-hotkey';
import { htmlToBlocks, normalizeBlock } from '@sanity/block-tools';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", {
      value: raw
    });
  } else {
    cooked.raw = raw;
  }

  return cooked;
}

function compileType(rawType) {
    return Schema.compile({
        name: 'blockTypeSchema',
        types: [rawType],
    }).get(rawType.name);
}

function getPortableTextFeatures(portabletextType) {
    var _a, _b, _c;
    if (!portabletextType) {
        throw new Error("Parameter 'portabletextType' missing (required)");
    }
    var blockType = (_a = portabletextType.of) === null || _a === void 0 ? void 0 : _a.find(findBlockType);
    if (!blockType) {
        throw new Error('Block type is not defined in this schema (required)');
    }
    var childrenField = (_b = blockType.fields) === null || _b === void 0 ? void 0 : _b.find(function (field) { return field.name === 'children'; });
    if (!childrenField) {
        throw new Error('Children field for block type found in schema (required)');
    }
    var ofType = childrenField.type.of;
    if (!ofType) {
        throw new Error('Valid types for block children not found in schema (required)');
    }
    var spanType = ofType.find(function (memberType) { return memberType.name === 'span'; });
    if (!spanType) {
        throw new Error('Span type not found in schema (required)');
    }
    var inlineObjectTypes = (ofType.filter(function (memberType) { return memberType.name !== 'span'; }) ||
        []);
    var blockObjectTypes = (((_c = portabletextType.of) === null || _c === void 0 ? void 0 : _c.filter(function (field) { return field.name !== blockType.name; })) ||
        []);
    var annotations = resolveEnabledAnnotationTypes(spanType);
    return {
        styles: resolveEnabledStyles(blockType),
        decorators: resolveEnabledDecorators(spanType),
        lists: resolveEnabledListItems(blockType),
        annotations: annotations,
        types: {
            block: blockType,
            span: spanType,
            portableText: portabletextType,
            inlineObjects: inlineObjectTypes,
            blockObjects: blockObjectTypes,
            annotations: annotations.map(function (an) { return an.type; }),
        },
    };
}
function resolveEnabledStyles(blockType) {
    var _a, _b, _c;
    var styleField = (_a = blockType.fields) === null || _a === void 0 ? void 0 : _a.find(function (btField) { return btField.name === 'style'; });
    if (!styleField) {
        throw new Error("A field with name 'style' is not defined in the block type (required).");
    }
    var textStyles = ((_b = styleField.type.options) === null || _b === void 0 ? void 0 : _b.list) &&
        ((_c = styleField.type.options.list) === null || _c === void 0 ? void 0 : _c.filter(function (style) { return style.value; }));
    if (!textStyles || textStyles.length === 0) {
        throw new Error('The style fields need at least one style ' +
            "defined. I.e: {title: 'Normal', value: 'normal'}.");
    }
    return textStyles;
}
function resolveEnabledAnnotationTypes(spanType) {
    return spanType.annotations.map(function (annotation) {
        return {
            blockEditor: annotation.blockEditor,
            portableText: annotation.portableText,
            title: annotation.title,
            type: annotation,
            value: annotation.name,
            icon: annotation.icon,
        };
    });
}
function resolveEnabledDecorators(spanType) {
    return spanType.decorators;
}
function resolveEnabledListItems(blockType) {
    var _a, _b;
    var listField = (_a = blockType.fields) === null || _a === void 0 ? void 0 : _a.find(function (btField) { return btField.name === 'list'; });
    if (!listField) {
        throw new Error("A field with name 'list' is not defined in the block type (required).");
    }
    var listItems = ((_b = listField.type.options) === null || _b === void 0 ? void 0 : _b.list) &&
        listField.type.options.list.filter(function (list) { return list.value; });
    if (!listItems) {
        throw new Error('The list field need at least to be an empty array');
    }
    return listItems;
}
function findBlockType(type) {
    if (type.type) {
        return findBlockType(type.type);
    }
    if (type.name === 'block') {
        return type;
    }
    return null;
}

function setIfMissing(value, path) {
    if (path === void 0) { path = []; }
    return {
        type: 'setIfMissing',
        path: path,
        value: value,
    };
}
// eslint-disable-next-line new-cap
var dmp$3 = new DMP.diff_match_patch();
function diffMatchPatch(currentValue, nextValue, path) {
    if (path === void 0) { path = []; }
    var patch = dmp$3
        .patch_make(currentValue, nextValue)
        .map(function (_patch) { return _patch.toString(); })
        .join('');
    return { type: 'diffMatchPatch', path: path, value: patch };
}
function insert$1(items, position, path) {
    if (path === void 0) { path = []; }
    return {
        type: 'insert',
        path: path,
        position: position,
        items: items,
    };
}
function set(value, path) {
    if (path === void 0) { path = []; }
    return { type: 'set', path: path, value: value };
}
function unset(path) {
    if (path === void 0) { path = []; }
    return { type: 'unset', path: path };
}

function validateValue(value, portableTextFeatures, keyGenerator) {
    var resolution = null;
    var valid = true;
    var validChildTypes = __spreadArray(__spreadArray([], [portableTextFeatures.types.span.name], false), __read(portableTextFeatures.types.inlineObjects.map(function (t) { return t.name; })), false);
    var validBlockTypes = __spreadArray(__spreadArray([], [portableTextFeatures.types.block.name], false), __read(portableTextFeatures.types.blockObjects.map(function (t) { return t.name; })), false);
    // Undefined is allowed
    if (value === undefined) {
        return { valid: true, resolution: null };
    }
    // Only lengthy arrays are allowed "inside" the editor.
    if (!Array.isArray(value) || value.length === 0) {
        return {
            valid: false,
            resolution: {
                patches: [unset([])],
                description: 'Editor value must be an array of Portable Text blocks, or undefined.',
                action: 'Unset the value',
                item: value,
            },
        };
    }
    if (value.some(function (blk, index) {
        if (!isObject(blk)) {
            resolution = {
                patches: [unset([index])],
                description: "Block must be an object, got ".concat(String(blk)),
                action: "Unset invalid item",
                item: blk,
            };
            return true;
        }
        // Test that every block has a _key
        if (!blk._key) {
            resolution = {
                patches: [set(__assign(__assign({}, blk), { _key: keyGenerator() }), [index])],
                description: "Block at index ".concat(index, " is missing required _key."),
                action: 'Set the block with a random _key value',
                item: blk,
            };
            return true;
        }
        // Test that every block has valid _type
        if (!blk._type || !validBlockTypes.includes(blk._type)) {
            // Special case where block type is set to default 'block', but the block type is named something else according to the schema.
            if (blk._type === 'block') {
                var currentBlockTypeName = portableTextFeatures.types.block.name;
                resolution = {
                    patches: [set(__assign(__assign({}, blk), { _type: currentBlockTypeName }), [{ _key: blk._key }])],
                    description: "Block with _key '".concat(blk._key, "' has invalid type name '").concat(blk._type, "'. According to the schema, the block type name is '").concat(currentBlockTypeName, "'"),
                    action: "Use type '".concat(currentBlockTypeName, "'"),
                    item: blk,
                };
                return true;
            }
            resolution = {
                patches: [unset([{ _key: blk._key }])],
                description: "Block with _key '".concat(blk._key, "' has invalid _type '").concat(blk._type, "'"),
                action: 'Remove the block',
                item: blk,
            };
            return true;
        }
        // Test that every child in text block is valid
        if (blk._type === portableTextFeatures.types.block.name) {
            // Test that it has children
            if (!blk.children) {
                resolution = {
                    patches: [unset([{ _key: blk._key }])],
                    description: "Text block with _key '".concat(blk._key, "' is missing required key 'children'."),
                    action: 'Remove the block',
                    item: blk,
                };
                return true;
            }
            // Test that markDefs exists
            if (!blk.markDefs) {
                resolution = {
                    patches: [set(__assign(__assign({}, blk), { markDefs: [] }), [{ _key: blk._key }])],
                    description: "Block is missing required key 'markDefs'.",
                    action: 'Add empty markDefs array',
                    item: blk,
                };
                return true;
            }
            // // Test that every span has .marks
            // const spansWithUndefinedMarks = blk.children
            //   .filter(cld => cld._type === portableTextFeatures.types.span.name)
            //   .filter(cld => typeof cld.marks === 'undefined')
            // if (spansWithUndefinedMarks.length > 0) {
            //   const first = spansWithUndefinedMarks[0]
            //   resolution = {
            //     patches: [
            //       set({...first, marks: []}, [{_key: blk._key}, 'children', {_key: first._key}])
            //     ],
            //     description: `Span has no .marks array`,
            //     action: 'Add empty marks array',
            //     item: first
            //   }
            //   return true
            // }
            var allUsedMarks = uniq(flatten$1(blk.children
                .filter(function (cld) { return cld._type === portableTextFeatures.types.span.name; })
                .map(function (cld) { return cld.marks || []; })));
            // // Test that all markDefs are in use
            // if (blk.markDefs && blk.markDefs.length > 0) {
            //   const unusedMarkDefs: string[] = uniq(
            //     blk.markDefs.map(def => def._key).filter(key => !allUsedMarks.includes(key))
            //   )
            //   if (unusedMarkDefs.length > 0) {
            //     resolution = {
            //       patches: unusedMarkDefs.map(key =>
            //         unset([{_key: blk._key}, 'markDefs', {_key: key}])
            //       ),
            //       description: `Block has unused mark definitions: ${unusedMarkDefs.join(', ')}.`,
            //       action: 'Remove unused markDefs',
            //       item: blk
            //     }
            //     return true
            //   }
            // }
            // Test that every annotation mark used has a definition
            var annotationMarks = allUsedMarks.filter(function (mark) { return !portableTextFeatures.decorators.map(function (dec) { return dec.value; }).includes(mark); });
            var orphanedMarks_1 = annotationMarks.filter(function (mark) { return !blk.markDefs.find(function (def) { return def._key === mark; }); });
            if (orphanedMarks_1.length > 0) {
                var children = blk.children.filter(function (cld) {
                    return Array.isArray(cld.marks) &&
                        cld.marks.some(function (mark) { return orphanedMarks_1.includes(mark); });
                });
                if (children) {
                    resolution = {
                        patches: children.map(function (child) {
                            return set(child.marks.filter(function (cmrk) { return !orphanedMarks_1.includes(cmrk); }), [{ _key: blk._key }, 'children', { _key: child._key }, 'marks']);
                        }),
                        description: "Block with _key '".concat(blk._key, "' contains marks (").concat(orphanedMarks_1.join(', '), ") not supported by the current content model."),
                        action: 'Remove invalid marks',
                        item: blk,
                    };
                    return true;
                }
            }
            // Test that children is lengthy
            if (blk.children && blk.children.length === 0) {
                var newSpan = {
                    _type: portableTextFeatures.types.span.name,
                    _key: keyGenerator(),
                    text: '',
                };
                resolution = {
                    patches: [insert$1([newSpan], 'after', [{ _key: blk._key }, 'children', 0])],
                    description: "Children for text block with _key '".concat(blk._key, "' is empty."),
                    action: 'Insert an empty text',
                    item: blk,
                };
                return true;
            }
            // Test every child
            if (blk.children.some(function (child, cIndex) {
                if (!child._key) {
                    var newchild = __assign(__assign({}, child), { _key: keyGenerator() });
                    resolution = {
                        patches: [set(newchild, [{ _key: blk._key }, 'children', cIndex])],
                        description: "Child at index ".concat(cIndex, " is missing required _key in block with _key ").concat(blk._key, "."),
                        action: 'Set a new random _key on the object',
                        item: blk,
                    };
                    return true;
                }
                // Verify that childs have valid types
                if (!child._type || validChildTypes.includes(child._type) === false) {
                    resolution = {
                        patches: [unset([{ _key: blk._key }, 'children', { _key: child._key }])],
                        description: "Child with _key '".concat(child._key, "' in block with key '").concat(blk._key, "' has invalid '_type' property (").concat(child._type, ")."),
                        action: 'Remove the object',
                        item: blk,
                    };
                    return true;
                }
                // Verify that spans have .text
                if (child._type === portableTextFeatures.types.span.name && child.text === undefined) {
                    resolution = {
                        patches: [
                            set(__assign(__assign({}, child), { text: '' }), [{ _key: blk._key }, 'children', { _key: child._key }]),
                        ],
                        description: "Child with _key '".concat(child._key, "' in block with key '").concat(blk._key, "' is missing text property!"),
                        action: "Write an empty .text to the object",
                        item: blk,
                    };
                    return true;
                }
                return false;
            })) {
                valid = false;
            }
        }
        return false;
    })) {
        valid = false;
    }
    return { valid: valid, resolution: resolution };
}

var rootName = 'sanity-pte:';
debug$i(rootName);
function debugWithName(name) {
    var namespace = "".concat(rootName).concat(name);
    if (debug$i && debug$i.enabled(namespace)) {
        return debug$i(namespace);
    }
    return debug$i(rootName);
}

var EMPTY_MARKDEFS = [];
function keepObjectEquality(object, keyMap) {
    var value = keyMap[object._key];
    if (value && isEqual(object, value)) {
        return value;
    }
    keyMap[object._key] = object;
    return object;
}
function toSlateValue(value, _a, keyMap) {
    var portableTextFeatures = _a.portableTextFeatures;
    if (keyMap === void 0) { keyMap = {}; }
    if (value && Array.isArray(value)) {
        return value.map(function (block) {
            var _type = block._type, _key = block._key, rest = __rest(block, ["_type", "_key"]);
            var voidChildren = [{ _key: "".concat(_key, "-void-child"), _type: 'span', text: '', marks: [] }];
            var isPortableText = block && block._type === portableTextFeatures.types.block.name;
            if (isPortableText) {
                var textBlock = block;
                var hasInlines_1 = false;
                var hasMissingStyle = typeof textBlock.style === 'undefined';
                var hasMissingMarkDefs = typeof textBlock.markDefs === 'undefined';
                var children = textBlock.children.map(function (child) {
                    var cType = child._type, cKey = child._key, cRest = __rest(child, ["_type", "_key"]);
                    if (cType !== 'span') {
                        hasInlines_1 = true;
                        return keepObjectEquality({
                            _type: cType,
                            _key: cKey,
                            children: voidChildren,
                            value: cRest,
                            __inline: true,
                        }, keyMap);
                    }
                    // Original object
                    return child;
                });
                if (!hasMissingStyle && !hasMissingMarkDefs && !hasInlines_1 && Element$1.isElement(block)) {
                    // Original object
                    return block;
                }
                if (hasMissingStyle) {
                    rest.style = portableTextFeatures.styles[0].value;
                }
                if (hasMissingMarkDefs) {
                    rest.markDefs = EMPTY_MARKDEFS;
                }
                return keepObjectEquality(__assign(__assign({ _type: _type, _key: _key }, rest), { children: children }), keyMap);
            }
            return keepObjectEquality({
                _type: _type,
                _key: _key,
                children: voidChildren,
                value: rest,
            }, keyMap);
        });
    }
    return [];
}
function fromSlateValue(value, textBlockType, keyMap) {
    if (keyMap === void 0) { keyMap = {}; }
    return value.map(function (block) {
        var _key = block._key, _type = block._type;
        if (!_key || !_type) {
            throw new Error('Not a valid block');
        }
        if (_type === textBlockType && 'children' in block && Array.isArray(block.children) && _key) {
            var hasInlines_2 = false;
            var children = block.children.map(function (child) {
                var _cType = child._type;
                if ('value' in child && _cType !== 'span') {
                    hasInlines_2 = true;
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    var v = child.value, k = child._key, t = child._type, rest = __rest(child, ["value", "_key", "_type", "__inline", "children"]);
                    return keepObjectEquality(__assign(__assign(__assign({}, rest), v), { _key: k, _type: t }), keyMap);
                }
                return child;
            });
            if (!hasInlines_2) {
                return block; // Original object
            }
            return keepObjectEquality(__assign(__assign({}, block), { children: children, _key: _key, _type: _type }), keyMap);
        }
        var blockValue = 'value' in block && block.value;
        return keepObjectEquality(__assign({ _key: _key, _type: _type }, (typeof blockValue === 'object' ? blockValue : {})), keyMap);
    });
}
function isEqualToEmptyEditor(children, portableTextFeatures) {
    return (children === undefined ||
        (children && Array.isArray(children) && children.length === 0) ||
        (children &&
            Array.isArray(children) &&
            children.length === 1 &&
            Element$1.isElement(children[0]) &&
            children[0]._type === portableTextFeatures.types.block.name &&
            'style' in children[0] &&
            children[0].style === portableTextFeatures.styles[0].value &&
            Array.isArray(children[0].children) &&
            children[0].children.length === 1 &&
            Text.isText(children[0].children[0]) &&
            children[0].children[0]._type === 'span' &&
            children[0].children[0].text === ''));
}
function getValueOrInitialValue(value, initialValue) {
    if (value && Array.isArray(value) && value.length > 0) {
        return value;
    }
    return initialValue;
}

/**
 * Dragging
 */
// Is the editor dragging something?
var IS_DRAGGING = new WeakMap();
// Is the editor dragging a element?
var IS_DRAGGING_BLOCK_ELEMENT = new WeakMap();
var IS_DRAGGING_CHILD_ELEMENT = new WeakMap();
// When dragging elements, this will be the target element
var IS_DRAGGING_ELEMENT_TARGET = new WeakMap();
var IS_DRAGGING_ELEMENT_RANGE = new WeakMap();
// Target position for dragging over a block
var IS_DRAGGING_BLOCK_TARGET_POSITION = new WeakMap();
var KEY_TO_SLATE_ELEMENT = new WeakMap();
var KEY_TO_VALUE_ELEMENT = new WeakMap();
// Keep object relation to slate range in the portable-text-range
var SLATE_TO_PORTABLE_TEXT_RANGE = new WeakMap();

/**
 * A React context for sharing the editor object.
 */
var PortableTextEditorContext = createContext(null);
/**
 * Get the current editor object from the React context.
 */
var usePortableTextEditor = function () {
    var editor = useContext(PortableTextEditorContext);
    if (!editor) {
        throw new Error("The `usePortableTextEditor` hook must be used inside the <PortableTextEditor> component's context.");
    }
    return editor;
};

/**
 * A React context for sharing the editor selection.
 */
var PortableTextEditorSelectionContext = createContext(null);
/**
 * Get the current editor selection from the React context.
 */
var usePortableTextEditorSelection = function () {
    var selection = useContext(PortableTextEditorSelectionContext);
    if (selection === undefined) {
        throw new Error("The `usePortableTextEditorSelection` hook must be used inside the <PortableTextEditor> component's context.");
    }
    return selection;
};

/**
 * A React context for sharing the editor's readOnly status.
 */
var PortableTextEditorReadOnlyContext = createContext(false);
/**
 * Get the current editor selection from the React context.
 */
var usePortableTextEditorReadOnlyStatus = function () {
    var readOnly = useContext(PortableTextEditorReadOnlyContext);
    if (readOnly === undefined) {
        throw new Error("The `usePortableTextEditorReadOnly` hook must be used inside the <PortableTextEditor> component's context.");
    }
    return readOnly;
};

/**
 * A React context for sharing the editor value.
 */
var PortableTextEditorValueContext = createContext(undefined);

var debug$h = debugWithName('operationToPatches');
function createOperationToPatches(portableTextFeatures) {
    var textBlockName = portableTextFeatures.types.block.name;
    function insertTextPatch(editor, operation, beforeValue) {
        debug$h('Operation', JSON.stringify(operation, null, 2));
        var block = editor.isTextBlock(editor.children[operation.path[0]]) && editor.children[operation.path[0]];
        if (!block) {
            throw new Error('Could not find block');
        }
        var textChild = editor.isTextBlock(block) &&
            Text.isText(block.children[operation.path[1]]) &&
            block.children[operation.path[1]];
        if (!textChild) {
            throw new Error('Could not find child');
        }
        var path = [{ _key: block._key }, 'children', { _key: textChild._key }, 'text'];
        var prevBlock = beforeValue[operation.path[0]];
        var prevChild = editor.isTextBlock(prevBlock) && prevBlock.children[operation.path[1]];
        var prevText = Text.isText(prevChild) ? prevChild.text : '';
        var patch = diffMatchPatch(prevText, textChild.text, path);
        return patch.value.length ? [patch] : [];
    }
    function removeTextPatch(editor, operation, beforeValue) {
        var block = editor && editor.children[operation.path[0]];
        if (!block) {
            throw new Error('Could not find block');
        }
        var textChild = editor.isTextBlock(block) &&
            Text.isText(block.children[operation.path[1]]) &&
            block.children[operation.path[1]];
        if (!textChild) {
            throw new Error('Could not find child');
        }
        var path = [{ _key: block._key }, 'children', { _key: textChild._key }, 'text'];
        var beforeBlock = beforeValue[operation.path[0]];
        var prevTextChild = editor.isTextBlock(beforeBlock) && beforeBlock.children[operation.path[1]];
        var prevText = Text.isText(prevTextChild) && prevTextChild.text;
        var patch = diffMatchPatch(prevText || '', textChild.text, path);
        return patch.value ? [patch] : [];
    }
    function setNodePatch(editor, operation) {
        if (operation.path.length === 1) {
            var block = editor.children[operation.path[0]];
            if (typeof block._key !== 'string') {
                throw new Error('Expected block to have a _key');
            }
            var setNode = omitBy(__assign(__assign({}, editor.children[operation.path[0]]), operation.newProperties), isUndefined);
            return [set(fromSlateValue([setNode], textBlockName)[0], [{ _key: block._key }])];
        }
        else if (operation.path.length === 2) {
            var block = editor.children[operation.path[0]];
            if (editor.isTextBlock(block)) {
                var child = block.children[operation.path[1]];
                if (child) {
                    var blockKey_1 = block._key;
                    var childKey_1 = child._key;
                    var patches_1 = [];
                    Object.keys(operation.newProperties).forEach(function (keyName) {
                        var val = get(operation.newProperties, keyName);
                        patches_1.push(set(val, [{ _key: blockKey_1 }, 'children', { _key: childKey_1 }, keyName]));
                    });
                    return patches_1;
                }
                throw new Error('Could not find a valid child');
            }
            throw new Error('Could not find a valid block');
        }
        else {
            throw new Error("Unexpected path encountered: ".concat(JSON.stringify(operation.path)));
        }
    }
    function insertNodePatch(editor, operation, beforeValue) {
        var block = beforeValue[operation.path[0]];
        if (operation.path.length === 1) {
            var position = operation.path[0] === 0 ? 'before' : 'after';
            var beforeBlock = beforeValue[operation.path[0] - 1];
            var targetKey = operation.path[0] === 0 ? block === null || block === void 0 ? void 0 : block._key : beforeBlock === null || beforeBlock === void 0 ? void 0 : beforeBlock._key;
            if (targetKey) {
                return [
                    insert$1([fromSlateValue([operation.node], textBlockName)[0]], position, [
                        { _key: targetKey },
                    ]),
                ];
            }
            return [
                setIfMissing(beforeValue, []),
                insert$1([fromSlateValue([operation.node], textBlockName)[0]], 'before', [operation.path[0]]),
            ];
        }
        else if (operation.path.length === 2 && editor.children[operation.path[0]]) {
            if (!editor.isTextBlock(block)) {
                throw new Error('Invalid block');
            }
            var position = block.children.length === 0 || !block.children[operation.path[1] - 1] ? 'before' : 'after';
            var child = fromSlateValue([
                {
                    _key: 'bogus',
                    _type: textBlockName,
                    children: [operation.node],
                },
            ], textBlockName)[0].children[0];
            return [
                insert$1([child], position, [
                    { _key: block._key },
                    'children',
                    block.children.length <= 1 || !block.children[operation.path[1] - 1]
                        ? 0
                        : { _key: block.children[operation.path[1] - 1]._key },
                ]),
            ];
        }
        throw new Error("Unexpected path encountered: ".concat(JSON.stringify(operation.path), " - ").concat(JSON.stringify(beforeValue)));
    }
    function splitNodePatch(editor, operation, beforeValue) {
        var patches = [];
        var splitBlock = editor.children[operation.path[0]];
        if (!editor.isTextBlock(splitBlock)) {
            throw new Error("Block with path ".concat(JSON.stringify(operation.path[0]), " is not a text block and can't be split"));
        }
        if (operation.path.length === 1) {
            var oldBlock_1 = beforeValue[operation.path[0]];
            if (editor.isTextBlock(oldBlock_1)) {
                var targetValue = fromSlateValue([editor.children[operation.path[0] + 1]], textBlockName)[0];
                if (targetValue) {
                    patches.push(insert$1([targetValue], 'after', [{ _key: splitBlock._key }]));
                    var spansToUnset = oldBlock_1.children.slice(operation.position);
                    spansToUnset.forEach(function (span) {
                        var path = [{ _key: oldBlock_1._key }, 'children', { _key: span._key }];
                        patches.push(unset(path));
                    });
                }
            }
            return patches;
        }
        if (operation.path.length === 2) {
            var splitSpan = splitBlock.children[operation.path[1]];
            if (Text.isText(splitSpan)) {
                var targetSpans = fromSlateValue([
                    __assign(__assign({}, splitBlock), { children: splitBlock.children.slice(operation.path[1] + 1, operation.path[1] + 2) }),
                ], textBlockName)[0].children;
                patches.push(insert$1(targetSpans, 'after', [
                    { _key: splitBlock._key },
                    'children',
                    { _key: splitSpan._key },
                ]));
                patches.push(set(splitSpan.text, [{ _key: splitBlock._key }, 'children', { _key: splitSpan._key }, 'text']));
            }
            return patches;
        }
        return patches;
    }
    function removeNodePatch(_, operation, beforeValue) {
        var block = beforeValue[operation.path[0]];
        if (operation.path.length === 1) {
            // Remove a single block
            if (block && block._key) {
                return [unset([{ _key: block._key }])];
            }
            throw new Error('Block not found');
        }
        else if (operation.path.length === 2) {
            var spanToRemove = block && block.children && block.children[operation.path[1]];
            if (spanToRemove) {
                return [unset([{ _key: block._key }, 'children', { _key: spanToRemove._key }])];
            }
            // If it was not there before, do nothing
            debug$h('Span not found in editor trying to remove node');
            return [];
        }
        else {
            throw new Error("Unexpected path encountered: ".concat(JSON.stringify(operation.path)));
        }
    }
    function mergeNodePatch(editor, operation, beforeValue) {
        var patches = [];
        if (operation.path.length === 1) {
            var block = beforeValue[operation.path[0]];
            var targetKey = block && block._key;
            if (targetKey) {
                var newBlock = fromSlateValue([editor.children[operation.path[0] - 1]], textBlockName)[0];
                patches.push(set(newBlock, [{ _key: newBlock._key }]));
                patches.push(unset([{ _key: targetKey }]));
            }
            else {
                throw new Error('Target key not found!');
            }
        }
        else if (operation.path.length === 2) {
            var block = beforeValue[operation.path[0]];
            var mergedSpan = block.children[operation.path[1]];
            var targetBlock = editor.children[operation.path[0]];
            if (!editor.isTextBlock(targetBlock)) {
                throw new Error('Invalid block');
            }
            var targetSpan = targetBlock.children[operation.path[1] - 1];
            if (Text.isText(targetSpan)) {
                // Set the merged span with it's new value
                patches.push(set(targetSpan.text, [{ _key: block._key }, 'children', { _key: targetSpan._key }, 'text']));
                patches.push(unset([{ _key: block._key }, 'children', { _key: mergedSpan._key }]));
            }
        }
        else {
            throw new Error("Unexpected path encountered: ".concat(JSON.stringify(operation.path)));
        }
        return patches;
    }
    function moveNodePatch(_, operation, beforeValue) {
        var patches = [];
        var block = beforeValue[operation.path[0]];
        var targetBlock = beforeValue[operation.newPath[0]];
        if (operation.path.length === 1) {
            var position = operation.path[0] > operation.newPath[0] ? 'before' : 'after';
            patches.push(unset([{ _key: block._key }]));
            patches.push(insert$1([fromSlateValue([block], textBlockName)[0]], position, [{ _key: targetBlock._key }]));
        }
        else if (operation.path.length === 2) {
            var child = block.children[operation.path[1]];
            var targetChild = targetBlock.children[operation.newPath[1]];
            var position = operation.newPath[1] === targetBlock.children.length ? 'after' : 'before';
            var childToInsert = fromSlateValue([block], textBlockName)[0].children[operation.path[1]];
            patches.push(unset([{ _key: block._key }, 'children', { _key: child._key }]));
            patches.push(insert$1([childToInsert], position, [
                { _key: targetBlock._key },
                'children',
                { _key: targetChild._key },
            ]));
        }
        return patches;
    }
    return {
        insertNodePatch: insertNodePatch,
        insertTextPatch: insertTextPatch,
        mergeNodePatch: mergeNodePatch,
        moveNodePatch: moveNodePatch,
        removeNodePatch: removeNodePatch,
        removeTextPatch: removeTextPatch,
        setNodePatch: setNodePatch,
        splitNodePatch: splitNodePatch,
    };
}

function createKeyedPath(point, value, portableTextFeatures) {
    var blockPath = [point.path[0]];
    if (!value) {
        return null;
    }
    var block = value[blockPath[0]];
    if (!block) {
        return null;
    }
    var keyedBlockPath = [{ _key: block._key }];
    if (block._type !== portableTextFeatures.types.block.name) {
        return keyedBlockPath;
    }
    var keyedChildPath;
    var childPath = point.path.slice(0, 2);
    var child = block.children[childPath[1]];
    if (child) {
        keyedChildPath = ['children', { _key: child._key }];
    }
    return (keyedChildPath ? __spreadArray(__spreadArray([], __read(keyedBlockPath), false), __read(keyedChildPath), false) : keyedBlockPath);
}
function createArrayedPath(point, editor) {
    if (!editor) {
        return [];
    }
    var _a = __read(Array.from(Editor.nodes(editor, {
        at: [],
        match: function (n) { return isKeySegment(point.path[0]) && n._key === point.path[0]._key; },
    }))[0] || [undefined, undefined], 2), block = _a[0], blockPath = _a[1];
    if (!block || !Element$1.isElement(block)) {
        return [];
    }
    if (editor.isVoid(block)) {
        return blockPath;
    }
    var childPath = [point.path[2]];
    var childIndex = block.children.findIndex(function (child) { return isEqual([{ _key: child._key }], childPath); });
    if (childIndex >= 0 && block.children[childIndex]) {
        var child = block.children[childIndex];
        if (Element$1.isElement(child) && editor.isVoid(child)) {
            return blockPath.concat(childIndex).concat(0);
        }
        return blockPath.concat(childIndex);
    }
    return blockPath;
}

function toPortableTextRange(value, range, portableTextFeatures) {
    if (!range) {
        return null;
    }
    var anchor = null;
    var focus = null;
    var anchorPath = range.anchor && createKeyedPath(range.anchor, value, portableTextFeatures);
    if (anchorPath && range.anchor) {
        anchor = {
            path: anchorPath,
            offset: range.anchor.offset,
        };
    }
    var focusPath = range.focus && createKeyedPath(range.focus, value, portableTextFeatures);
    if (focusPath && range.focus) {
        focus = {
            path: focusPath,
            offset: range.focus.offset,
        };
    }
    return anchor && focus ? { anchor: anchor, focus: focus } : null;
}
function toSlateRange(selection, editor) {
    if (!selection || !editor) {
        return null;
    }
    var anchor = {
        path: createArrayedPath(selection.anchor, editor),
        offset: selection.anchor.offset,
    };
    var focus = {
        path: createArrayedPath(selection.focus, editor),
        offset: selection.focus.offset,
    };
    var range = anchor && focus ? { anchor: anchor, focus: focus } : null;
    return range;
}

var debug$g = debugWithName('API:editable');
function createWithEditableAPI(portableTextEditor, portableTextFeatures, keyGenerator) {
    return function withEditableAPI(editor) {
        portableTextEditor.setEditable({
            focus: function () {
                // Make a selection if missing
                if (!editor.selection) {
                    var point = { path: [0, 0], offset: 0 };
                    Transforms.select(editor, { focus: point, anchor: point });
                    editor.onChange();
                }
                ReactEditor.focus(editor);
            },
            blur: function () {
                ReactEditor.blur(editor);
            },
            toggleMark: function (mark) {
                editor.pteToggleMark(mark);
            },
            toggleList: function (listStyle) {
                editor.pteToggleListItem(listStyle);
            },
            toggleBlockStyle: function (blockStyle) {
                editor.pteToggleBlockStyle(blockStyle);
            },
            isMarkActive: function (mark) {
                // Try/catch this, as Slate may error because the selection is currently wrong
                // TODO: catch only relevant error from Slate
                try {
                    return editor.pteIsMarkActive(mark);
                }
                catch (err) {
                    console.warn(err);
                    return false;
                }
            },
            marks: function () {
                return (__assign({}, (Editor.marks(editor) || {})).marks || []);
            },
            undo: function () { return editor.undo(); },
            redo: function () { return editor.redo(); },
            select: function (selection) {
                var slateSelection = toSlateRange(selection, editor);
                if (slateSelection) {
                    Transforms.select(editor, slateSelection);
                }
                else {
                    Transforms.deselect(editor);
                }
                editor.onChange();
            },
            focusBlock: function () {
                if (editor.selection) {
                    // Try/catch this, as Slate may error because the selection is currently wrong
                    // TODO: catch only relevant error from Slate
                    try {
                        var _a = __read(Array.from(Editor.nodes(editor, {
                            at: editor.selection.focus,
                            match: function (n) { return Editor.isBlock(editor, n); },
                        }))[0] || [undefined], 1), block = _a[0];
                        if (block) {
                            return fromSlateValue([block], portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];
                        }
                    }
                    catch (err) {
                        return undefined;
                    }
                }
                return undefined;
            },
            focusChild: function () {
                if (editor.selection) {
                    try {
                        var _a = __read(Array.from(Editor.nodes(editor, {
                            mode: 'lowest',
                            at: editor.selection.focus,
                            match: function (n) { return n._type !== undefined; },
                            voids: true,
                        }))[0] || [undefined], 1), node = _a[0];
                        if (node && !Editor.isBlock(editor, node)) {
                            var pseudoBlock = {
                                _key: 'pseudo',
                                _type: portableTextFeatures.types.block.name,
                                children: [node],
                            };
                            return fromSlateValue([pseudoBlock], portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0].children[0];
                        }
                    }
                    catch (err) {
                        return undefined;
                    }
                }
                return undefined;
            },
            insertChild: function (type, value) {
                var _a;
                if (!editor.selection) {
                    throw new Error('The editor has no selection');
                }
                var _b = __read(Array.from(Editor.nodes(editor, {
                    at: editor.selection.focus,
                    match: function (n) { return Editor.isBlock(editor, n); },
                }))[0] || [undefined], 1), focusBlock = _b[0];
                if (!focusBlock) {
                    throw new Error('No focus block');
                }
                if (focusBlock && Editor.isVoid(editor, focusBlock)) {
                    throw new Error("Can't insert childs into block objects");
                }
                var block = toSlateValue([
                    {
                        _key: keyGenerator(),
                        _type: portableTextFeatures.types.block.name,
                        children: [
                            __assign({ _key: keyGenerator(), _type: type.name }, (value ? value : {})),
                        ],
                    },
                ], portableTextEditor)[0];
                var child = block.children[0];
                Editor.insertNode(editor, child);
                editor.onChange();
                return (((_a = toPortableTextRange(fromSlateValue(editor.children, portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, portableTextFeatures)) === null || _a === void 0 ? void 0 : _a.focus.path) || []);
            },
            insertBlock: function (type, value) {
                var _a;
                if (!editor.selection) {
                    throw new Error('The editor has no selection');
                }
                var block = toSlateValue([
                    __assign({ _key: keyGenerator(), _type: type.name }, (value ? value : {})),
                ], portableTextEditor)[0];
                Editor.insertNode(editor, block);
                editor.onChange();
                return (((_a = toPortableTextRange(fromSlateValue(editor.children, portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, portableTextFeatures)) === null || _a === void 0 ? void 0 : _a.focus.path) || []);
            },
            hasBlockStyle: function (style) {
                try {
                    return editor.pteHasBlockStyle(style);
                }
                catch (err) {
                    // This is fine.
                    // debug(err)
                    return false;
                }
            },
            hasListStyle: function (listStyle) {
                try {
                    return editor.pteHasListStyle(listStyle);
                }
                catch (err) {
                    // This is fine.
                    // debug(err)
                    return false;
                }
            },
            isVoid: function (element) {
                return ![
                    portableTextFeatures.types.block.name,
                    portableTextFeatures.types.span.name,
                ].includes(element._type);
            },
            findByPath: function (path) {
                var slatePath = toSlateRange({ focus: { path: path, offset: 0 }, anchor: { path: path, offset: 0 } }, editor);
                if (slatePath) {
                    var _a = __read(Editor.node(editor, slatePath.focus.path.slice(0, 1)), 2), block = _a[0], blockPath = _a[1];
                    if (block && blockPath && typeof block._key === 'string') {
                        if (path.length === 1 && slatePath.focus.path.length === 1) {
                            return [
                                fromSlateValue([block], portableTextFeatures.types.block.name)[0],
                                [{ _key: block._key }],
                            ];
                        }
                        var ptBlock = fromSlateValue([block], portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];
                        var ptChild = ptBlock.children[slatePath.focus.path[1]];
                        if (ptChild) {
                            return [ptChild, [{ _key: block._key }, 'children', { _key: ptChild._key }]];
                        }
                    }
                }
                return [undefined, undefined];
            },
            findDOMNode: function (element) {
                var node;
                try {
                    var _a = __read(Array.from(Editor.nodes(editor, {
                        at: [],
                        match: function (n) { return n._key === element._key; },
                    }) || [])[0] || [undefined], 1), item = _a[0];
                    node = ReactEditor.toDOMNode(editor, item);
                }
                catch (err) {
                    // Nothing
                }
                return node;
            },
            activeAnnotations: function () {
                var e_1, _a;
                if (!editor.selection || editor.selection.focus.path.length < 2) {
                    return [];
                }
                try {
                    var activeAnnotations_1 = [];
                    var spans = Editor.nodes(editor, {
                        at: editor.selection,
                        match: function (node) {
                            return Text.isText(node) &&
                                node.marks !== undefined &&
                                Array.isArray(node.marks) &&
                                node.marks.length > 0;
                        },
                    });
                    var _loop_1 = function (span, path) {
                        var _c = __read(Editor.node(editor, path, { depth: 1 }), 1), block = _c[0];
                        if (editor.isTextBlock(block)) {
                            block.markDefs.forEach(function (def) {
                                if (Text.isText(span) &&
                                    span.marks &&
                                    Array.isArray(span.marks) &&
                                    span.marks.includes(def._key)) {
                                    activeAnnotations_1.push(def);
                                }
                            });
                        }
                    };
                    try {
                        for (var spans_1 = __values(spans), spans_1_1 = spans_1.next(); !spans_1_1.done; spans_1_1 = spans_1.next()) {
                            var _b = __read(spans_1_1.value, 2), span = _b[0], path = _b[1];
                            _loop_1(span, path);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (spans_1_1 && !spans_1_1.done && (_a = spans_1.return)) _a.call(spans_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    return activeAnnotations_1;
                }
                catch (err) {
                    return [];
                }
            },
            addAnnotation: function (type, value) {
                var selection = editor.selection;
                if (selection) {
                    var _a = __read(Editor.node(editor, selection.focus, { depth: 1 }), 1), block = _a[0];
                    if (Element$1.isElement(block) &&
                        block._type === portableTextFeatures.types.block.name) {
                        var annotationKey_1 = keyGenerator();
                        if (editor.isTextBlock(block)) {
                            Transforms.setNodes(editor, {
                                markDefs: __spreadArray(__spreadArray([], __read(block.markDefs), false), [__assign({ _type: type.name, _key: annotationKey_1 }, value)], false),
                            }, { at: selection.focus });
                            editor.onChange();
                            if (Range.isCollapsed(selection)) {
                                editor.pteExpandToWord();
                                editor.onChange();
                            }
                            var _b = __read(Editor.node(editor, selection.focus, { depth: 2 }), 1), textNode_1 = _b[0];
                            if (editor.selection) {
                                Editor.withoutNormalizing(editor, function () {
                                    // Split if needed
                                    Transforms.setNodes(editor, {}, { match: Text.isText, split: true });
                                    if (editor.selection && Text.isText(textNode_1)) {
                                        Transforms.setNodes(editor, {
                                            marks: __spreadArray(__spreadArray([], __read((textNode_1.marks || [])), false), [annotationKey_1], false),
                                        }, {
                                            at: editor.selection,
                                            match: function (n) { return n._type === portableTextFeatures.types.span.name; },
                                        });
                                        editor.onChange();
                                    }
                                });
                                Editor.normalize(editor);
                                editor.onChange();
                                var newSelection = toPortableTextRange(fromSlateValue(editor.children, portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, portableTextFeatures);
                                // eslint-disable-next-line max-depth
                                if (newSelection && typeof block._key === 'string') {
                                    // Insert an empty string to continue writing non-annotated text
                                    Editor.withoutNormalizing(editor, function () {
                                        if (editor.selection) {
                                            Transforms.insertNodes(editor, [{ _type: 'span', text: '', marks: [], _key: keyGenerator() }], {
                                                at: Range.end(editor.selection),
                                            });
                                            editor.onChange();
                                        }
                                    });
                                    return {
                                        spanPath: newSelection.focus.path,
                                        markDefPath: [{ _key: block._key }, 'markDefs', { _key: annotationKey_1 }],
                                    };
                                }
                            }
                        }
                    }
                }
                return undefined;
            },
            delete: function (selection, options) {
                if (selection) {
                    var range = toSlateRange(selection, editor);
                    if (range) {
                        if (!(options === null || options === void 0 ? void 0 : options.mode) || (options === null || options === void 0 ? void 0 : options.mode) === 'selected') {
                            debug$g("Deleting content in selection");
                            Transforms.delete(editor, {
                                at: range,
                                hanging: true,
                                voids: true,
                            });
                            editor.onChange();
                            return;
                        }
                        var nodes = Editor.nodes(editor, {
                            at: range,
                            match: function (node) {
                                if ((options === null || options === void 0 ? void 0 : options.mode) === 'blocks') {
                                    debug$g("Deleting blocks touched by selection");
                                    return (editor.isTextBlock(node) ||
                                        (!editor.isTextBlock(node) && Element$1.isElement(node)));
                                }
                                debug$g("Deleting children touched by selection");
                                return (node._type === portableTextFeatures.types.span.name || // Text children
                                    (!editor.isTextBlock(node) && Element$1.isElement(node)) // inline blocks
                                );
                            },
                        });
                        var nodeAndPaths = __spreadArray([], __read(nodes), false);
                        nodeAndPaths.forEach(function (_a) {
                            var _b = __read(_a, 2), p = _b[1];
                            Transforms.removeNodes(editor, {
                                at: p,
                                voids: true,
                                hanging: true,
                            });
                        });
                        editor.onChange();
                    }
                }
            },
            removeAnnotation: function (type) {
                var selection = editor.selection;
                debug$g('Removing annotation', type);
                if (selection) {
                    // Select the whole annotation if collapsed
                    if (Range.isCollapsed(selection)) {
                        var _a = __read(Editor.node(editor, selection, { depth: 2 }), 2), node = _a[0], nodePath = _a[1];
                        if (Text.isText(node) && node.marks && typeof node.text === 'string') {
                            Transforms.select(editor, nodePath);
                            selection = editor.selection;
                        }
                    }
                    // Do this without normalization or span references will be unstable!
                    Editor.withoutNormalizing(editor, function () {
                        if (selection && Range.isExpanded(selection)) {
                            selection = editor.selection;
                            if (!selection) {
                                return;
                            }
                            // Split the span first
                            Transforms.setNodes(editor, {}, { match: Text.isText, split: true });
                            editor.onChange();
                            // Everything in the selection which has marks
                            var spans = __spreadArray([], __read(Editor.nodes(editor, {
                                at: selection,
                                match: function (node) {
                                    return Text.isText(node) &&
                                        node.marks !== undefined &&
                                        Array.isArray(node.marks) &&
                                        node.marks.length > 0;
                                },
                            })), false);
                            spans.forEach(function (_a) {
                                var _b = __read(_a, 2), span = _b[0], path = _b[1];
                                var _c = __read(Editor.node(editor, path, { depth: 1 }), 1), block = _c[0];
                                if (editor.isTextBlock(block)) {
                                    block.markDefs
                                        .filter(function (def) { return def._type === type.name; })
                                        .forEach(function (def) {
                                        if (Text.isText(span) &&
                                            Array.isArray(span.marks) &&
                                            span.marks.includes(def._key)) {
                                            var newMarks = __spreadArray([], __read((span.marks || []).filter(function (mark) { return mark !== def._key; })), false);
                                            Transforms.setNodes(editor, {
                                                marks: newMarks,
                                            }, { at: path, voids: false, split: false });
                                        }
                                    });
                                }
                            });
                        }
                    });
                    Editor.normalize(editor);
                    editor.onChange();
                }
            },
            getSelection: function () {
                var ptRange = null;
                if (editor.selection) {
                    var existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection);
                    if (existing) {
                        return existing;
                    }
                    ptRange = toPortableTextRange(fromSlateValue(editor.children, portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, portableTextFeatures);
                    SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange);
                }
                return ptRange;
            },
            getValue: function () {
                return fromSlateValue(editor.children, portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor));
            },
            isCollapsedSelection: function () {
                return !!editor.selection && Range.isCollapsed(editor.selection);
            },
            isExpandedSelection: function () {
                return !!editor.selection && Range.isExpanded(editor.selection);
            },
        });
        return editor;
    };
}

/**
 * This plugin makes sure that the PTE maxBlocks prop is respected
 *
 */
function createWithMaxBlocks() {
    return function withMaxBlocks(editor) {
        var apply = editor.apply;
        editor.apply = function (operation) {
            var rows = editor.maxBlocks || -1;
            if (rows > 0 && editor.children.length >= rows) {
                if ((operation.type === 'insert_node' || operation.type === 'split_node') &&
                    operation.path.length === 1) {
                    return;
                }
            }
            apply(operation);
        };
        return editor;
    };
}

var PRESERVE_KEYS = new WeakMap();
function withPreserveKeys(editor, fn) {
    var prev = isPreservingKeys(editor);
    PRESERVE_KEYS.set(editor, true);
    fn();
    PRESERVE_KEYS.set(editor, !prev);
}
function isPreservingKeys(editor) {
    return PRESERVE_KEYS.get(editor);
}

/**
 * This plugin makes sure that every new node in the editor get a new _key prop when created
 *
 */
function createWithObjectKeys(portableTextFeatures, keyGenerator) {
    return function withKeys(editor) {
        PRESERVE_KEYS.set(editor, false);
        var apply = editor.apply, normalizeNode = editor.normalizeNode;
        editor.apply = function (operation) {
            if (operation.type === 'split_node') {
                operation.properties = __assign(__assign({}, operation.properties), { _key: keyGenerator() });
            }
            if (operation.type === 'insert_node') {
                // Must be given a new key or adding/removing marks while typing gets in trouble (duped keys)!
                var withNewKey = !isPreservingKeys(editor) || !('_key' in operation.node);
                if (!Editor.isEditor(operation.node)) {
                    operation.node = __assign(__assign({}, operation.node), (withNewKey ? { _key: keyGenerator() } : {}));
                }
            }
            apply(operation);
        };
        editor.normalizeNode = function (entry) {
            var e_1, _a;
            var _b = __read(entry, 2), node = _b[0], path = _b[1];
            if (Element$1.isElement(node) && node._type === portableTextFeatures.types.block.name) {
                // Set key on block itself
                if (!node._key) {
                    Transforms.setNodes(editor, { _key: keyGenerator() }, { at: path });
                }
                try {
                    // Set keys on it's children
                    for (var _c = __values(Node.children(editor, path)), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var _e = __read(_d.value, 2), child = _e[0], childPath = _e[1];
                        if (!child._key) {
                            Transforms.setNodes(editor, { _key: keyGenerator() }, { at: childPath });
                            return;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            // Do the original `normalizeNode` to enforce other constraints.
            normalizeNode(entry);
        };
        return editor;
    };
}

var PATCHING = new WeakMap();
function withoutPatching(editor, fn) {
    var prev = isPatching(editor);
    PATCHING.set(editor, false);
    fn();
    PATCHING.set(editor, prev);
}
function isPatching(editor) {
    return PATCHING.get(editor);
}

var BEFORE = 'before';
var AFTER = 'after';
function insert(array, position, index) {
    var args = [];
    for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
    }
    if (position !== BEFORE && position !== AFTER) {
        throw new Error("Invalid position \"".concat(position, "\", must be either ").concat(BEFORE, " or ").concat(AFTER));
    }
    var items = flatten.apply(void 0, __spreadArray([], __read(args), false));
    if (array.length === 0) {
        return items;
    }
    var len = array.length;
    var idx = Math.abs((len + index) % len) % len;
    var normalizedIdx = position === 'after' ? idx + 1 : idx;
    var copy = array.slice();
    copy.splice.apply(copy, __spreadArray([normalizedIdx, 0], __read(flatten(items)), false));
    return copy;
}
function flatten() {
    var values = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
    }
    return values.reduce(function (prev, item) { return prev.concat(item); }, []);
}

var hasOwn = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);
function move(arr, from, to) {
    var nextValue = arr.slice();
    var val = nextValue[from];
    nextValue.splice(from, 1);
    nextValue.splice(to, 0, val);
    return nextValue;
}
function findTargetIndex(array, pathSegment) {
    if (typeof pathSegment === 'number') {
        return pathSegment;
    }
    var index = findIndex(array, pathSegment);
    return index === -1 ? false : index;
}
function apply$3(value, patch) {
    var nextValue = value.slice(); // make a copy for internal mutation
    if (patch.path.length === 0) {
        // its directed to me
        if (patch.type === 'setIfMissing') {
            if (!Array.isArray(patch.value)) {
                // eslint-disable-line max-depth
                throw new Error('Cannot set value of an array to a non-array');
            }
            return value === undefined ? patch.value : value;
        }
        else if (patch.type === 'set') {
            if (!Array.isArray(patch.value)) {
                // eslint-disable-line max-depth
                throw new Error('Cannot set value of an array to a non-array');
            }
            return patch.value;
        }
        else if (patch.type === 'unset') {
            return undefined;
        }
        else if (patch.type === 'move') {
            if (!patch.value || !hasOwn(patch.value, 'from') || !hasOwn(patch.value, 'to')) {
                // eslint-disable-line max-depth
                throw new Error("Invalid value of 'move' patch. Expected a value with \"from\" and \"to\" indexes, instead got: ".concat(JSON.stringify(patch.value)));
            }
            return move(nextValue, patch.value.from, patch.value.to);
        }
        throw new Error("Invalid array operation: ".concat(patch.type));
    }
    var _a = __read(patch.path), head = _a[0], tail = _a.slice(1);
    var index = findTargetIndex(value, head);
    // If the given selector could not be found, return as-is
    if (index === false) {
        return nextValue;
    }
    if (tail.length === 0) {
        if (patch.type === 'insert') {
            var position = patch.position, items = patch.items;
            return insert(value, position, index, items);
        }
        else if (patch.type === 'unset') {
            if (typeof index !== 'number') {
                throw new Error("Expected array index to be a number, instead got \"".concat(index, "\""));
            }
            nextValue.splice(index, 1);
            return nextValue;
        }
    }
    // The patch is not directed to me
    nextValue[index] = _apply(nextValue[index], __assign(__assign({}, patch), { path: tail }));
    return nextValue;
}

function apply$2(value, patch) {
    var nextValue = clone(value);
    if (patch.path.length === 0) {
        // its directed to me
        if (patch.type === 'set') {
            if (!isObject(patch.value)) {
                // eslint-disable-line max-depth
                throw new Error('Cannot set value of an object to a non-object');
            }
            return patch.value;
        }
        else if (patch.type === 'unset') {
            return undefined;
        }
        else if (patch.type === 'setIfMissing') {
            // console.log('IS IT missing?', value)
            return value === undefined ? patch.value : value;
        }
        throw new Error("Invalid object operation: ".concat(patch.type));
    }
    // The patch is not directed to me
    var _a = __read(patch.path), head = _a[0], tail = _a.slice(1);
    if (typeof head !== 'string') {
        throw new Error("Expected field name to be a string, instad got: ".concat(head));
    }
    if (tail.length === 0 && patch.type === 'unset') {
        return omit(nextValue, head);
    }
    nextValue[head] = _apply(nextValue[head], __assign(__assign({}, patch), { path: tail }));
    return nextValue;
}

var OPERATIONS$1 = {
    replace: function (_currentValue, nextValue) {
        return nextValue;
    },
    set: function (_currentValue, nextValue) {
        return nextValue;
    },
    setIfMissing: function (currentValue, nextValue) {
        return currentValue === undefined ? nextValue : currentValue;
    },
    unset: function (_currentValue, _nextValue) {
        return undefined;
    },
    inc: function (currentValue, nextValue) {
        return currentValue + nextValue;
    },
    dec: function (currentValue, nextValue) {
        return currentValue - nextValue;
    },
};
var SUPPORTED_PATCH_TYPES$1 = Object.keys(OPERATIONS$1);
function apply$1(value, patch) {
    if (!SUPPORTED_PATCH_TYPES$1.includes(patch.type)) {
        throw new Error("Received patch of unsupported type: \"".concat(JSON.stringify(patch.type), "\" for primitives. This is most likely a bug."));
    }
    if (patch.path.length > 0) {
        throw new Error("Cannot apply deep operations on primitive values. Received patch with type \"".concat(patch.type, "\" and path \"").concat(patch.path
            .map(function (path) { return JSON.stringify(path); })
            .join('.'), " that targeted the value \"").concat(JSON.stringify(value), "\""));
    }
    return OPERATIONS$1[patch.type](value, patch.value);
}

// eslint-disable-next-line new-cap
var dmp$2 = new DMP.diff_match_patch();
var OPERATIONS = {
    replace: function (currentValue, nextValue) {
        return nextValue;
    },
    set: function (currentValue, nextValue) {
        return nextValue;
    },
    setIfMissing: function (currentValue, nextValue) {
        return currentValue === undefined ? nextValue : currentValue;
    },
    unset: function (currentValue, nextValue) {
        return undefined;
    },
    diffMatchPatch: function (currentValue, nextValue) {
        return dmp$2.patch_apply(dmp$2.patch_fromText(nextValue), currentValue)[0];
    },
};
var SUPPORTED_PATCH_TYPES = Object.keys(OPERATIONS);
function apply(value, patch) {
    if (!SUPPORTED_PATCH_TYPES.includes(patch.type)) {
        throw new Error("Received patch of unsupported type: \"".concat(JSON.stringify(patch.type), "\" for string. This is most likely a bug."));
    }
    if (patch.path.length > 0) {
        throw new Error("Cannot apply deep operations on string values. Received patch with type \"".concat(patch.type, "\" and path \"").concat(patch.path.join('.'), " that targeted the value \"").concat(JSON.stringify(value), "\""));
    }
    var func = OPERATIONS[patch.type];
    if (func) {
        return func(value, patch.value);
    }
    throw new Error('Unknown patch type');
}

function applyAll(value, patches) {
    return patches.reduce(_apply, value);
}
function applyPatch(value, patch) {
    if (Array.isArray(value)) {
        return apply$3(value, patch);
    }
    if (isString(value)) {
        return apply(value, patch);
    }
    if (isObject(value)) {
        return apply$2(value, patch);
    }
    return apply$1(value, patch);
}
function _apply(value, patch) {
    var res = applyPatch(value, patch);
    // console.log('applyPatch(%o, %o) : %o (noop? %o)', value, patch, res, value === res)
    return res;
}

var debug$f = debugWithName('operationToPatches');
// eslint-disable-next-line new-cap
var dmp$1 = new DMP.diff_match_patch();
function createPatchToOperations(portableTextFeatures, keyGenerator) {
    function diffMatchPatch(editor, patch) {
        var blockKey = findLastKey([patch.path[0]]);
        var blockIndex = editor.children.findIndex(function (node, indx) {
            return blockKey ? node._key === blockKey : indx === patch.path[0];
        });
        var block = editor.children[blockIndex];
        var parsed = dmp$1.patch_fromText(patch.value)[0];
        if (parsed && editor.isTextBlock(block)) {
            var childKey_1 = findLastKey([patch.path[2]]);
            var childIndex = block.children.findIndex(function (node, indx) {
                return childKey_1 ? node._key === childKey_1 : indx === patch.path[0];
            });
            var slatePath = [blockIndex, childIndex];
            var distance = parsed.length2 - parsed.length1;
            var point = {
                path: slatePath,
                offset: distance >= 0
                    ? (parsed.start1 || 0) + parsed.diffs[0][1].length
                    : (parsed.start2 || 0) + parsed.length2 - distance,
            };
            debug$f("DiffMatchPatch (".concat(distance < 0 ? 'remove' : 'insert', ") at ").concat(JSON.stringify(slatePath), "}: "), JSON.stringify(point, null, 2), JSON.stringify(parsed, null, 2));
            debugState(editor, 'before');
            var text = void 0;
            if (parsed.diffs[1]) {
                text = parsed.diffs[1][1];
            }
            else {
                text = parsed.diffs[0][1];
            }
            debug$f("Text: '".concat(text, "'"));
            if (distance >= 0) {
                editor.apply({
                    type: 'insert_text',
                    path: point.path,
                    offset: point.offset,
                    text: text,
                });
            }
            else {
                editor.apply({
                    type: 'remove_text',
                    path: point.path,
                    offset: point.offset - text.length,
                    text: text,
                });
            }
            debugState(editor, 'after');
            return true;
        }
        return false;
    }
    function insertPatch(editor, patch) {
        // Insert blocks
        if (patch.path.length === 1) {
            var items_1 = patch.items, position_1 = patch.position;
            var blocksToInsert = toSlateValue(items_1, { portableTextFeatures: portableTextFeatures }, KEY_TO_SLATE_ELEMENT.get(editor));
            var posKey_1 = findLastKey(patch.path);
            var index = editor.children.findIndex(function (node, indx) {
                return posKey_1 ? node._key === posKey_1 : indx === patch.path[0];
            });
            var normalizedIdx_1 = position_1 === 'after' ? index + 1 : index;
            debug$f("Inserting blocks at path [".concat(normalizedIdx_1, "]"));
            debugState(editor, 'before');
            Transforms.insertNodes(editor, blocksToInsert, { at: [normalizedIdx_1] });
            debugState(editor, 'after');
            return true;
        }
        var items = patch.items, position = patch.position;
        var posKey = findLastKey(patch.path);
        var blockIndex = editor.children.findIndex(function (node, indx) {
            return posKey ? node._key === posKey : indx === patch.path[0];
        });
        // Insert children
        var block = editor.children && blockIndex > -1 ? editor.children[blockIndex] : undefined;
        var childIndex = block &&
            block.children.findIndex(function (node, indx) {
                return isKeyedSegment(patch.path[2])
                    ? node._key === patch.path[2]._key
                    : indx === patch.path[2];
            });
        var childrenToInsert = block &&
            toSlateValue([__assign(__assign({}, block), { children: items })], { portableTextFeatures: portableTextFeatures }, KEY_TO_SLATE_ELEMENT.get(editor));
        var normalizedIdx = position === 'after' ? childIndex + 1 : childIndex;
        var targetPath = [blockIndex, normalizedIdx];
        debug$f("Inserting children at path ".concat(targetPath));
        debugState(editor, 'before');
        if (childrenToInsert && Element$1.isElement(childrenToInsert[0])) {
            Transforms.insertNodes(editor, childrenToInsert[0].children, { at: targetPath });
        }
        debugState(editor, 'after');
        return true;
    }
    function setPatch(editor, patch) {
        var blockIndex = editor.children.findIndex(function (node, indx) {
            return isKeyedSegment(patch.path[0])
                ? node._key === patch.path[0]._key
                : indx === patch.path[0];
        });
        debug$f('blockIndex', blockIndex);
        var block = blockIndex > -1 ? editor.children[blockIndex] : undefined;
        var childIndex = block &&
            block.children.findIndex(function (node, indx) {
                return isKeyedSegment(patch.path[2])
                    ? node._key === patch.path[2]._key
                    : indx === patch.path[2];
            });
        var value = patch.value;
        var targetPath = childIndex > -1 ? [blockIndex, childIndex] : [blockIndex];
        if (typeof patch.path[3] === 'string') {
            value = {};
            value[patch.path[3]] = patch.value;
        }
        var isTextBlock = portableTextFeatures.types.block.name === (block === null || block === void 0 ? void 0 : block._type);
        if (isTextBlock) {
            debug$f("Setting nodes at ".concat(JSON.stringify(patch.path), " - ").concat(JSON.stringify(targetPath)));
            debug$f('Value to set', JSON.stringify(value, null, 2));
            debugState(editor, 'before');
            if (targetPath.length === 1) {
                debug$f('Setting block property');
                var _a = value, children = _a.children, nextRest = __rest(_a, ["children"]);
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                var _b = block || { children: undefined }, prevRest = __rest(_b, ["children"]);
                editor.apply({
                    type: 'set_node',
                    path: targetPath,
                    properties: __assign({}, prevRest),
                    newProperties: nextRest,
                });
                if (block && Element$1.isElement(block)) {
                    block.children.forEach(function (c, cIndex) {
                        editor.apply({
                            type: 'remove_node',
                            path: targetPath.concat(cIndex),
                            node: c,
                        });
                    });
                }
                if (Array.isArray(children)) {
                    children.forEach(function (c, cIndex) {
                        editor.apply({
                            type: 'insert_node',
                            path: targetPath.concat(cIndex),
                            node: c,
                        });
                    });
                }
            }
            else if (Text.isText(value)) {
                debug$f('Setting text property');
                var prevSel = editor.selection && __assign({}, editor.selection);
                editor.apply({
                    type: 'remove_text',
                    path: targetPath,
                    offset: 0,
                    text: block === null || block === void 0 ? void 0 : block.children[childIndex].text,
                });
                editor.apply({
                    type: 'insert_text',
                    path: targetPath,
                    offset: 0,
                    text: value.text,
                });
                var onSamePath = prevSel && isEqual(prevSel.focus.path, targetPath);
                // const onSameText =
                //   editor.selection &&
                //   editor.selection.focus.path[0] === blockIndex &&
                //   patch.path[3] === 'text'
                if (onSamePath) {
                    debug$f('On same path, restoring previous selection');
                    Transforms.select(editor, prevSel);
                }
                //  else if (onSameText) {
                //   debug('Adjusting for inserted text')
                //   const newOffset = typeof patch.value === 'string' ? patch.value.length : 0
                //   const point = {path: targetPath, offset: newOffset}
                //   Transforms.select(editor, {focus: point, anchor: point})
                // }
            }
            else {
                debug$f('Setting non-text property');
                editor.apply({
                    type: 'set_node',
                    path: targetPath,
                    properties: {},
                    newProperties: value,
                });
            }
            debugState(editor, 'after');
            return true;
        }
        // If this is a object block, just set the whole block
        else if (!isTextBlock && block) {
            var newVal = applyAll([block.value], [patch])[0];
            Transforms.setNodes(editor, __assign(__assign({}, block), { value: newVal }), { at: [blockIndex] });
            return true;
        }
        return false;
    }
    function unsetPatch(editor, patch, previousPatch) {
        var _a;
        // Value
        if (patch.path.length === 0) {
            debug$f("Removing everything");
            debugState(editor, 'before');
            Transforms.deselect(editor);
            editor.children.forEach(function (c, i) {
                Transforms.removeNodes(editor, { at: [i] });
            });
            debugState(editor, 'after');
            return true;
        }
        // Single blocks
        if (patch.path.length === 1) {
            var lastKey_1 = findLastKey(patch.path);
            var index = editor.children.findIndex(function (node, indx) {
                return lastKey_1 ? node._key === lastKey_1 : indx === patch.path[0];
            });
            debug$f("Removing block at path [".concat(index, "]"));
            debugState(editor, 'before');
            if (editor.selection &&
                editor.selection.focus.path[0] === index &&
                editor.children[index - 1]) {
                var point = { path: [Math.max(editor.selection.focus.path[0] - 1, 0)], offset: 0 };
                Transforms.select(editor, { focus: point, anchor: point });
                Transforms.move(editor, { unit: 'line' });
            }
            Transforms.removeNodes(editor, { at: [index] });
            debugState(editor, 'after');
            return true;
        }
        var blockIndex = editor.children.findIndex(function (node, indx) {
            return isKeyedSegment(patch.path[0])
                ? node._key === patch.path[0]._key
                : indx === patch.path[0];
        });
        var block = blockIndex > -1 ? editor.children[blockIndex] : undefined;
        var isTextBlock = portableTextFeatures.types.block.name === (block === null || block === void 0 ? void 0 : block._type);
        // Unset on text block children
        if (isTextBlock && patch.path[1] === 'children' && patch.path.length === 3) {
            var childIndex = block &&
                block.children.findIndex(function (node, indx) {
                    return isKeyedSegment(patch.path[2])
                        ? node._key === patch.path[2]._key
                        : indx === patch.path[2];
                });
            var targetPath = [blockIndex, childIndex];
            var prevSel = editor.selection && __assign({}, editor.selection);
            var onSamePath = isEqual((_a = editor.selection) === null || _a === void 0 ? void 0 : _a.focus.path, targetPath);
            debug$f("Removing child at path ".concat(JSON.stringify(targetPath)));
            debugState(editor, 'before');
            if (prevSel && onSamePath && editor.isTextBlock(block)) {
                var needToAdjust = childIndex >= prevSel.focus.path[1];
                if (needToAdjust) {
                    var isMergeUnset = (previousPatch === null || previousPatch === void 0 ? void 0 : previousPatch.type) === 'set' &&
                        previousPatch.path[3] === 'text' &&
                        typeof previousPatch.value === 'string' &&
                        isEqual(previousPatch.value.slice(-block.children[childIndex].text.length), block.children[childIndex].text);
                    if (isMergeUnset) {
                        debug$f('Adjusting selection for merging of nodes');
                        prevSel.focus = __assign({}, prevSel.focus);
                        prevSel.focus.path = [targetPath[0], Math.max(targetPath[1] - 1, 0)];
                        prevSel.focus.offset =
                            block.children[Math.max(childIndex - 1, 0)].text.length -
                                block.children[childIndex].text.length +
                                prevSel.focus.offset;
                        prevSel.anchor = prevSel.focus;
                        Transforms.select(editor, prevSel);
                        Transforms.removeNodes(editor, { at: [blockIndex, childIndex] });
                        debugState(editor, 'after');
                        return true;
                    }
                }
            }
            Transforms.removeNodes(editor, { at: [blockIndex, childIndex] });
            debugState(editor, 'after');
            return true;
        }
        // Inside block objects - patch block and set it again
        if (!isTextBlock && block) {
            var newBlock = applyAll([block], [patch])[0];
            Transforms.setNodes(editor, newBlock, { at: [blockIndex] });
            return true;
        }
        return false;
    }
    var previousPatch;
    return function (editor, patch) {
        var changed = false;
        debug$f('\n\nNEW PATCH =============================================================');
        debug$f(JSON.stringify(patch, null, 2));
        try {
            switch (patch.type) {
                case 'insert':
                    changed = insertPatch(editor, patch);
                    break;
                case 'unset':
                    changed = unsetPatch(editor, patch, previousPatch);
                    break;
                case 'set':
                    changed = setPatch(editor, patch);
                    break;
                case 'diffMatchPatch':
                    changed = diffMatchPatch(editor, patch);
                    break;
                default:
                    debug$f('Unhandled patch', patch.type);
            }
        }
        catch (err) {
            console.error(err);
        }
        previousPatch = patch;
        return changed;
    };
}
function isKeyedSegment(segment) {
    return typeof segment === 'object' && '_key' in segment;
}
// Helper function to find the last part of a patch path that has a known key
function findLastKey(path) {
    var key = null;
    path
        .concat('')
        .reverse()
        .forEach(function (part) {
        if (isKeyedSegment(part)) {
            key = part._key;
        }
    });
    return key;
}
function debugState(editor, stateName) {
    debug$f("Children ".concat(stateName, ":"), JSON.stringify(editor.children, null, 2));
    debug$f("Selection ".concat(stateName, ": "), JSON.stringify(editor.selection, null, 2));
}

/* eslint-disable complexity */
var debug$e = debugWithName('plugin:withUndoRedo');
// eslint-disable-next-line new-cap
var dmp = new DMP.diff_match_patch();
var SAVING = new WeakMap();
var MERGING = new WeakMap();
var UNDO_STEP_LIMIT = 300;
var isMerging = function (editor) {
    return MERGING.get(editor);
};
var isSaving = function (editor) {
    if (!isPatching(editor)) {
        return false;
    }
    return SAVING.get(editor);
};
function createWithUndoRedo(incomingPatches$) {
    // TODO: unsubscribe to this
    // Subscribe to incoming patches
    var cleanupFn = function () { return undefined; };
    var incomingPatches = [];
    if (incomingPatches$) {
        debug$e('Subscribing to patches');
        var sub_1 = incomingPatches$.subscribe(function (_a) {
            var patches = _a.patches;
            patches.forEach(function (patch) {
                if (patch.origin !== 'local') {
                    incomingPatches.push({ patch: patch, time: new Date() });
                }
            });
        });
        cleanupFn = function () {
            debug$e('Unsubscribing to patches');
            sub_1.unsubscribe();
        };
    }
    return [
        function (editor) {
            editor.history = { undos: [], redos: [] };
            var apply = editor.apply;
            // Apply function for merging and saving local history inspired from 'slate-history' by Ian Storm Taylor
            editor.apply = function (op) {
                if (editor.readOnly) {
                    apply(op);
                    return;
                }
                var operations = editor.operations, history = editor.history;
                var undos = history.undos;
                var step = undos[undos.length - 1];
                var lastOp = step && step.operations && step.operations[step.operations.length - 1];
                var overwrite = shouldOverwrite(op, lastOp);
                var save = isSaving(editor);
                var merge = isMerging(editor);
                if (save == null) {
                    save = shouldSave(op);
                }
                if (save) {
                    if (merge == null) {
                        if (step == null) {
                            merge = false;
                            // eslint-disable-next-line no-negated-condition
                        }
                        else if (operations.length !== 0) {
                            merge = true;
                        }
                        else {
                            merge = shouldMerge(op, lastOp) || overwrite;
                        }
                    }
                    if (step && merge) {
                        if (overwrite) {
                            step.operations.pop();
                        }
                        step.operations.push(op);
                    }
                    else {
                        var stp = {
                            operations: __spreadArray(__spreadArray([], __read((editor.selection === null ? [] : [createSelectOperation(editor)])), false), [
                                op,
                            ], false),
                            timestamp: new Date(),
                        };
                        undos.push(stp);
                        debug$e('Created new undo step', step);
                    }
                    while (undos.length > UNDO_STEP_LIMIT) {
                        undos.shift();
                    }
                    if (shouldClear(op)) {
                        history.redos = [];
                    }
                }
                apply(op);
            };
            editor.undo = function () {
                if (editor.readOnly) {
                    return;
                }
                var undos = editor.history.undos;
                if (undos.length > 0) {
                    var step_1 = undos[undos.length - 1];
                    debug$e('Undoing', step_1);
                    if (step_1.operations.length > 0) {
                        var otherPatches = __spreadArray([], __read(incomingPatches.filter(function (item) { return item.time >= step_1.timestamp; })), false);
                        var transformedOperations_1 = step_1.operations;
                        otherPatches.forEach(function (item) {
                            transformedOperations_1 = flatten$1(transformedOperations_1.map(function (op) { return transformOperation(editor, item.patch, op); }));
                        });
                        withoutSaving(editor, function () {
                            Editor.withoutNormalizing(editor, function () {
                                transformedOperations_1
                                    .map(Operation.inverse)
                                    .reverse()
                                    .forEach(function (op) {
                                    // Try this as the document could be changed from the outside,
                                    // and sometimes we can't perform the undo operation on the current doc.
                                    try {
                                        editor.apply(op);
                                    }
                                    catch (err) {
                                        debug$e('Could not perform undo step', err);
                                        editor.history.redos.push(step_1);
                                        editor.history.undos.pop();
                                    }
                                });
                            });
                        });
                    }
                    editor.history.redos.push(step_1);
                    editor.history.undos.pop();
                    editor.onChange();
                }
            };
            editor.redo = function () {
                if (editor.readOnly) {
                    return;
                }
                var redos = editor.history.redos;
                if (redos.length > 0) {
                    var step_2 = redos[redos.length - 1];
                    debug$e('Redoing', step_2);
                    if (step_2.operations.length > 0) {
                        var otherPatches = incomingPatches.filter(function (item) { return item.time > step_2.timestamp; });
                        var transformedOperations_2 = step_2.operations;
                        otherPatches.forEach(function (item) {
                            transformedOperations_2 = flatten$1(transformedOperations_2.map(function (op) { return transformOperation(editor, item.patch, op); }));
                        });
                        withoutSaving(editor, function () {
                            Editor.withoutNormalizing(editor, function () {
                                transformedOperations_2.forEach(function (op) {
                                    try {
                                        editor.apply(op);
                                    }
                                    catch (err) {
                                        debug$e('Could not perform redo step', err);
                                        editor.history.undos.push(step_2);
                                        editor.history.redos.pop();
                                    }
                                });
                            });
                        });
                    }
                    editor.history.undos.push(step_2);
                    editor.history.redos.pop();
                    editor.onChange();
                }
            };
            // Plugin return
            return editor;
        },
        cleanupFn,
    ];
}
// This will adjust the user selection according to patcehes done by others.
// TODO: complete all necessary steps of the algorithm and write tests.
// eslint-disable-next-line max-statements
function transformOperation(editor, patch, operation) {
    // debug(`Rebasing selection for patch ${patch.type} against operation ${operation.type}`)
    var e_1, _a, e_2, _b;
    var transformedOperation = __assign({}, operation);
    if (patch.type === 'insert' && patch.path.length === 1) {
        return [adjustBlockPath(editor, patch, operation, patch.items.length)];
    }
    if (patch.type === 'unset' && patch.path.length === 1) {
        return [adjustBlockPath(editor, patch, operation, -1)];
    }
    // Someone reset the whole value
    if (patch.type === 'unset' && patch.path.length === 0) {
        debug$e("Adjusting selection for unset everything patch and ".concat(operation.type, " operation"));
        return [operation];
    }
    if (patch.type === 'diffMatchPatch') {
        var blockIndex = editor.children.findIndex(function (blk) { return isEqual({ _key: blk._key }, patch.path[0]); });
        var block = editor.children[blockIndex];
        if (Element$1.isElement(block) && Array.isArray(block.children)) {
            var childIndex = block.children.findIndex(function (child) {
                return isEqual({ _key: child._key }, patch.path[2]);
            });
            var parsed = dmp.patch_fromText(patch.value)[0];
            if (!parsed) {
                debug$e('Could not parse diffMatchPatch', patch);
                return [operation];
            }
            var distance = parsed.length2 - parsed.length1;
            var patchIsRemovingText = parsed.diffs.some(function (diff) { return diff[0] === -1; });
            if (operation.type === 'split_node' && operation.path.length > 1) {
                var splitOperation = transformedOperation;
                if (patchIsRemovingText) {
                    splitOperation.position -= distance;
                }
                else {
                    splitOperation.position += distance;
                }
                return [splitOperation];
            }
            if ((operation.type === 'insert_text' || operation.type === 'remove_text') &&
                Path.isPath(operation.path) &&
                operation.path[0] !== undefined &&
                operation.path[0] === blockIndex &&
                operation.path[1] === childIndex) {
                if (operation.type === 'insert_text') {
                    var insertOffset = 0;
                    try {
                        for (var _c = __values(parsed.diffs), _d = _c.next(); !_d.done; _d = _c.next()) {
                            var diff = _d.value;
                            if (diff[0] === 0) {
                                insertOffset = diff[1].length;
                            }
                            if (diff[0] === 1) {
                                break;
                            }
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    if (parsed.start1 !== null && insertOffset + parsed.start1 <= operation.offset) {
                        var insertTextOperation = transformedOperation;
                        insertTextOperation.offset += distance;
                        transformedOperation = insertTextOperation;
                    }
                    // TODO: deal with overlapping ranges
                    return [transformedOperation];
                }
                if (operation.type === 'remove_text') {
                    var insertOffset = 0;
                    try {
                        for (var _e = __values(parsed.diffs), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var diff = _f.value;
                            if (diff[0] === 0) {
                                insertOffset = diff[1].length;
                            }
                            if (diff[0] === -1) {
                                break;
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                    if (parsed.start1 !== null && insertOffset + parsed.start1 <= operation.offset) {
                        var removeTextOperation = transformedOperation;
                        removeTextOperation.offset -= distance;
                        transformedOperation = removeTextOperation;
                    }
                    return [transformedOperation];
                }
            }
            // // Selection operations with diffPatchMatch
            // if (operation.type === 'set_selection') {
            //   const newProperties = transformedOperation.newProperties
            //   if (newProperties && patchIsRemovingText) {
            //     newProperties.offset = newProperties.offset - distance
            //   } else if (newProperties) {
            //     newProperties.offset = newProperties.offset + distance
            //   }
            //   return [newProperties ? {...transformedOperation, newProperties} : transformedOperation]
            // }
        }
        // TODO: transform this?
        // if (operation.type === 'set_selection' && patch.type !== 'diffMatchPatch') {
        //   console.log('set_selection other', JSON.stringify(patch))
        // }
    }
    return [operation];
}
function adjustBlockPath(editor, patch, operation, level) {
    var myIndex = editor.children.findIndex(function (blk) { return isEqual({ _key: blk._key }, patch.path[0]); });
    if (myIndex >= 0 &&
        operation.type !== 'set_selection' &&
        Array.isArray(operation.path) &&
        operation.path[0] !== undefined &&
        operation.path[0] >= myIndex + level) {
        var transformedOperation = __assign({}, operation);
        var newPath = __spreadArray([operation.path[0] + level], __read(operation.path.slice(1)), false);
        debug$e("Adjusting ".concat(operation.type, " for block ").concat(patch.type), operation.path, newPath);
        transformedOperation.path = newPath;
        return transformedOperation;
    }
    return operation;
}
// Helper functions for editor.apply above
var shouldMerge = function (op, prev) {
    if (op.type === 'set_selection') {
        return true;
    }
    // Text input
    if (prev &&
        op.type === 'insert_text' &&
        prev.type === 'insert_text' &&
        op.offset === prev.offset + prev.text.length &&
        Path.equals(op.path, prev.path) &&
        op.text !== ' ' // Tokenize between words
    ) {
        return true;
    }
    // Text deletion
    if (prev &&
        op.type === 'remove_text' &&
        prev.type === 'remove_text' &&
        op.offset + op.text.length === prev.offset &&
        Path.equals(op.path, prev.path)) {
        return true;
    }
    // Don't merge
    return false;
};
var shouldSave = function (op, prev) {
    if (op.type === 'set_selection' && op.newProperties === null) {
        return false;
    }
    return true;
};
var shouldOverwrite = function (op, prev) {
    if (prev && op.type === 'set_selection' && prev.type === 'set_selection') {
        return true;
    }
    return false;
};
var shouldClear = function (op) {
    if (op.type === 'set_selection') {
        return false;
    }
    return true;
};
function withoutSaving(editor, fn) {
    var prev = isSaving(editor);
    SAVING.set(editor, false);
    fn();
    SAVING.set(editor, prev);
}
function createSelectOperation(editor) {
    return {
        type: 'set_selection',
        properties: __assign({}, editor.selection),
        newProperties: __assign({}, editor.selection),
    };
}

var debug$d = debugWithName('plugin:withPatches');
function createWithPatches(_a) {
    var patchFunctions = _a.patchFunctions, change$ = _a.change$, portableTextFeatures = _a.portableTextFeatures, syncValue = _a.syncValue, incomingPatches$ = _a.incomingPatches$;
    // The previous editor children are needed to figure out the _key of deleted nodes
    // The editor.children would no longer contain that information if the node is already deleted.
    var previousChildren;
    var patchToOperations = createPatchToOperations(portableTextFeatures);
    var patchSubscription;
    var cleanupFn = function () {
        if (patchSubscription) {
            debug$d('Unsubscribing to patches');
            patchSubscription.unsubscribe();
        }
    };
    return [
        function withPatches(editor) {
            PATCHING.set(editor, true);
            previousChildren = __spreadArray([], __read(editor.children), false);
            // Sync the with props.value in PortableTextEditor after we have processed batches of incoming patches.
            // This is only for consistency checking against the props.value, so it can be debounced without problems.
            var syncValueAfterIncomingPatches = debounce(function () { return syncValue(); }, 100, {
                trailing: true,
                leading: false,
            });
            // Subscribe and deal with incoming patches
            if (incomingPatches$) {
                debug$d('Subscribing to patches');
                patchSubscription = incomingPatches$.subscribe(function (_a) {
                    var patches = _a.patches, snapshot = _a.snapshot;
                    debug$d('Incoming patches', patches);
                    var remotePatches = patches.filter(function (p) { return p.origin !== 'local'; });
                    if (remotePatches.length !== 0) {
                        Editor.withoutNormalizing(editor, function () {
                            remotePatches.forEach(function (patch) {
                                debug$d("Handling remote patch ".concat(JSON.stringify(patch)));
                                withoutPatching(editor, function () {
                                    withoutSaving(editor, function () {
                                        withPreserveKeys(editor, function () {
                                            try {
                                                patchToOperations(editor, patch, patches, snapshot);
                                            }
                                            catch (err) {
                                                debug$d('Got error trying to create operations from patch');
                                                console.error(err);
                                            }
                                        });
                                    });
                                });
                            });
                        });
                    }
                    if (patches.length > 0) {
                        syncValueAfterIncomingPatches();
                    }
                });
            }
            var apply = editor.apply;
            editor.apply = function (operation) {
                if (editor.readOnly) {
                    apply(operation);
                    return editor;
                }
                var patches = [];
                // Update previous children here before we apply
                previousChildren = editor.children;
                var editorWasEmpty = isEqualToEmptyEditor(previousChildren, portableTextFeatures);
                // Apply the operation
                apply(operation);
                var editorIsEmpty = isEqualToEmptyEditor(editor.children, portableTextFeatures);
                if (!isPatching(editor)) {
                    debug$d("Editor is not producing patch for operation ".concat(operation.type), operation);
                    return editor;
                }
                // Make sure the actual value is an array, and then insert the placeholder block into it
                // before we produce any other patches that will target that block.
                if (editorWasEmpty && operation.type !== 'set_selection') {
                    patches.push(setIfMissing([], []));
                    previousChildren.forEach(function (c, index) {
                        patches.push(insert$1(fromSlateValue([c], portableTextFeatures.types.block.name), 'before', [index]));
                    });
                }
                switch (operation.type) {
                    case 'insert_text':
                        patches = __spreadArray(__spreadArray([], __read(patches), false), __read(patchFunctions.insertTextPatch(editor, operation, previousChildren)), false);
                        break;
                    case 'remove_text':
                        patches = __spreadArray(__spreadArray([], __read(patches), false), __read(patchFunctions.removeTextPatch(editor, operation, previousChildren)), false);
                        break;
                    case 'remove_node':
                        patches = __spreadArray(__spreadArray([], __read(patches), false), __read(patchFunctions.removeNodePatch(editor, operation, previousChildren)), false);
                        break;
                    case 'split_node':
                        patches = __spreadArray(__spreadArray([], __read(patches), false), __read(patchFunctions.splitNodePatch(editor, operation, previousChildren)), false);
                        break;
                    case 'insert_node':
                        patches = __spreadArray(__spreadArray([], __read(patches), false), __read(patchFunctions.insertNodePatch(editor, operation, previousChildren)), false);
                        break;
                    case 'set_node':
                        patches = __spreadArray(__spreadArray([], __read(patches), false), __read(patchFunctions.setNodePatch(editor, operation, previousChildren)), false);
                        break;
                    case 'merge_node':
                        patches = __spreadArray(__spreadArray([], __read(patches), false), __read(patchFunctions.mergeNodePatch(editor, operation, previousChildren)), false);
                        break;
                    case 'move_node':
                        patches = __spreadArray(__spreadArray([], __read(patches), false), __read(patchFunctions.moveNodePatch(editor, operation, previousChildren)), false);
                        break;
                    // Do nothing
                }
                // Unset the value if the operation made the editor empty
                if (editorIsEmpty && ['remove_text', 'remove_node'].includes(operation.type)) {
                    patches = __spreadArray(__spreadArray([], __read(patches), false), [unset([])], false);
                    change$.next({
                        type: 'unset',
                        previousValue: fromSlateValue(previousChildren, portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)),
                    });
                }
                // Emit all patches
                if (patches.length > 0) {
                    patches.forEach(function (patch) {
                        change$.next({
                            type: 'patch',
                            patch: __assign(__assign({}, patch), { origin: 'local' }),
                        });
                    });
                }
                return editor;
            };
            return editor;
        },
        cleanupFn,
    ];
}

var debug$c = debugWithName('plugin:withPlaceholderBlock');
/**
 * Keep a "placeholder" block present when the editor is empty
 *
 */
function createWithPlaceholderBlock(_a) {
    var portableTextFeatures = _a.portableTextFeatures, keyGenerator = _a.keyGenerator;
    return function withPlaceholderBlock(editor) {
        editor.createPlaceholderBlock = function () {
            return {
                _type: portableTextFeatures.types.block.name,
                _key: keyGenerator(),
                style: portableTextFeatures.styles[0].value,
                markDefs: [],
                children: [
                    {
                        _type: 'span',
                        _key: keyGenerator(),
                        text: '',
                        marks: [],
                    },
                ],
            };
        };
        var onChange = editor.onChange;
        // Make sure there's a placeholder block present if the editor's children become empty
        editor.onChange = function () {
            onChange();
            if (editor.children.length === 0) {
                withoutPatching(editor, function () {
                    withoutSaving(editor, function () {
                        debug$c('Inserting placeholder block');
                        Transforms.deselect(editor);
                        Transforms.insertNodes(editor, editor.createPlaceholderBlock(), {
                            at: [0],
                        });
                        Transforms.select(editor, {
                            focus: { path: [0, 0], offset: 0 },
                            anchor: { path: [0, 0], offset: 0 },
                        });
                        editor.onChange();
                    });
                });
            }
        };
        return editor;
    };
}

var debug$b = debugWithName('plugin:withPortableTextBlockStyle');
function createWithPortableTextBlockStyle(portableTextFeatures, change$) {
    var defaultStyle = portableTextFeatures.styles[0].value;
    return function withPortableTextBlockStyle(editor) {
        // Extend Slate's default normalization to reset split node to normal style
        // if there is no text at the right end of the split.
        var normalizeNode = editor.normalizeNode;
        editor.normalizeNode = function (nodeEntry) {
            var e_1, _a;
            normalizeNode(nodeEntry);
            var _b = __read(nodeEntry, 2), path = _b[1];
            try {
                for (var _c = __values(editor.operations), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var op = _d.value;
                    if (op.type === 'split_node' &&
                        op.path.length === 1 &&
                        editor.isTextBlock(op.properties) &&
                        op.properties.style !== defaultStyle &&
                        op.path[0] === path[0] &&
                        !Path.equals(path, op.path)) {
                        var _e = __read(Editor.node(editor, [op.path[0] + 1, 0]), 1), child = _e[0];
                        if (Text.isText(child) && child.text === '') {
                            debug$b("Normalizing split node to ".concat(defaultStyle, " style"), op);
                            Transforms.setNodes(editor, { style: defaultStyle }, { at: [op.path[0] + 1], voids: false });
                            break;
                        }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        editor.pteHasBlockStyle = function (style) {
            if (!editor.selection) {
                return false;
            }
            var selectedBlocks = __spreadArray([], __read(Editor.nodes(editor, {
                at: editor.selection,
                match: function (node) { return editor.isTextBlock(node) && node.style === style; },
            })), false);
            if (selectedBlocks.length > 0) {
                return true;
            }
            return false;
        };
        editor.pteToggleBlockStyle = function (blockStyle) {
            if (!editor.selection) {
                return;
            }
            var selectedBlocks = __spreadArray([], __read(Editor.nodes(editor, {
                at: editor.selection,
                match: function (node) {
                    return Element$1.isElement(node) && node._type === portableTextFeatures.types.block.name;
                },
            })), false);
            selectedBlocks.forEach(function (_a) {
                var _b = __read(_a, 2), node = _b[0], path = _b[1];
                if (editor.isTextBlock(node) && node.style === blockStyle) {
                    debug$b("Unsetting block style '".concat(blockStyle, "'"));
                    Transforms.setNodes(editor, __assign(__assign({}, node), { style: defaultStyle }), {
                        at: path,
                    });
                }
                else {
                    if (blockStyle) {
                        debug$b("Setting style '".concat(blockStyle, "'"));
                    }
                    else {
                        debug$b('Setting default style', defaultStyle);
                    }
                    Transforms.setNodes(editor, __assign(__assign({}, node), { style: blockStyle || defaultStyle }), { at: path });
                }
            });
            // Emit a new selection here (though it might be the same).
            // Toolbars and similar on the outside may rely on selection changes to update themselves.
            change$.next({
                type: 'selection',
                selection: toPortableTextRange(fromSlateValue(editor.children, portableTextFeatures.types.block.name), editor.selection, portableTextFeatures),
            });
            editor.onChange();
        };
        return editor;
    };
}

var debug$a = debugWithName('plugin:withPortableTextLists');
var MAX_LIST_LEVEL = 10;
function createWithPortableTextLists(portableTextFeatures) {
    return function withPortableTextLists(editor) {
        editor.pteToggleListItem = function (listItemStyle) {
            var isActive = editor.pteHasListStyle(listItemStyle);
            if (isActive) {
                debug$a("Remove list item '".concat(listItemStyle, "'"));
                editor.pteUnsetListItem(listItemStyle);
            }
            else {
                debug$a("Add list item '".concat(listItemStyle, "'"));
                editor.pteSetListItem(listItemStyle);
            }
        };
        editor.pteUnsetListItem = function (listItemStyle) {
            if (!editor.selection) {
                return;
            }
            var selectedBlocks = __spreadArray([], __read(Editor.nodes(editor, {
                at: editor.selection,
                match: function (node) {
                    return Element$1.isElement(node) && node._type === portableTextFeatures.types.block.name;
                },
            })), false);
            selectedBlocks.forEach(function (_a) {
                var _b = __read(_a, 2), node = _b[0], path = _b[1];
                if (editor.isListBlock(node)) {
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    var rest = __rest(node, ["listItem", "level"]);
                    var newNode = __assign(__assign({}, rest), { listItem: undefined, level: undefined });
                    debug$a("Unsetting list '".concat(listItemStyle, "'"));
                    Transforms.setNodes(editor, newNode, { at: path });
                }
            });
        };
        editor.pteSetListItem = function (listItemStyle) {
            if (!editor.selection) {
                return;
            }
            var selectedBlocks = __spreadArray([], __read(Editor.nodes(editor, {
                at: editor.selection,
                match: function (node) { return editor.isTextBlock(node); },
            })), false);
            selectedBlocks.forEach(function (_a) {
                var _b = __read(_a, 2), node = _b[0], path = _b[1];
                debug$a("Setting list '".concat(listItemStyle, "'"));
                Transforms.setNodes(editor, __assign(__assign({}, node), { level: 1, listItem: listItemStyle ||
                        (portableTextFeatures.lists[0] && portableTextFeatures.lists[0].value) }), { at: path });
            });
        };
        editor.pteEndList = function () {
            if (!editor.selection) {
                return false;
            }
            var selectedBlocks = __spreadArray([], __read(Editor.nodes(editor, {
                at: editor.selection,
                match: function (node) {
                    return Element$1.isElement(node) &&
                        editor.isListBlock(node) &&
                        node.children.length === 1 &&
                        Text.isText(node.children[0]) &&
                        node.children[0].text === '';
                },
            })), false);
            if (selectedBlocks.length === 0) {
                return false;
            }
            selectedBlocks.forEach(function (_a) {
                var _b = __read(_a, 2), node = _b[0], path = _b[1];
                if (Element$1.isElement(node)) {
                    debug$a('Unset list');
                    Transforms.setNodes(editor, 
                    // @todo: fix typing
                    __assign(__assign({}, node), { level: undefined, listItem: undefined }), { at: path });
                }
            });
            return true; // Note: we are exiting the plugin chain by not returning editor (or hotkey plugin 'enter' will fire)
        };
        editor.pteIncrementBlockLevels = function (reverse) {
            if (!editor.selection) {
                return false;
            }
            var selectedBlocks = __spreadArray([], __read(Editor.nodes(editor, {
                at: editor.selection,
                match: function (node) { return !!editor.isListBlock(node); },
            })), false);
            if (selectedBlocks.length === 0) {
                return false;
            }
            selectedBlocks.forEach(function (_a) {
                var _b = __read(_a, 2), node = _b[0], path = _b[1];
                if (editor.isListBlock(node)) {
                    var level = node.level || 1;
                    if (reverse) {
                        level--;
                        debug$a('Decrementing list level', Math.min(MAX_LIST_LEVEL, Math.max(1, level)));
                    }
                    else {
                        level++;
                        debug$a('Incrementing list level', Math.min(MAX_LIST_LEVEL, Math.max(1, level)));
                    }
                    Transforms.setNodes(editor, { level: Math.min(MAX_LIST_LEVEL, Math.max(1, level)) }, { at: path });
                }
            });
            return true;
        };
        editor.pteHasListStyle = function (listStyle) {
            if (!editor.selection) {
                return false;
            }
            var selectedBlocks = __spreadArray([], __read(Editor.nodes(editor, {
                at: editor.selection,
                match: function (node) { return editor.isListBlock(node) && node.listItem === listStyle; },
            })), false);
            if (selectedBlocks.length > 0) {
                return true;
            }
            return false;
        };
        return editor;
    };
}

/* eslint-disable complexity */
var debug$9 = debugWithName('plugin:withPortableTextMarkModel');
function createWithPortableTextMarkModel(portableTextFeatures, keyGenerator) {
    return function withPortableTextMarkModel(editor) {
        var apply = editor.apply, normalizeNode = editor.normalizeNode;
        var decorators = portableTextFeatures.decorators.map(function (t) { return t.value; });
        // Extend Slate's default normalization. Merge spans with same set of .marks when doing merge_node operations, and clean up markDefs / marks
        editor.normalizeNode = function (nodeEntry) {
            var e_1, _a;
            normalizeNode(nodeEntry);
            if (editor.operations.some(function (op) {
                return [
                    'insert_node',
                    'insert_text',
                    'merge_node',
                    'remove_node',
                    'remove_text',
                    'set_node',
                ].includes(op.type);
            })) {
                mergeSpans(editor);
            }
            var _b = __read(nodeEntry, 2), node = _b[0], path = _b[1];
            var isSpan = Text.isText(node) && node._type === portableTextFeatures.types.span.name;
            var isTextBlock = editor.isTextBlock(node);
            if (isSpan || isTextBlock) {
                if (!isTextBlock && !Array.isArray(node.marks)) {
                    debug$9('Adding .marks to span node');
                    Transforms.setNodes(editor, { marks: [] }, { at: path });
                    editor.onChange();
                }
                try {
                    for (var _c = __values(editor.operations), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var op = _d.value;
                        // Make sure markDefs are copied over when merging two blocks.
                        if (op.type === 'merge_node' &&
                            op.path.length === 1 &&
                            'markDefs' in op.properties &&
                            op.properties._type === portableTextFeatures.types.block.name &&
                            Array.isArray(op.properties.markDefs) &&
                            op.properties.markDefs.length > 0 &&
                            op.path[0] - 1 >= 0) {
                            var _e = __read(Editor.node(editor, [op.path[0] - 1]), 2), targetBlock = _e[0], targetPath = _e[1];
                            debug$9("Copying markDefs over to merged block", op);
                            if (editor.isTextBlock(targetBlock)) {
                                var oldDefs = (Array.isArray(targetBlock.markDefs) && targetBlock.markDefs) || [];
                                var newMarkDefs = uniq(__spreadArray(__spreadArray([], __read(oldDefs), false), __read(op.properties.markDefs), false));
                                var isNormalized = isEqual(newMarkDefs, targetBlock.markDefs);
                                // eslint-disable-next-line max-depth
                                if (!isNormalized) {
                                    Transforms.setNodes(editor, { markDefs: newMarkDefs }, { at: targetPath, voids: false });
                                    editor.onChange();
                                }
                            }
                        }
                        // Make sure markDefs are copied over to new block when splitting a block.
                        if (op.type === 'split_node' &&
                            op.path.length === 1 &&
                            Element$1.isElementProps(op.properties) &&
                            op.properties._type === portableTextFeatures.types.block.name &&
                            'markDefs' in op.properties &&
                            Array.isArray(op.properties.markDefs) &&
                            op.properties.markDefs.length > 0 &&
                            op.path[0] + 1 < editor.children.length) {
                            var _f = __read(Editor.node(editor, [op.path[0] + 1]), 2), targetBlock = _f[0], targetPath = _f[1];
                            debug$9("Copying markDefs over to split block", op);
                            if (editor.isTextBlock(targetBlock)) {
                                var oldDefs = (Array.isArray(targetBlock.markDefs) && targetBlock.markDefs) || [];
                                Transforms.setNodes(editor, { markDefs: uniq(__spreadArray(__spreadArray([], __read(oldDefs), false), __read(op.properties.markDefs), false)) }, { at: targetPath, voids: false });
                                editor.onChange();
                            }
                        }
                        // Make sure marks are reset, if a block is split at the end.
                        if (op.type === 'split_node' &&
                            op.path.length === 2 &&
                            op.properties._type === portableTextFeatures.types.span.name &&
                            'marks' in op.properties &&
                            Array.isArray(op.properties.marks) &&
                            op.properties.marks.length > 0 &&
                            op.path[0] + 1 < editor.children.length) {
                            var _g = __read(Editor.node(editor, [op.path[0] + 1, 0]), 2), child = _g[0], childPath = _g[1];
                            if (Text.isText(child) &&
                                child.text === '' &&
                                Array.isArray(child.marks) &&
                                child.marks.length > 0) {
                                Transforms.setNodes(editor, { marks: [] }, { at: childPath, voids: false });
                                editor.onChange();
                            }
                        }
                        // Make sure markDefs are reset, if a block is split at start.
                        if (op.type === 'split_node' &&
                            op.path.length === 1 &&
                            op.properties._type === portableTextFeatures.types.block.name &&
                            'markDefs' in op.properties &&
                            Array.isArray(op.properties.markDefs) &&
                            op.properties.markDefs.length > 0) {
                            var _h = __read(Editor.node(editor, [op.path[0]]), 2), block = _h[0], blockPath = _h[1];
                            if (editor.isTextBlock(block) &&
                                block.children.length === 1 &&
                                block.markDefs.length > 0 &&
                                Text.isText(block.children[0]) &&
                                block.children[0].text === '' &&
                                block.children[0].marks.length === 0) {
                                Transforms.setNodes(editor, { markDefs: [] }, { at: blockPath });
                                editor.onChange();
                            }
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                // Empty marks if text is empty
                if (isSpan && Array.isArray(node.marks) && node.marks.length > 0 && node.text === '') {
                    Transforms.setNodes(editor, { marks: [] }, { at: path, voids: false });
                    editor.onChange();
                }
            }
            // Check consistency of markDefs
            if (isTextBlock &&
                editor.operations.some(function (op) {
                    return ['split_node', 'remove_node', 'remove_text', 'merge_node'].includes(op.type);
                })) {
                normalizeMarkDefs(editor);
            }
        };
        // Special hook before inserting text at the end of an annotation.
        editor.apply = function (op) {
            var _a, _b;
            if (op.type === 'insert_text') {
                var selection = editor.selection;
                if (selection &&
                    Range.isCollapsed(selection) &&
                    ((_b = (_a = Editor.marks(editor)) === null || _a === void 0 ? void 0 : _a.marks) === null || _b === void 0 ? void 0 : _b.some(function (mark) { return !decorators.includes(mark); }))) {
                    var _c = __read(Array.from(Editor.nodes(editor, {
                        mode: 'lowest',
                        at: selection.focus,
                        match: function (n) { return n._type === portableTextFeatures.types.span.name; },
                        voids: false,
                    }))[0] || [undefined], 1), node = _c[0];
                    if (Text.isText(node) &&
                        node.text.length === selection.focus.offset &&
                        Array.isArray(node.marks) &&
                        node.marks.length > 0) {
                        apply(op);
                        Transforms.splitNodes(editor, {
                            match: Text.isText,
                            at: __assign(__assign({}, selection.focus), { offset: selection.focus.offset }),
                        });
                        var marksWithoutAnnotationMarks = (__assign({}, (Editor.marks(editor) || {})).marks || []).filter(function (mark) { return decorators.includes(mark); });
                        Transforms.setNodes(editor, { marks: marksWithoutAnnotationMarks }, { at: Path.next(selection.focus.path) });
                        return;
                    }
                }
            }
            apply(op);
        };
        // Override built in addMark function
        editor.addMark = function (mark) {
            if (editor.selection) {
                if (Range.isExpanded(editor.selection)) {
                    // Split if needed
                    Transforms.setNodes(editor, {}, { match: Text.isText, split: true });
                    // Use new selection
                    var splitTextNodes_1 = __spreadArray([], __read(Editor.nodes(editor, { at: editor.selection, match: Text.isText })), false);
                    var shouldRemoveMark = flatten$1(splitTextNodes_1.map(function (item) { return item[0]; }).map(function (node) { return node.marks; })).includes(mark);
                    if (shouldRemoveMark) {
                        editor.removeMark(mark);
                        return;
                    }
                    Editor.withoutNormalizing(editor, function () {
                        splitTextNodes_1.forEach(function (_a) {
                            var _b = __read(_a, 2), node = _b[0], path = _b[1];
                            var marks = __spreadArray(__spreadArray([], __read((Array.isArray(node.marks) ? node.marks : []).filter(function (eMark) { return eMark !== mark; })), false), [
                                mark,
                            ], false);
                            Transforms.setNodes(editor, { marks: marks }, { at: path, match: Text.isText, split: true, hanging: true });
                        });
                    });
                    Editor.normalize(editor);
                }
                else {
                    var existingMarks = __assign({}, (Editor.marks(editor) || {})).marks || [];
                    var marks = __assign(__assign({}, (Editor.marks(editor) || {})), { marks: __spreadArray(__spreadArray([], __read(existingMarks), false), [mark], false) });
                    editor.marks = marks;
                }
                editor.onChange();
            }
        };
        // Override built in removeMark function
        editor.removeMark = function (mark) {
            var selection = editor.selection;
            if (selection) {
                if (Range.isExpanded(selection)) {
                    Editor.withoutNormalizing(editor, function () {
                        // Split if needed
                        Transforms.setNodes(editor, {}, { match: Text.isText, split: true });
                        if (editor.selection) {
                            var splitTextNodes = __spreadArray([], __read(Editor.nodes(editor, { at: editor.selection, match: Text.isText })), false);
                            splitTextNodes.forEach(function (_a) {
                                var _b = __read(_a, 2), node = _b[0], path = _b[1];
                                var block = editor.children[path[0]];
                                if (Element$1.isElement(block) && block.children.includes(node)) {
                                    Transforms.setNodes(editor, {
                                        marks: (Array.isArray(node.marks) ? node.marks : []).filter(function (eMark) { return eMark !== mark; }),
                                    }, { at: path });
                                }
                            });
                        }
                    });
                    Editor.normalize(editor);
                }
                else {
                    var existingMarks = __assign({}, (Editor.marks(editor) || {})).marks || [];
                    var marks = __assign(__assign({}, (Editor.marks(editor) || {})), { marks: existingMarks.filter(function (eMark) { return eMark !== mark; }) });
                    editor.marks = marks;
                }
                editor.onChange();
            }
        };
        editor.pteIsMarkActive = function (mark) {
            if (!editor.selection || editor.selection.focus.path.length < 2) {
                return false;
            }
            var existingMarks = __assign({}, (Editor.marks(editor) || {})).marks || [];
            if (Range.isExpanded(editor.selection)) {
                Array.from(Editor.nodes(editor, { match: Text.isText, at: editor.selection })).forEach(function (n) {
                    var _a = __read(n, 1), node = _a[0];
                    existingMarks = uniq(__spreadArray(__spreadArray([], __read(existingMarks), false), __read((node.marks || [])), false));
                });
            }
            return existingMarks.includes(mark);
        };
        // Custom editor function to toggle a mark
        editor.pteToggleMark = function (mark) {
            var isActive = editor.pteIsMarkActive(mark);
            if (isActive) {
                debug$9("Remove mark '".concat(mark, "'"));
                Editor.removeMark(editor, mark);
            }
            else {
                debug$9("Add mark '".concat(mark, "'"));
                Editor.addMark(editor, mark, true);
            }
            editor.onChange();
        };
        return editor;
    };
    /**
     * Normalize re-marked spans in selection
     */
    function mergeSpans(editor) {
        var e_2, _a;
        var selection = editor.selection;
        if (selection) {
            try {
                for (var _b = __values(Array.from(Editor.nodes(editor, {
                    at: Editor.range(editor, [selection.anchor.path[0]], [selection.focus.path[0]]),
                })).reverse()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var _d = __read(_c.value, 2), node = _d[0], path = _d[1];
                    var _e = __read(path.length > 1 ? Editor.node(editor, Path.parent(path)) : [undefined], 1), parent_1 = _e[0];
                    var nextPath = [path[0], path[1] + 1];
                    if (Editor.isBlock(editor, parent_1)) {
                        var nextNode = parent_1.children[nextPath[1]];
                        if (Text.isText(node) && Text.isText(nextNode) && isEqual(nextNode.marks, node.marks)) {
                            debug$9('Merging spans');
                            Transforms.mergeNodes(editor, { at: nextPath, voids: true });
                            editor.onChange();
                        }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    }
    /**
     * Normalize markDefs
     *
     */
    function normalizeMarkDefs(editor) {
        var e_3, _a;
        var selection = editor.selection;
        if (selection) {
            var blocks = Editor.nodes(editor, {
                at: selection,
                match: function (n) { return n._type === portableTextFeatures.types.block.name; },
            });
            var _loop_1 = function (block, path) {
                if (editor.isTextBlock(block)) {
                    var newMarkDefs = block.markDefs.filter(function (def) {
                        return block.children.find(function (child) {
                            return (Text.isText(child) && Array.isArray(child.marks) && child.marks.includes(def._key));
                        });
                    });
                    if (!isEqual(newMarkDefs, block.markDefs)) {
                        debug$9('Removing markDef not in use');
                        Transforms.setNodes(editor, {
                            markDefs: newMarkDefs,
                        }, { at: path });
                        editor.onChange();
                    }
                }
            };
            try {
                for (var blocks_1 = __values(blocks), blocks_1_1 = blocks_1.next(); !blocks_1_1.done; blocks_1_1 = blocks_1.next()) {
                    var _b = __read(blocks_1_1.value, 2), block = _b[0], path = _b[1];
                    _loop_1(block, path);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (blocks_1_1 && !blocks_1_1.done && (_a = blocks_1.return)) _a.call(blocks_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
    }
}

var debug$8 = debugWithName('plugin:withPortableTextSelections');
// This plugin will make sure that we emit a PT selection whenever the editor has changed.
function createWithPortableTextSelections(change$, portableTextFeatures) {
    return function withPortableTextSelections(editor) {
        var emitPortableTextSelection = function () {
            var ptRange = null;
            if (editor.selection) {
                var existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection);
                if (existing) {
                    ptRange = existing;
                }
                else {
                    ptRange = toPortableTextRange(fromSlateValue(editor.children, portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, portableTextFeatures);
                    SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange);
                }
            }
            debug$8("Emitting selection ".concat(JSON.stringify(ptRange || null)));
            if (ptRange) {
                change$.next({ type: 'selection', selection: ptRange });
            }
            else {
                change$.next({ type: 'selection', selection: null });
            }
        };
        var onChange = editor.onChange;
        editor.onChange = function () {
            var hasChanges = editor.operations.length > 0;
            onChange();
            if (hasChanges) {
                emitPortableTextSelection();
            }
        };
        return editor;
    };
}

var debug$7 = debugWithName('plugin:withSchemaTypes');
/**
 * This plugin makes sure that shema types are recognized properly by Slate as blocks, voids, inlines
 *
 */
function createWithSchemaTypes(portableTextFeatures) {
    return function withSchemaTypes(editor) {
        editor.isTextBlock = function (value) {
            return (!editor.isVoid(value) &&
                'markDefs' in value &&
                'style' in value &&
                'children' in value &&
                '_type' in value &&
                portableTextFeatures.types.block.name === value._type);
        };
        editor.isTextSpan = function (value) {
            return (!editor.isVoid(value) &&
                'text' in value &&
                'marks' in value &&
                '_type' in value &&
                portableTextFeatures.types.span.name === value._type);
        };
        editor.isListBlock = function (value) {
            return Boolean(editor.isTextBlock(value) &&
                'listItem' in value &&
                'level' in value &&
                value.listItem &&
                Number.isInteger(value.level));
        };
        editor.isVoid = function (element) {
            return (portableTextFeatures.types.block.name !== element._type &&
                (portableTextFeatures.types.blockObjects.map(function (obj) { return obj.name; }).includes(element._type) ||
                    portableTextFeatures.types.inlineObjects.map(function (obj) { return obj.name; }).includes(element._type)));
        };
        editor.isInline = function (element) {
            var inlineSchemaTypes = portableTextFeatures.types.inlineObjects.map(function (obj) { return obj.name; });
            return (inlineSchemaTypes.includes(element._type) &&
                '__inline' in element &&
                element.__inline === true);
        };
        // Extend Slate's default normalization to add _type span to span inserted after a inline void object
        var apply = editor.apply;
        editor.apply = function (op) {
            var isInsertTextWithoutType = op.type === 'insert_node' &&
                op.path.length === 2 &&
                Text.isText(op.node) &&
                op.node._type === undefined;
            if (isInsertTextWithoutType) {
                var insertNodeOperation = op;
                var newNode = __assign(__assign({}, insertNodeOperation.node), { _type: 'span' });
                op.node = newNode;
                debug$7('Setting span type to child without a type', op);
            }
            apply(op);
        };
        return editor;
    };
}

var debug$6 = debugWithName('plugin:withUtils');
/**
 * This plugin makes various util commands available in the editor
 *
 */
function createWithUtils(_a) {
    return function withUtils(editor) {
        // Expands the the selection to wrap around the word the focus is at
        editor.pteExpandToWord = function () {
            var selection = editor.selection;
            if (selection && !Range.isExpanded(selection)) {
                var _a = __read(Editor.node(editor, selection.focus, { depth: 2 }), 1), textNode = _a[0];
                if (!textNode || !Text.isText(textNode) || textNode.text.length === 0) {
                    debug$6("pteExpandToWord: Can't expand to word here");
                    return;
                }
                var focus_1 = selection.focus;
                var focusOffset = focus_1.offset;
                var charsBefore = textNode.text.slice(0, focusOffset);
                var charsAfter = textNode.text.slice(focusOffset, -1);
                var isEmpty_1 = function (str) { return str.match(/\s/g); };
                var whiteSpaceBeforeIndex = charsBefore
                    .split('')
                    .reverse()
                    .findIndex(function (str) { return isEmpty_1(str); });
                var newStartOffset = whiteSpaceBeforeIndex > -1 ? charsBefore.length - whiteSpaceBeforeIndex : 0;
                var whiteSpaceAfterIndex = charsAfter.split('').findIndex(function (obj) { return isEmpty_1(obj); });
                var newEndOffset = charsBefore.length +
                    (whiteSpaceAfterIndex > -1 ? whiteSpaceAfterIndex : charsAfter.length + 1);
                if (!(newStartOffset === newEndOffset || isNaN(newStartOffset) || isNaN(newEndOffset))) {
                    debug$6('pteExpandToWord: Expanding to focused word');
                    Transforms.setSelection(editor, {
                        anchor: __assign(__assign({}, selection.anchor), { offset: newStartOffset }),
                        focus: __assign(__assign({}, selection.focus), { offset: newEndOffset }),
                    });
                    return;
                }
                debug$6("pteExpandToWord: Can't expand to word here");
            }
        };
        return editor;
    };
}

var debug$5 = debugWithName('plugin:withHotKeys');
var DEFAULT_HOTKEYS = {
    marks: {
        'mod+b': 'strong',
        'mod+i': 'em',
        'mod+u': 'underline',
        "mod+'": 'code',
    },
    custom: {},
};
/**
 * This plugin takes care of all hotkeys in the editor
 *
 */
function createWithHotkeys(portableTextFeatures, keyGenerator, portableTextEditor, hotkeysFromOptions) {
    var reservedHotkeys = ['enter', 'tab', 'shift', 'delete', 'end'];
    var activeHotkeys = hotkeysFromOptions || DEFAULT_HOTKEYS; // TODO: Merge where possible? A union?
    var createEmptyBlock = function () {
        return toSlateValue([
            {
                _type: portableTextFeatures.types.block.name,
                _key: keyGenerator(),
                style: 'normal',
                markDefs: [],
                children: [
                    {
                        _type: 'span',
                        _key: keyGenerator(),
                        text: '',
                        marks: [],
                    },
                ],
            },
        ], portableTextEditor)[0];
    };
    return function withHotKeys(editor) {
        editor.pteWithHotKeys = function (event) {
            var _a;
            // Wire up custom marks hotkeys
            Object.keys(activeHotkeys).forEach(function (cat) {
                if (cat === 'marks') {
                    // eslint-disable-next-line guard-for-in
                    for (var hotkey in activeHotkeys[cat]) {
                        if (reservedHotkeys.includes(hotkey)) {
                            throw new Error("The hotkey ".concat(hotkey, " is reserved!"));
                        }
                        if (isHotkey(hotkey, event.nativeEvent)) {
                            event.preventDefault();
                            var possibleMark = activeHotkeys[cat];
                            if (possibleMark) {
                                var mark = possibleMark[hotkey];
                                debug$5("HotKey ".concat(hotkey, " to toggle ").concat(mark));
                                editor.pteToggleMark(mark);
                            }
                        }
                    }
                }
                if (cat === 'custom') {
                    // eslint-disable-next-line guard-for-in
                    for (var hotkey in activeHotkeys[cat]) {
                        if (reservedHotkeys.includes(hotkey)) {
                            throw new Error("The hotkey ".concat(hotkey, " is reserved!"));
                        }
                        if (isHotkey(hotkey, event.nativeEvent)) {
                            var possibleCommand = activeHotkeys[cat];
                            if (possibleCommand) {
                                var command = possibleCommand[hotkey];
                                command(event, portableTextEditor);
                            }
                        }
                    }
                }
            });
            var isEnter = isHotkey('enter', event.nativeEvent);
            var isTab = isHotkey('tab', event.nativeEvent);
            var isShiftEnter = isHotkey('shift+enter', event.nativeEvent);
            var isShiftTab = isHotkey('shift+tab', event.nativeEvent);
            var isBackspace = isHotkey('backspace', event.nativeEvent);
            var isDelete = isHotkey('delete', event.nativeEvent);
            // Disallow deleting void blocks by backspace from another line.
            // Otherwise it's so easy to delete the void block above when trying to delete text on
            // the line below or above
            if (isBackspace &&
                editor.selection &&
                editor.selection.focus.path[0] > 0 &&
                Range.isCollapsed(editor.selection)) {
                var _b = __read(Editor.node(editor, Path.previous(editor.selection.focus.path.slice(0, 1))), 2), prevBlock = _b[0], prevPath = _b[1];
                var _c = __read(Editor.node(editor, editor.selection.focus, { depth: 1 }), 1), focusBlock_1 = _c[0];
                if (prevBlock &&
                    focusBlock_1 &&
                    Editor.isVoid(editor, prevBlock) &&
                    editor.selection.focus.offset === 0) {
                    debug$5('Preventing deleting void block above');
                    event.preventDefault();
                    event.stopPropagation();
                    Transforms.removeNodes(editor, { match: function (n) { return n === focusBlock_1; } });
                    Transforms.select(editor, prevPath);
                    editor.onChange();
                    return;
                }
            }
            if (isDelete &&
                editor.selection &&
                editor.selection.focus.offset === 0 &&
                Range.isCollapsed(editor.selection) &&
                editor.children[editor.selection.focus.path[0] + 1]) {
                var _d = __read(Editor.node(editor, Path.next(editor.selection.focus.path.slice(0, 1))), 1), nextBlock = _d[0];
                var _e = __read(Editor.node(editor, editor.selection.focus, { depth: 1 }), 2), focusBlock_2 = _e[0], focusBlockPath = _e[1];
                if (nextBlock &&
                    focusBlock_2 &&
                    !Editor.isVoid(editor, focusBlock_2) &&
                    Editor.isVoid(editor, nextBlock)) {
                    debug$5('Preventing deleting void block below');
                    event.preventDefault();
                    event.stopPropagation();
                    Transforms.removeNodes(editor, { match: function (n) { return n === focusBlock_2; } });
                    Transforms.select(editor, focusBlockPath);
                    editor.onChange();
                    return;
                }
            }
            // Tab for lists
            if (isTab || isShiftTab) {
                if (editor.pteIncrementBlockLevels(isShiftTab)) {
                    event.preventDefault();
                }
            }
            // Deal with enter key combos
            if (isEnter && !isShiftEnter && editor.selection) {
                var focusBlock = void 0;
                try {
                    ;
                    _a = __read(Editor.node(editor, editor.selection.focus, { depth: 1 }), 1), focusBlock = _a[0];
                }
                catch (err) {
                    // Just ignore
                }
                // List item enter key
                if (editor.isListBlock(focusBlock)) {
                    if (editor.pteEndList()) {
                        event.preventDefault();
                    }
                    return;
                }
                // Enter from another style than the first (default one)
                if (editor.isTextBlock(focusBlock) &&
                    focusBlock.style &&
                    focusBlock.style !== portableTextFeatures.styles[0].value) {
                    var _f = __read(Range.edges(editor.selection), 2), end = _f[1];
                    var endAtEndOfNode = Editor.isEnd(editor, end, end.path);
                    if (endAtEndOfNode) {
                        Editor.insertNode(editor, createEmptyBlock());
                        event.preventDefault();
                        return;
                    }
                }
                // Block object enter key
                if (focusBlock && Editor.isVoid(editor, focusBlock)) {
                    Editor.insertNode(editor, createEmptyBlock());
                    event.preventDefault();
                    return;
                }
            }
            // Soft line breaks
            if (isShiftEnter) {
                event.preventDefault();
                editor.insertText('\n');
                return;
            }
            // Undo/redo
            if (isHotkey('mod+z', event.nativeEvent)) {
                event.preventDefault();
                editor.undo();
                return;
            }
            if (isHotkey('mod+y', event.nativeEvent) || isHotkey('mod+shift+z', event.nativeEvent)) {
                event.preventDefault();
                editor.redo();
            }
        };
        return editor;
    };
}

var debug$4 = debugWithName('plugin:withInsertData');
/**
 * This plugin handles copy/paste in the editor
 *
 */
function createWithInsertData(change$, portableTextFeatures, keyGenerator) {
    return function withInsertData(editor) {
        var blockTypeName = portableTextFeatures.types.block.name;
        var spanTypeName = portableTextFeatures.types.span.name;
        var toPlainText = function (blocks) {
            return blocks
                .map(function (block) {
                var _a;
                if (block._type === blockTypeName) {
                    return block.children
                        .map(function (child) {
                        var _a;
                        if (child._type === spanTypeName) {
                            return child.text;
                        }
                        return "[".concat(((_a = portableTextFeatures.types.inlineObjects.find(function (t) { return t.name === child._type; })) === null || _a === void 0 ? void 0 : _a.title) || 'Object', "]");
                    })
                        .join('');
                }
                return "[".concat(((_a = portableTextFeatures.types.blockObjects.find(function (t) { return t.name === block._type; })) === null || _a === void 0 ? void 0 : _a.title) ||
                    'Object', "]");
            })
                .join('\n\n');
        };
        editor.setFragmentData = function (data, originEvent) {
            var selection = editor.selection;
            if (!selection) {
                return;
            }
            var _a = __read(Range.edges(selection), 2), start = _a[0], end = _a[1];
            var startVoid = Editor.void(editor, { at: start.path });
            var endVoid = Editor.void(editor, { at: end.path });
            if (Range.isCollapsed(selection) && !startVoid) {
                return;
            }
            // Create a fake selection so that we can add a Base64-encoded copy of the
            // fragment to the HTML, to decode on future pastes.
            var domRange = ReactEditor.toDOMRange(editor, selection);
            var contents = domRange.cloneContents();
            // COMPAT: If the end node is a void node, we need to move the end of the
            // range from the void node's spacer span, to the end of the void node's
            // content, since the spacer is before void's content in the DOM.
            if (endVoid) {
                var _b = __read(endVoid, 1), voidNode = _b[0];
                var r = domRange.cloneRange();
                var domNode = ReactEditor.toDOMNode(editor, voidNode);
                r.setEndAfter(domNode);
                contents = r.cloneContents();
            }
            // Remove any zero-width space spans from the cloned DOM so that they don't
            // show up elsewhere when pasted.
            Array.from(contents.querySelectorAll('[data-slate-zero-width]')).forEach(function (zw) {
                var isNewline = zw.getAttribute('data-slate-zero-width') === 'n';
                zw.textContent = isNewline ? '\n' : '';
            });
            // Clean up the clipboard HTML for editor spesific attributes
            Array.from(contents.querySelectorAll('*')).forEach(function (elm) {
                elm.removeAttribute('contentEditable');
                elm.removeAttribute('data-slate-inline');
                elm.removeAttribute('data-slate-leaf');
                elm.removeAttribute('data-slate-node');
                elm.removeAttribute('data-slate-spacer');
                elm.removeAttribute('data-slate-string');
                elm.removeAttribute('data-slate-zero-width');
                elm.removeAttribute('draggable');
                for (var key in elm.attributes) {
                    if (elm.hasAttribute(key)) {
                        elm.removeAttribute(key);
                    }
                }
            });
            var div = contents.ownerDocument.createElement('div');
            div.appendChild(contents);
            div.setAttribute('hidden', 'true');
            contents.ownerDocument.body.appendChild(div);
            var asHTML = div.innerHTML;
            contents.ownerDocument.body.removeChild(div);
            var fragment = editor.getFragment();
            var portableText = fromSlateValue(fragment, portableTextFeatures.types.block.name);
            var asJSON = JSON.stringify(portableText);
            var asPlainText = toPlainText(portableText);
            data.clearData();
            data.setData('text/plain', asPlainText);
            data.setData('text/html', asHTML);
            data.setData('application/json', asJSON);
            data.setData('application/x-portable-text', asJSON);
            debug$4('text', asPlainText);
            data.setData('application/x-portable-text-event-origin', originEvent || 'external');
            debug$4('Set fragment data', asJSON, asHTML);
        };
        editor.insertPortableTextData = function (data) {
            var _a;
            if (!editor.selection) {
                return false;
            }
            var pText = data.getData('application/x-portable-text');
            var origin = data.getData('application/x-portable-text-event-origin');
            debug$4("Inserting portable text from ".concat(origin, " event"), pText);
            if (pText) {
                var parsed = JSON.parse(pText);
                if (Array.isArray(parsed) && parsed.length > 0) {
                    var slateValue = regenerateKeys(editor, toSlateValue(parsed, { portableTextFeatures: portableTextFeatures }), keyGenerator, spanTypeName);
                    // Validate the result
                    var validation = validateValue(parsed, portableTextFeatures, keyGenerator);
                    // Bail out if it's not valid
                    if (!validation.valid) {
                        var errorDescription = "".concat((_a = validation.resolution) === null || _a === void 0 ? void 0 : _a.description);
                        change$.next({
                            type: 'error',
                            level: 'warning',
                            name: 'pasteError',
                            description: errorDescription,
                            data: validation,
                        });
                        debug$4('Invalid insert result', validation);
                        return false;
                    }
                    mixMarkDefs(editor, slateValue);
                    editor.insertFragment(slateValue);
                    editor.onChange();
                    return true;
                }
            }
            return false;
        };
        editor.insertTextOrHTMLData = function (data) {
            var _a;
            if (!editor.selection) {
                debug$4('No selection, not inserting');
                return false;
            }
            change$.next({ type: 'loading', isLoading: true }); // This could potentially take some time
            var html = data.getData('text/html');
            var text = data.getData('text/plain');
            if (html || text) {
                debug$4('Inserting data', data);
                var portableText = void 0;
                var fragment = void 0;
                var insertedType = void 0;
                if (html) {
                    portableText = htmlToBlocks(html, portableTextFeatures.types.portableText).map(function (block) {
                        return normalizeBlock(block, { blockTypeName: blockTypeName });
                    });
                    fragment = toSlateValue(portableText, { portableTextFeatures: portableTextFeatures });
                    insertedType = 'HTML';
                }
                else {
                    // plain text
                    var blocks = escapeHtml(text)
                        .split(/\n{2,}/)
                        .map(function (line) {
                        return line ? "<p>".concat(line.replace(/(?:\r\n|\r|\n)/g, '<br/>'), "</p>") : '<p></p>';
                    })
                        .join('');
                    var textToHtml = "<html><body>".concat(blocks, "</body></html>");
                    portableText = htmlToBlocks(textToHtml, portableTextFeatures.types.portableText).map(function (block) { return normalizeBlock(block, { blockTypeName: blockTypeName }); });
                    fragment = toSlateValue(portableText, {
                        portableTextFeatures: portableTextFeatures,
                    });
                    insertedType = 'text';
                }
                // Validate the result
                var validation = validateValue(portableText, portableTextFeatures, keyGenerator);
                // Bail out if it's not valid
                if (!validation.valid) {
                    var errorDescription = "Could not validate the resulting portable text to insert.\n".concat((_a = validation.resolution) === null || _a === void 0 ? void 0 : _a.description, "\nTry to insert as plain text (shift-paste) instead.");
                    change$.next({
                        type: 'error',
                        level: 'warning',
                        name: 'pasteError',
                        description: errorDescription,
                        data: validation,
                    });
                    debug$4('Invalid insert result', validation);
                    return false;
                }
                debug$4("Inserting ".concat(insertedType, " fragment at ").concat(JSON.stringify(editor.selection)));
                mixMarkDefs(editor, fragment);
                editor.insertFragment(fragment);
                editor.onChange();
                change$.next({ type: 'loading', isLoading: false });
                return true;
            }
            change$.next({ type: 'loading', isLoading: false });
            return false;
        };
        editor.insertData = function (data) {
            if (!editor.insertPortableTextData(data)) {
                editor.insertTextOrHTMLData(data);
            }
        };
        editor.insertFragmentData = function (data) {
            var fragment = data.getData('application/x-portable-text');
            if (fragment) {
                var parsed = JSON.parse(fragment);
                editor.insertFragment(parsed);
                return true;
            }
            return false;
        };
        return editor;
    };
}
var entityMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '/': '&#x2F;',
    '`': '&#x60;',
    '=': '&#x3D;',
};
function escapeHtml(str) {
    return String(str).replace(/[&<>"'`=/]/g, function (s) { return entityMap[s]; });
}
function regenerateKeys(editor, fragment, keyGenerator, spanTypeName) {
    return fragment.map(function (node) {
        var newNode = __assign({}, node);
        // Ensure the copy has new keys
        if (editor.isTextBlock(newNode)) {
            newNode.markDefs = newNode.markDefs.map(function (def) {
                var oldKey = def._key;
                var newKey = keyGenerator();
                if (Array.isArray(newNode.children)) {
                    newNode.children = newNode.children.map(function (child) {
                        return child._type === spanTypeName && Text.isText(child)
                            ? __assign(__assign({}, child), { marks: child.marks && child.marks.includes(oldKey)
                                    ? // eslint-disable-next-line max-nested-callbacks
                                        __spreadArray([], __read(child.marks), false).filter(function (mark) { return mark !== oldKey; }).concat(newKey)
                                    : child.marks }) : child;
                    });
                }
                return __assign(__assign({}, def), { _key: newKey });
            });
        }
        var nodeWithNewKeys = __assign(__assign({}, newNode), { _key: keyGenerator() });
        if (editor.isTextBlock(nodeWithNewKeys)) {
            nodeWithNewKeys.children = nodeWithNewKeys.children.map(function (child) { return (__assign(__assign({}, child), { _key: keyGenerator() })); });
        }
        return nodeWithNewKeys;
    });
}
function mixMarkDefs(editor, fragment) {
    if (!editor.selection) {
        return false;
    }
    var _a = __read(Editor.node(editor, editor.selection, { depth: 1 }), 2), focusBlock = _a[0], focusPath = _a[1];
    if (editor.isTextBlock(focusBlock) && editor.isTextBlock(fragment[0])) {
        var markDefs = focusBlock.markDefs;
        debug$4('Mixing markDefs of focusBlock and fragments[0] block', markDefs, fragment[0].markDefs);
        // As the first block will be inserted into another block (potentially), mix those markDefs
        Transforms.setNodes(editor, {
            markDefs: __spreadArray(__spreadArray([], __read(fragment[0].markDefs), false), __read(markDefs), false),
        }, { at: focusPath, mode: 'lowest', voids: false });
        return true;
    }
    return false;
}

var originalFnMap = new WeakMap();
var withPlugins = function (editor, options) {
    var e = editor;
    var portableTextEditor = options.portableTextEditor;
    var portableTextFeatures = portableTextEditor.portableTextFeatures, keyGenerator = portableTextEditor.keyGenerator, readOnly = portableTextEditor.readOnly, change$ = portableTextEditor.change$, syncValue = portableTextEditor.syncValue, incomingPatches$ = portableTextEditor.incomingPatches$;
    e.maxBlocks = portableTextEditor.maxBlocks || -1;
    e.readOnly = portableTextEditor.readOnly || false;
    if (e.destroy) {
        e.destroy();
    }
    else {
        // Save a copy of the original editor functions here before they were changed by plugins.
        // We will put them back when .destroy is called (see below).
        originalFnMap.set(e, {
            apply: e.apply,
            onChange: e.onChange,
            normalizeNode: e.normalizeNode,
        });
    }
    var operationToPatches = createOperationToPatches(portableTextFeatures);
    var withObjectKeys = createWithObjectKeys(portableTextFeatures, keyGenerator);
    var withSchemaTypes = createWithSchemaTypes(portableTextFeatures);
    var withEditableAPI = createWithEditableAPI(portableTextEditor, portableTextFeatures, keyGenerator);
    var _a = __read(readOnly
        ? []
        : createWithPatches({
            patchFunctions: operationToPatches,
            change$: change$,
            portableTextFeatures: portableTextFeatures,
            syncValue: syncValue,
            incomingPatches$: incomingPatches$,
        }), 2), withPatches = _a[0], withPatchesCleanupFunction = _a[1];
    var withMaxBlocks = createWithMaxBlocks();
    var withPortableTextLists = createWithPortableTextLists(portableTextFeatures);
    var _b = __read(readOnly
        ? []
        : createWithUndoRedo(incomingPatches$), 2), withUndoRedo = _b[0], withUndoRedoCleanupFunction = _b[1];
    var withPortableTextMarkModel = createWithPortableTextMarkModel(portableTextFeatures);
    var withPortableTextBlockStyle = createWithPortableTextBlockStyle(portableTextFeatures, change$);
    var withPlaceholderBlock = createWithPlaceholderBlock({
        keyGenerator: keyGenerator,
        portableTextFeatures: portableTextFeatures,
    });
    var withUtils = createWithUtils();
    var withPortableTextSelections = createWithPortableTextSelections(change$, portableTextFeatures);
    e.destroy = function () {
        var originalFunctions = originalFnMap.get(e);
        if (!originalFunctions) {
            throw new Error('Could not find pristine versions of editor functions');
        }
        e.onChange = originalFunctions.onChange;
        e.apply = originalFunctions.apply;
        e.normalizeNode = originalFunctions.normalizeNode;
        if (withPatchesCleanupFunction) {
            withPatchesCleanupFunction();
        }
        if (withUndoRedoCleanupFunction) {
            withUndoRedoCleanupFunction();
        }
    };
    if (readOnly) {
        return withSchemaTypes(withObjectKeys(withPortableTextMarkModel(withPortableTextBlockStyle(withUtils(withPlaceholderBlock(withPortableTextLists(withPortableTextSelections(withEditableAPI(e)))))))));
    }
    // The 'if' here is only to satisfy Typscript
    if (withUndoRedo && withPatches) {
        // Ordering is important here, selection dealing last, data manipulation in the middle and core model stuff first.
        return withSchemaTypes(withObjectKeys(withPortableTextMarkModel(withPortableTextBlockStyle(withPortableTextLists(withPlaceholderBlock(withUtils(withMaxBlocks(withUndoRedo(withPatches(withPortableTextSelections(withEditableAPI(e))))))))))));
    }
    return e;
};

// Debounce time for flushing local patches (ms since user haven't produced a patch)
// (lower time for tests to speed them up)
var FLUSH_PATCHES_DEBOUNCE_MS = process.env.NODE_ENV === 'test' ? 50 : 1000;
var defaultKeyGenerator = function () { return randomKey(12); };
var debug$3 = debugWithName('component:PortableTextEditor');
var PortableTextEditor = /** @class */ (function (_super) {
    __extends(PortableTextEditor, _super);
    function PortableTextEditor(props) {
        var _this = _super.call(this, props) || this;
        _this.change$ = new Subject();
        _this.pendingPatches = [];
        _this.returnedPatches = [];
        _this.setEditable = function (editable) {
            _this.editable = __assign(__assign({}, _this.editable), editable);
            _this.change$.next({ type: 'value', value: _this.props.value || undefined });
            _this.change$.next({ type: 'ready' });
        };
        _this.syncValue = function (userCallbackFn) {
            var val = _this.props.value;
            var callbackFn = function () {
                debug$3('Updating slate instance');
                _this.slateInstance.onChange();
                _this.change$.next({ type: 'value', value: val });
                if (userCallbackFn) {
                    userCallbackFn();
                }
            };
            if (_this.hasPendingLocalPatches.current && !_this.readOnly) {
                debug$3('Not syncing value (has pending local patches)');
                retrySync(function () { return _this.syncValue(); }, callbackFn);
                return;
            }
            // If the  editor is empty and there is a new value, just set that value directly.
            if (isEqualToEmptyEditor(_this.slateInstance.children, _this.portableTextFeatures) &&
                _this.props.value) {
                var oldSel = _this.slateInstance.selection;
                Transforms.deselect(_this.slateInstance);
                _this.slateInstance.children = toSlateValue(val, {
                    portableTextFeatures: _this.portableTextFeatures,
                }, KEY_TO_SLATE_ELEMENT.get(_this.slateInstance));
                if (oldSel) {
                    Transforms.select(_this.slateInstance, oldSel);
                }
                debug$3('Setting props.value directly to empty editor');
                callbackFn();
                return;
            }
            // Test for diffs between our state value and the incoming value.
            var isEqualToValue = !(val || []).some(function (blk, index) {
                var compareBlock = toSlateValue([blk], { portableTextFeatures: _this.portableTextFeatures }, KEY_TO_SLATE_ELEMENT.get(_this.slateInstance))[0];
                if (!isEqual(compareBlock, _this.slateInstance.children[index])) {
                    return true;
                }
                return false;
            });
            if (isEqualToValue) {
                debug$3('Not syncing value (value is equal)');
                return;
            }
            // Value is different - validate it.
            debug$3('Validating');
            var validation = validateValue(val, _this.portableTextFeatures, _this.keyGenerator);
            if (val && !validation.valid) {
                _this.change$.next({
                    type: 'invalidValue',
                    resolution: validation.resolution,
                    value: val,
                });
                _this.setState({ invalidValueResolution: validation.resolution });
            }
            // Set the new value
            debug$3('Replacing changed nodes');
            if (val && val.length > 0) {
                var oldSel = _this.slateInstance.selection;
                Transforms.deselect(_this.slateInstance);
                var slateValueFromProps = toSlateValue(val, {
                    portableTextFeatures: _this.portableTextFeatures,
                }, KEY_TO_SLATE_ELEMENT.get(_this.slateInstance));
                _this.slateInstance.children = slateValueFromProps;
                if (oldSel) {
                    Transforms.select(_this.slateInstance, oldSel);
                }
            }
            callbackFn();
        };
        _this.flush = function () {
            var onChange = _this.props.onChange;
            var finalPatches = __spreadArray([], __read(_this.pendingPatches), false);
            if (finalPatches.length > 0) {
                debug$3('Flushing', finalPatches);
                finalPatches.forEach(function (p) {
                    _this.returnedPatches.push(p);
                });
                onChange({ type: 'mutation', patches: finalPatches });
                _this.pendingPatches = [];
            }
        };
        _this.flushDebounced = debounce(_this.flush, FLUSH_PATCHES_DEBOUNCE_MS, {
            leading: false,
            trailing: true,
        });
        if (!props.type) {
            throw new Error('PortableTextEditor: missing "type" property');
        }
        _this.hasPendingLocalPatches = React.createRef();
        _this.hasPendingLocalPatches.current = false;
        _this.state = {
            invalidValueResolution: null,
            selection: null,
            initialValue: [], // Created in the constructor
        };
        // Test if we have a compiled schema type, if not, conveniently compile it
        _this.type = props.type.hasOwnProperty('jsonType') ? props.type : compileType(props.type);
        // Indicate that we are loading
        _this.change$.next({ type: 'loading', isLoading: true });
        // Get the block types feature set (lookup table)
        _this.portableTextFeatures = getPortableTextFeatures(_this.type);
        // Setup keyGenerator (either from props, or default)
        _this.keyGenerator = props.keyGenerator || defaultKeyGenerator;
        // Setup processed incoming patches stream
        if (props.incomingPatches$) {
            // Buffer patches until we are no longer producing local patches
            _this.incomingPatches$ = props.incomingPatches$
                .pipe(tap(function (_a) {
                var patches = _a.patches;
                // Reset hasPendingLocalPatches when local patches are returned
                if (patches.some(function (p) { return p.origin === 'local'; })) {
                    _this.hasPendingLocalPatches.current = false;
                }
            }))
                .pipe(bufferUntil(function () { return !_this.hasPendingLocalPatches.current; }), concatMap(function (incoming) {
                return incoming;
            }), share());
        }
        // Subscribe to editor events and set state for selection and pending patches
        _this.changeSubscription = _this.change$.subscribe(function (next) {
            var onChange = _this.props.onChange;
            switch (next.type) {
                case 'patch':
                    _this.pendingPatches.push(next.patch);
                    if (_this.props.incomingPatches$) {
                        _this.hasPendingLocalPatches.current = true;
                    }
                    _this.flushDebounced();
                    onChange(next);
                    break;
                case 'selection':
                    onChange(next);
                    _this.setState({ selection: next.selection });
                    break;
                default:
                    onChange(next);
            }
        });
        // Set maxBlocks and readOnly
        _this.maxBlocks =
            typeof props.maxBlocks === 'undefined'
                ? undefined
                : parseInt(props.maxBlocks.toString(), 10) || undefined;
        _this.readOnly = Boolean(props.readOnly) || false;
        // Validate the incoming value
        if (props.value) {
            var validation = validateValue(props.value, _this.portableTextFeatures, _this.keyGenerator);
            if (props.value && !validation.valid) {
                _this.change$.next({ type: 'loading', isLoading: false });
                _this.change$.next({
                    type: 'invalidValue',
                    resolution: validation.resolution,
                    value: props.value,
                });
                _this.state = __assign(__assign({}, _this.state), { invalidValueResolution: validation.resolution });
            }
        }
        // Create the slate instance
        _this.slateInstance = withPlugins(withReact(createEditor()), {
            portableTextEditor: _this,
        });
        _this.state = __assign(__assign({}, _this.state), { initialValue: toSlateValue(getValueOrInitialValue(props.value, [_this.slateInstance.createPlaceholderBlock()]), { portableTextFeatures: _this.portableTextFeatures }, KEY_TO_SLATE_ELEMENT.get(_this.slateInstance)) });
        KEY_TO_VALUE_ELEMENT.set(_this.slateInstance, {});
        KEY_TO_SLATE_ELEMENT.set(_this.slateInstance, {});
        return _this;
    }
    PortableTextEditor.prototype.componentWillUnmount = function () {
        this.flush();
        this.changeSubscription.unsubscribe();
        this.slateInstance.destroy();
    };
    PortableTextEditor.prototype.componentDidUpdate = function (prevProps) {
        // Whenever readOnly toggles, recreate the editor's plugin chain
        if (this.props.readOnly !== prevProps.readOnly) {
            this.readOnly = Boolean(this.props.readOnly);
            this.slateInstance = withPlugins(this.slateInstance, {
                portableTextEditor: this,
            });
        }
        // Update the maxBlocks prop
        if (this.props.maxBlocks !== prevProps.maxBlocks) {
            this.maxBlocks =
                typeof this.props.maxBlocks === 'undefined'
                    ? undefined
                    : parseInt(this.props.maxBlocks.toString(), 10) || undefined;
            this.slateInstance.maxBlocks = this.maxBlocks;
        }
        // Sync value from props, but not when we are responding to incoming patches
        // (if this is the case, we sync the value after the incoming patches has been processed - see createWithPatches plugin)
        if (this.props.value !== prevProps.value &&
            (!prevProps.value || this.readOnly || !this.props.incomingPatches$)) {
            this.syncValue();
        }
    };
    PortableTextEditor.prototype.render = function () {
        if (this.state.invalidValueResolution) {
            return this.state.invalidValueResolution.description;
        }
        return (React.createElement(PortableTextEditorContext.Provider, { value: this },
            React.createElement(PortableTextEditorValueContext.Provider, { value: this.props.value },
                React.createElement(PortableTextEditorReadOnlyContext.Provider, { value: Boolean(this.props.readOnly) },
                    React.createElement(PortableTextEditorSelectionContext.Provider, { value: this.state.selection },
                        React.createElement(Slate, { onChange: NOOP$1, editor: this.slateInstance, value: this.state.initialValue }, this.props.children))))));
    };
    // Static API methods
    PortableTextEditor.activeAnnotations = function (editor) {
        return editor && editor.editable ? editor.editable.activeAnnotations() : [];
    };
    PortableTextEditor.addAnnotation = function (editor, type, value) { var _a; return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.addAnnotation(type, value); };
    PortableTextEditor.blur = function (editor) {
        var _a;
        debug$3('Host blurred');
        (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.blur();
    };
    PortableTextEditor.delete = function (editor, selection, options) { var _a; return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.delete(selection, options); };
    PortableTextEditor.findDOMNode = function (editor, element) {
        var _a;
        // eslint-disable-next-line react/no-find-dom-node
        return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.findDOMNode(element);
    };
    PortableTextEditor.findByPath = function (editor, path) {
        var _a;
        return ((_a = editor.editable) === null || _a === void 0 ? void 0 : _a.findByPath(path)) || [];
    };
    PortableTextEditor.focus = function (editor) {
        var _a;
        debug$3('Host requesting focus');
        (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.focus();
    };
    PortableTextEditor.focusBlock = function (editor) {
        var _a;
        return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.focusBlock();
    };
    PortableTextEditor.focusChild = function (editor) {
        var _a;
        return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.focusChild();
    };
    PortableTextEditor.getPortableTextFeatures = function (editor) {
        return editor.portableTextFeatures;
    };
    PortableTextEditor.getSelection = function (editor) {
        return editor.editable ? editor.editable.getSelection() : null;
    };
    PortableTextEditor.getValue = function (editor) {
        var _a;
        return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.getValue();
    };
    PortableTextEditor.hasBlockStyle = function (editor, blockStyle) {
        var _a;
        return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.hasBlockStyle(blockStyle);
    };
    PortableTextEditor.hasListStyle = function (editor, listStyle) {
        var _a;
        return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.hasListStyle(listStyle);
    };
    PortableTextEditor.isCollapsedSelection = function (editor) { var _a; return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.isCollapsedSelection(); };
    PortableTextEditor.isExpandedSelection = function (editor) { var _a; return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.isExpandedSelection(); };
    PortableTextEditor.isMarkActive = function (editor, mark) { var _a; return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.isMarkActive(mark); };
    PortableTextEditor.insertChild = function (editor, type, value) {
        var _a;
        debug$3("Host inserting child");
        return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.insertChild(type, value);
    };
    PortableTextEditor.insertBlock = function (editor, type, value) {
        var _a;
        return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.insertBlock(type, value);
    };
    PortableTextEditor.isVoid = function (editor, element) {
        var _a;
        return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.isVoid(element);
    };
    PortableTextEditor.isObjectPath = function (editor, path) {
        if (!path || !Array.isArray(path))
            return false;
        var isChildObjectEditPath = path.length > 3 && path[1] === 'children';
        var isBlockObjectEditPath = path.length > 1 && path[1] !== 'children';
        return isBlockObjectEditPath || isChildObjectEditPath;
    };
    PortableTextEditor.marks = function (editor) {
        var _a;
        return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.marks();
    };
    PortableTextEditor.select = function (editor, selection) {
        var _a;
        debug$3("Host setting selection", selection);
        (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.select(selection);
    };
    PortableTextEditor.removeAnnotation = function (editor, type) { var _a; return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.removeAnnotation(type); };
    PortableTextEditor.toggleBlockStyle = function (editor, blockStyle) {
        var _a;
        debug$3("Host is toggling block style");
        return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.toggleBlockStyle(blockStyle);
    };
    PortableTextEditor.toggleList = function (editor, listStyle) {
        var _a;
        return (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.toggleList(listStyle);
    };
    PortableTextEditor.toggleMark = function (editor, mark) {
        var _a;
        debug$3("Host toggling mark", mark);
        (_a = editor.editable) === null || _a === void 0 ? void 0 : _a.toggleMark(mark);
    };
    return PortableTextEditor;
}(React.Component));
var retrySync = throttle(function (syncFn, callbackFn) { return syncFn(callbackFn); }, 100);
function bufferUntil(emitWhen) {
    return function (source) {
        return defer(function () {
            var buffer = []; // custom buffer
            return source.pipe(tap(function (v) { return buffer.push(v); }), // add values to buffer
            switchMap(function () { return (emitWhen(buffer) ? of(buffer) : EMPTY); }), // emit the buffer when the condition is met
            tap(function () { return (buffer = []); }) // clear the buffer
            );
        });
    };
}
var NOOP$1 = function () { return undefined; };

/**
 * Try to compact a set of patches
 *
 */
function compactPatches(patches) {
    // If the last patch is unsetting everything, just do that
    var lastPatch = patches.slice(-1)[0];
    if (lastPatch && lastPatch.type === 'unset' && lastPatch.path.length === 0) {
        return [lastPatch];
    }
    var finalPatches = patches;
    // Run through the patches and remove any redundant ones.
    finalPatches = finalPatches.filter(function (patch, index) {
        if (!patch) {
            return false;
        }
        var nextPatch = finalPatches[index + 1];
        if (nextPatch &&
            nextPatch.type === 'set' &&
            patch.type === 'set' &&
            isEqual(patch.path, nextPatch.path)) {
            return false;
        }
        return true;
    });
    if (finalPatches.length !== patches.length) {
        return finalPatches;
    }
    return patches;
}

function normalizePoint(point, value) {
    if (!point || !value) {
        return null;
    }
    var newPath = [];
    var newOffset = point.offset || 0;
    var blockKey = typeof point.path[0] === 'object' && '_key' in point.path[0] && point.path[0]._key;
    var childKey = typeof point.path[2] === 'object' && '_key' in point.path[2] && point.path[2]._key;
    var block = value.find(function (blk) { return blk._key === blockKey; });
    if (block) {
        newPath.push({ _key: block._key });
    }
    else {
        return null;
    }
    if (block && point.path[1] === 'children') {
        if (!block.children || block.children.length === 0) {
            return null;
        }
        var child = block.children.find(function (cld) { return cld._key === childKey; });
        if (child) {
            newPath.push('children');
            newPath.push({ _key: child._key });
            newOffset =
                child.text && child.text.length >= point.offset
                    ? point.offset
                    : (child.text && child.text.length) || 0;
        }
        else {
            return null;
        }
    }
    return { path: newPath, offset: newOffset };
}
function normalizeSelection(selection, value) {
    if (!selection || !value || value.length === 0) {
        return null;
    }
    var newAnchor = null;
    var newFocus = null;
    var anchor = selection.anchor, focus = selection.focus;
    if (anchor && value.find(function (blk) { return isEqual({ _key: blk._key }, anchor.path[0]); })) {
        newAnchor = normalizePoint(anchor, value);
    }
    if (focus && value.find(function (blk) { return isEqual({ _key: blk._key }, focus.path[0]); })) {
        newFocus = normalizePoint(focus, value);
    }
    if (newAnchor && newFocus) {
        return { anchor: newAnchor, focus: newFocus };
    }
    return null;
}

function DefaultAnnotation(props) {
    // eslint-disable-next-line no-alert
    var handleClick = useCallback(function () { return alert(JSON.stringify(props.annotation)); }, [props.annotation]);
    return (React.createElement("span", { style: { color: 'blue' }, onClick: handleClick }, props.children));
}

var debug$2 = debugWithName('components:DraggableChild');
var DraggableChild = function (_a) {
    var children = _a.children, element = _a.element, readOnly = _a.readOnly;
    var editor = useSlateStatic();
    var dragGhostRef = useRef();
    var isVoid = useMemo(function () { return Editor.isVoid(editor, element); }, [editor, element]);
    // Note: this is called not for the dragging block, but for the targets when the block is dragged over them
    var handleDragOver = useCallback(function (event) {
        var isMyDragOver = IS_DRAGGING_CHILD_ELEMENT.get(editor);
        if (!isMyDragOver) {
            return;
        }
        debug$2('handle drag over');
        event.preventDefault(); // Needed to get the dropEffect showing
        event.dataTransfer.dropEffect = 'move';
        // Find the range where the drop happened
        var range = ReactEditor.findEventRange(editor, event);
        if (range) {
            IS_DRAGGING_ELEMENT_RANGE.set(editor, range);
            Transforms.select(editor, range);
        }
    }, [editor]);
    // Note: this is called for the dragging child
    var handleDragStart = useCallback(function (event) {
        debug$2('Drag start');
        IS_DRAGGING.set(editor, true);
        IS_DRAGGING_CHILD_ELEMENT.set(editor, element);
        if (isVoid) {
            event.dataTransfer.effectAllowed = 'move';
            // Specify dragImage so that single elements in the preview will not be the drag image,
            // but always the whole block preview itself.
            // Also clone it so that it will not be visually clipped by scroll-containers etc.
            var elm = event.currentTarget;
            if (elm instanceof HTMLElement) {
                var dragGhost = elm.cloneNode(true);
                dragGhostRef.current = dragGhost;
                dragGhost.style.width = "".concat(elm.clientWidth, "px");
                dragGhost.style.height = "".concat(elm.clientHeight, "px");
                dragGhost.style.position = 'absolute';
                dragGhost.style.top = '-99999px';
                dragGhost.style.left = '-99999px';
                if (document.body) {
                    document.body.appendChild(dragGhost);
                    var rect = elm.getBoundingClientRect();
                    var x = event.clientX - rect.left;
                    var y = event.clientY - rect.top;
                    dragGhost.style.width = "".concat(rect.width, "px");
                    dragGhost.style.height = "".concat(rect.height, "px");
                    event.dataTransfer.setDragImage(dragGhost, x, y);
                }
            }
        }
    }, [editor, element, isVoid]);
    if (readOnly) {
        return children;
    }
    return (React.createElement("span", { draggable: isVoid, onDragStart: handleDragStart, onDragOver: handleDragOver }, children));
};

debugWithName('components:Leaf');
var Leaf = function (props) {
    var editor = useSlateStatic();
    var selected = useSelected();
    var attributes = props.attributes, children = props.children, leaf = props.leaf, portableTextFeatures = props.portableTextFeatures, keyGenerator = props.keyGenerator, renderChild = props.renderChild, readOnly = props.readOnly;
    var spanRef = React.useRef(null);
    var returnedChildren = children;
    var focused = (selected && editor.selection && Range.isCollapsed(editor.selection)) || false;
    var handleMouseDown = useCallback(function (event) {
        // Slate will deselect this when it is already selected and clicked again, so prevent that. 2020/05/04
        if (focused) {
            event.stopPropagation();
            event.preventDefault();
        }
    }, [focused]);
    if (Text.isText(leaf) && leaf._type === portableTextFeatures.types.span.name) {
        var blockElement_1 = children.props.parent;
        var path_1 = blockElement_1 ? [{ _key: blockElement_1._key }, 'children', { _key: leaf._key }] : [];
        var decoratorValues_1 = portableTextFeatures.decorators.map(function (dec) { return dec.value; });
        var marks = uniq((Array.isArray(leaf.marks) ? leaf.marks : []).filter(function (mark) { return decoratorValues_1.includes(mark); }));
        marks.forEach(function (mark) {
            var _a, _b;
            var type = portableTextFeatures.decorators.find(function (dec) { return dec.value === mark; });
            if (type) {
                // TODO: look into this API!
                if ((_a = type === null || type === void 0 ? void 0 : type.blockEditor) === null || _a === void 0 ? void 0 : _a.render) {
                    var CustomComponent = (_b = type === null || type === void 0 ? void 0 : type.blockEditor) === null || _b === void 0 ? void 0 : _b.render;
                    returnedChildren = React.createElement(CustomComponent, { mark: mark }, returnedChildren);
                }
                if (props.renderDecorator) {
                    returnedChildren = props.renderDecorator(mark, type, { focused: focused, selected: selected, path: path_1 }, function () { return React.createElement(React.Fragment, null, returnedChildren); }, spanRef);
                }
            }
        });
        var annotationMarks = Array.isArray(leaf.marks) ? leaf.marks : [];
        var annotations_1 = annotationMarks
            .map(function (mark) {
            return !decoratorValues_1.includes(mark) &&
                blockElement_1 &&
                blockElement_1.markDefs &&
                blockElement_1.markDefs.find(function (def) { return def._key === mark; });
        })
            .filter(Boolean);
        if (annotations_1.length > 0) {
            annotations_1.forEach(function (annotation) {
                var _a;
                var type = portableTextFeatures.types.annotations.find(function (t) { return t.name === annotation._type; });
                // TODO: look into this API!
                var CustomComponent = (_a = type === null || type === void 0 ? void 0 : type.blockEditor) === null || _a === void 0 ? void 0 : _a.render;
                var defaultRender = function () {
                    // TODO: annotation should be an own prop here, keeping for backward compability (2020/05/18).
                    return CustomComponent ? (React.createElement(CustomComponent, __assign({}, annotation, { attributes: attributes }), returnedChildren)) : (React.createElement(React.Fragment, null, returnedChildren));
                };
                if (type) {
                    if (props.renderAnnotation) {
                        returnedChildren = (React.createElement("span", { ref: spanRef, key: keyGenerator() }, props.renderAnnotation(annotation, type, { focused: focused, selected: selected, path: path_1, annotations: annotations_1 }, defaultRender, spanRef)));
                    }
                    else {
                        returnedChildren = (React.createElement(DefaultAnnotation, { annotation: annotation },
                            React.createElement("span", { ref: spanRef, key: keyGenerator(), onMouseDown: handleMouseDown }, defaultRender())));
                    }
                }
            });
        }
        if (blockElement_1 && renderChild) {
            var child = blockElement_1.children.find(function (_child) { return _child._key === leaf._key; }); // Ensure object equality
            if (child) {
                returnedChildren = renderChild(child, portableTextFeatures.types.span, { focused: focused, selected: selected, path: path_1, annotations: annotations_1 }, function () { return returnedChildren; }, spanRef);
            }
        }
    }
    var key = leaf._key || keyGenerator();
    return (React.createElement("span", __assign({ key: key }, attributes, { ref: spanRef }),
        React.createElement(DraggableChild, { element: leaf, readOnly: readOnly }, returnedChildren)));
};

var DefaultBlockObject = styled.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  user-select: none;\n  border: ", ";\n"], ["\n  user-select: none;\n  border: ", ";\n"])), function (props) {
    if (props.selected) {
        return '1px solid blue';
    }
    return '1px solid transparent';
});
styled.span(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n  background: #999;\n  border: ", ";\n"], ["\n  background: #999;\n  border: ", ";\n"])), function (props) {
    if (props.selected) {
        return '1px solid blue';
    }
    return '1px solid transparent';
});
var DefaultListItem = styled.div(templateObject_3 || (templateObject_3 = __makeTemplateObject(["\n  &.pt-list-item {\n    width: fit-content;\n    position: relative;\n    display: block;\n\n    /* Important 'transform' in order to force refresh the ::before and ::after rules\n      in Webkit: https://stackoverflow.com/a/21947628/831480\n    */\n    transform: translateZ(0);\n    margin-left: ", ";\n  }\n  &.pt-list-item > .pt-list-item-inner {\n    display: flex;\n    margin: 0;\n    padding: 0;\n    &:before {\n      justify-content: flex-start;\n      vertical-align: top;\n    }\n  }\n  &.pt-list-item-bullet > .pt-list-item-inner:before {\n      content: '", "';\n      font-size: 0.4375rem; /* 7px */\n      line-height: 1.5rem; /* Same as body text */\n      /* Optical alignment */\n      position: relative;\n    }\n  }\n  &.pt-list-item-bullet > .pt-list-item-inner {\n    &:before {\n      min-width: 1.5rem; /* Make sure space between bullet and text never shrinks */\n    }\n  }\n  &.pt-list-item-number {\n    counter-increment: ", ";\n    counter-reset: ", ";\n  }\n  & + :not(.pt-list-item-number) {\n    counter-reset: listItemNumber;\n  }\n  &.pt-list-item-number > .pt-list-item-inner:before {\n    content: ", ";\n    min-width: 1.5rem; /* Make sure space between number and text never shrinks */\n    /* Optical alignment */\n    position: relative;\n    top: 1px;\n  }\n"], ["\n  &.pt-list-item {\n    width: fit-content;\n    position: relative;\n    display: block;\n\n    /* Important 'transform' in order to force refresh the ::before and ::after rules\n      in Webkit: https://stackoverflow.com/a/21947628/831480\n    */\n    transform: translateZ(0);\n    margin-left: ", ";\n  }\n  &.pt-list-item > .pt-list-item-inner {\n    display: flex;\n    margin: 0;\n    padding: 0;\n    &:before {\n      justify-content: flex-start;\n      vertical-align: top;\n    }\n  }\n  &.pt-list-item-bullet > .pt-list-item-inner:before {\n      content: '", "';\n      font-size: 0.4375rem; /* 7px */\n      line-height: 1.5rem; /* Same as body text */\n      /* Optical alignment */\n      position: relative;\n    }\n  }\n  &.pt-list-item-bullet > .pt-list-item-inner {\n    &:before {\n      min-width: 1.5rem; /* Make sure space between bullet and text never shrinks */\n    }\n  }\n  &.pt-list-item-number {\n    counter-increment: ", ";\n    counter-reset: ", ";\n  }\n  & + :not(.pt-list-item-number) {\n    counter-reset: listItemNumber;\n  }\n  &.pt-list-item-number > .pt-list-item-inner:before {\n    content: ", ";\n    min-width: 1.5rem; /* Make sure space between number and text never shrinks */\n    /* Optical alignment */\n    position: relative;\n    top: 1px;\n  }\n"])), function (props) { return getLeftPositionForListLevel(props.listLevel); }, function (props) {
    return getContentForListLevelAndStyle(props.listLevel, props.listStyle);
}, function (props) {
    return getCounterIncrementForListLevel(props.listLevel);
}, function (props) { return getCounterResetForListLevel(props.listLevel); }, function (props) { return getCounterContentForListLevel(props.listLevel); });
var DefaultListItemInner = styled.div(templateObject_4 || (templateObject_4 = __makeTemplateObject([""], [""])));
function getLeftPositionForListLevel(level) {
    switch (Number(level)) {
        case 1:
            return '1.5em';
        case 2:
            return '3em';
        case 3:
            return '4.5em';
        case 4:
            return '6em';
        case 5:
            return '7.5em';
        case 6:
            return '9em';
        case 7:
            return '10.5em';
        case 8:
            return '12em';
        case 9:
            return '13.5em';
        case 10:
            return '15em';
        default:
            return '0em';
    }
}
var bullets = ['', '', ''];
function getContentForListLevelAndStyle(level, style) {
    var normalizedLevel = (level - 1) % 3;
    if (style === 'bullet') {
        return bullets[normalizedLevel];
    }
    return '*';
}
function getCounterIncrementForListLevel(level) {
    switch (level) {
        case 1:
            return 'listItemNumber';
        case 2:
            return 'listItemAlpha';
        case 3:
            return 'listItemRoman';
        case 4:
            return 'listItemNumberNext';
        case 5:
            return 'listItemLetterNext';
        case 6:
            return 'listItemRomanNext';
        case 7:
            return 'listItemNumberNextNext';
        case 8:
            return 'listItemAlphaNextNext';
        case 9:
            return 'listItemRomanNextNext';
        default:
            return 'listItemNumberNextNextNext';
    }
}
function getCounterResetForListLevel(level) {
    switch (level) {
        case 1:
            return 'listItemAlpha';
        case 2:
            return 'listItemRoman';
        case 3:
            return 'listItemNumberNext';
        case 4:
            return 'listItemLetterNext';
        case 5:
            return 'listItemRomanNext';
        case 6:
            return 'listItemNumberNextNext';
        case 7:
            return 'listItemAlphaNextNext';
        case 8:
            return 'listItemRomanNextNext';
        case 9:
            return 'listItemNumberNextNextNext';
        default:
            return 'listItemNumberNextNextNext';
    }
}
function getCounterContentForListLevel(level) {
    switch (level) {
        case 1:
            return "counter(listItemNumber) '. '";
        case 2:
            return "counter(listItemAlpha, lower-alpha) '. '";
        case 3:
            return "counter(listItemRoman, lower-roman) '. '";
        case 4:
            return "counter(listItemNumberNext) '. '";
        case 5:
            return "counter(listItemLetterNext, lower-alpha) '. '";
        case 6:
            return "counter(listItemRomanNext, lower-roman) '. '";
        case 7:
            return "counter(listItemNumberNextNext) '. '";
        case 8:
            return "counter(listItemAlphaNextNext, lower-alpha) '. '";
        case 9:
            return "counter(listItemRomanNextNext, lower-roman) '. '";
        default:
            return "counter(listItemNumberNextNextNext) '. '";
    }
}
var templateObject_1, templateObject_2, templateObject_3, templateObject_4;

function TextBlock(props) {
    var portableTextFeatures = props.portableTextFeatures, children = props.children, block = props.block;
    var style = block.style || portableTextFeatures.styles[0].value;
    // Should we render a custom style?
    // TODO: Look into this API. This is legacy support for older Sanity Studio versions via the type
    var CustomStyle;
    var blockStyle = portableTextFeatures && style
        ? portableTextFeatures.styles.find(function (item) { return item.value === style; })
        : undefined;
    if (blockStyle) {
        CustomStyle = blockStyle.blockEditor && blockStyle.blockEditor.render;
    }
    var renderedBlock = children;
    if ('listItem' in block && block.listItem) {
        renderedBlock = (React.createElement(DefaultListItem, { listStyle: block.listItem || portableTextFeatures.lists[0].value, listLevel: block.level || 0 },
            React.createElement(DefaultListItemInner, null, renderedBlock)));
    }
    return (React.createElement(React.Fragment, null,
        !CustomStyle && renderedBlock,
        CustomStyle && React.createElement(CustomStyle, { style: style }, renderedBlock)));
}

var DefaultObject = function (props) {
    return React.createElement("pre", null, JSON.stringify(props.value, null, 2));
};

var debug$1 = debugWithName('components:DraggableBlock');
var DraggableBlock = function (_a) {
    var children = _a.children, element = _a.element, readOnly = _a.readOnly, blockRef = _a.blockRef;
    var editor = useSlateStatic();
    var dragGhostRef = useRef();
    var _b = __read(useState(false), 2), isDragOver = _b[0], setIsDragOver = _b[1];
    var isVoid = useMemo(function () { return Editor.isVoid(editor, element); }, [editor, element]);
    var isInline = useMemo(function () { return Editor.isInline(editor, element); }, [editor, element]);
    var _c = __read(useState(null), 2), blockElement = _c[0], setBlockElement = _c[1];
    useEffect(function () { return setBlockElement(blockRef ? blockRef.current : ReactEditor.toDOMNode(editor, element)); }, [editor, element, blockRef]);
    // Note: this is called not for the dragging block, but for the targets when the block is dragged over them
    var handleDragOver = useCallback(function (event) {
        var isMyDragOver = IS_DRAGGING_BLOCK_ELEMENT.get(editor);
        // debug('Drag over', blockElement)
        if (!isMyDragOver || !blockElement) {
            return;
        }
        event.preventDefault();
        event.dataTransfer.dropEffect = 'move';
        IS_DRAGGING_ELEMENT_TARGET.set(editor, element);
        var elementRect = blockElement.getBoundingClientRect();
        var offset = elementRect.top;
        var height = elementRect.height;
        var Y = event.pageY;
        var loc = Math.abs(offset - Y);
        var position = 'bottom';
        if (element === editor.children[0]) {
            position = 'top';
        }
        else if (loc < height / 2) {
            position = 'top';
            IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor, position);
        }
        else {
            position = 'bottom';
            IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor, position);
        }
        if (isMyDragOver === element) {
            event.dataTransfer.dropEffect = 'none';
            return;
        }
        setIsDragOver(true);
    }, [blockElement, editor, element]);
    // Note: this is called not for the dragging block, but for the targets when the block is dragged over them
    var handleDragLeave = useCallback(function () {
        setIsDragOver(false);
    }, []);
    // Note: this is called for the dragging block
    var handleDragEnd = useCallback(function (event) {
        var targetBlock = IS_DRAGGING_ELEMENT_TARGET.get(editor);
        if (targetBlock) {
            IS_DRAGGING.set(editor, false);
            event.preventDefault();
            event.stopPropagation();
            IS_DRAGGING_ELEMENT_TARGET.delete(editor);
            if (dragGhostRef.current) {
                debug$1('Removing drag ghost');
                document.body.removeChild(dragGhostRef.current);
            }
            var dragPosition_1 = IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor);
            IS_DRAGGING_BLOCK_TARGET_POSITION.delete(editor);
            var targetPath = ReactEditor.findPath(editor, targetBlock);
            var myPath = ReactEditor.findPath(editor, element);
            var isBefore = Path.isBefore(myPath, targetPath);
            if (dragPosition_1 === 'bottom' && !isBefore) {
                // If it is already at the bottom, don't do anything.
                if (targetPath[0] >= editor.children.length - 1) {
                    debug$1('target is already at the bottom, not moving');
                    return;
                }
                var originalPath = targetPath;
                targetPath = Path.next(targetPath);
                debug$1("Adjusting targetPath from ".concat(JSON.stringify(originalPath), " to ").concat(JSON.stringify(targetPath)));
            }
            if (dragPosition_1 === 'top' && isBefore && targetPath[0] !== editor.children.length - 1) {
                var originalPath = targetPath;
                targetPath = Path.previous(targetPath);
                debug$1("Adjusting targetPath from ".concat(JSON.stringify(originalPath), " to ").concat(JSON.stringify(targetPath)));
            }
            if (Path.equals(targetPath, myPath)) {
                event.preventDefault();
                debug$1('targetPath and myPath is the same, not moving');
                return;
            }
            debug$1("Moving element ".concat(element._key, " from path ").concat(JSON.stringify(myPath), " to ").concat(JSON.stringify(targetPath), " (").concat(dragPosition_1, ")"));
            Transforms.moveNodes(editor, { at: myPath, to: targetPath });
            editor.onChange();
            return;
        }
        debug$1('No target element, not doing anything');
    }, [editor, element]);
    // Note: this is called not for the dragging block, but for the drop target
    var handleDrop = useCallback(function (event) {
        if (IS_DRAGGING_BLOCK_ELEMENT.get(editor)) {
            debug$1('On drop (prevented)', element);
            event.preventDefault();
            event.stopPropagation();
            setIsDragOver(false);
        }
    }, [editor, element]);
    // Note: this is called for the dragging block
    var handleDrag = useCallback(function (event) {
        if (!isVoid) {
            IS_DRAGGING_BLOCK_ELEMENT.delete(editor);
            return;
        }
        IS_DRAGGING.set(editor, true);
        IS_DRAGGING_BLOCK_ELEMENT.set(editor, element);
        event.stopPropagation(); // Stop propagation so that leafs don't get this and take focus/selection!
        var target = event.target;
        if (target instanceof HTMLElement) {
            target.style.opacity = '1';
        }
    }, [editor, element, isVoid]);
    // Note: this is called for the dragging block
    var handleDragStart = useCallback(function (event) {
        if (!isVoid || isInline) {
            debug$1('Not dragging block');
            IS_DRAGGING_BLOCK_ELEMENT.delete(editor);
            IS_DRAGGING.set(editor, false);
            return;
        }
        debug$1('Drag start');
        IS_DRAGGING.set(editor, true);
        if (event.dataTransfer) {
            event.dataTransfer.setData('application/portable-text', 'something');
            event.dataTransfer.effectAllowed = 'move';
        }
        // Clone blockElement so that it will not be visually clipped by scroll-containers etc.
        // The application that uses the portable-text-editor may indicate the element used as
        // drag ghost by adding a truthy data attribute 'data-pt-drag-ghost-element' to a HTML element.
        if (blockElement && blockElement instanceof HTMLElement) {
            var dragGhost = blockElement.cloneNode(true);
            var customGhost = dragGhost.querySelector('[data-pt-drag-ghost-element]');
            if (customGhost) {
                dragGhost = customGhost;
            }
            // Set the `data-dragged` attribute so the consumer can style the element while its dragged
            dragGhost.setAttribute('data-dragged', '');
            if (document.body) {
                dragGhostRef.current = dragGhost;
                dragGhost.style.position = 'absolute';
                dragGhost.style.left = '-99999px';
                dragGhost.style.boxSizing = 'border-box';
                document.body.appendChild(dragGhost);
                var rect = blockElement.getBoundingClientRect();
                var x = event.clientX - rect.left;
                var y = event.clientY - rect.top;
                dragGhost.style.width = "".concat(rect.width, "px");
                dragGhost.style.height = "".concat(rect.height, "px");
                event.dataTransfer.setDragImage(dragGhost, x, y);
            }
        }
        handleDrag(event);
    }, [blockElement, editor, handleDrag, isInline, isVoid]);
    var isDraggingOverFirstBlock = isDragOver && editor.children[0] === IS_DRAGGING_ELEMENT_TARGET.get(editor);
    var isDraggingOverLastBlock = isDragOver &&
        editor.children[editor.children.length - 1] === IS_DRAGGING_ELEMENT_TARGET.get(editor);
    var dragPosition = IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor);
    var isDraggingOverTop = isDraggingOverFirstBlock ||
        (isDragOver && !isDraggingOverFirstBlock && !isDraggingOverLastBlock && dragPosition === 'top');
    var isDraggingOverBottom = isDraggingOverLastBlock ||
        (isDragOver &&
            !isDraggingOverFirstBlock &&
            !isDraggingOverLastBlock &&
            dragPosition === 'bottom');
    var dropIndicator = useMemo(function () { return (React.createElement("div", { className: "pt-drop-indicator", style: {
            position: 'absolute',
            width: '100%',
            height: 1,
            borderBottom: '1px solid currentColor',
            zIndex: 5,
        } })); }, []);
    if (readOnly) {
        return React.createElement(React.Fragment, null, children);
    }
    return (React.createElement("div", { draggable: isVoid, onDragStart: handleDragStart, onDrag: handleDrag, onDragOver: handleDragOver, onDragLeave: handleDragLeave, onDragEnd: handleDragEnd, onDrop: handleDrop },
        isDraggingOverTop && dropIndicator,
        children,
        isDraggingOverBottom && dropIndicator));
};

debugWithName('components:Element');
var inlineBlockStyle = { display: 'inline-block' };
var defaultRender = function (value) {
    return React.createElement(DefaultObject, { value: value });
};
// eslint-disable-next-line max-statements
var Element = function (_a) {
    var attributes = _a.attributes, children = _a.children, element = _a.element, portableTextFeatures = _a.portableTextFeatures, readOnly = _a.readOnly, renderBlock = _a.renderBlock, renderChild = _a.renderChild, spellCheck = _a.spellCheck;
    var editor = useSlateStatic();
    var selected = useSelected();
    var blockRef = useRef(null);
    var inlineBlockObjectRef = useRef(null);
    var focused = (selected && editor.selection && Range.isCollapsed(editor.selection)) || false;
    var className;
    if (typeof element._type !== 'string') {
        throw new Error("Expected element to have a _type property");
    }
    if (typeof element._key !== 'string') {
        throw new Error("Expected element to have a _key property");
    }
    // Test for inline objects first
    if (editor.isInline(element)) {
        var path = ReactEditor.findPath(editor, element);
        var _b = __read(Editor.node(editor, path, { depth: 1 }), 1), block_1 = _b[0];
        var type_1 = portableTextFeatures.types.inlineObjects.find(function (_type) { return _type.name === element._type; });
        if (!type_1) {
            throw new Error('Could not find type for inline block element');
        }
        if (Element$1.isElement(block_1)) {
            var elmPath = [{ _key: block_1._key }, 'children', { _key: element._key }];
            return (React.createElement("span", __assign({}, attributes),
                children,
                React.createElement(DraggableChild, { element: element, readOnly: readOnly },
                    React.createElement("span", { className: "pt-inline-object", ref: inlineBlockObjectRef, key: element._key, style: inlineBlockStyle, contentEditable: false },
                        renderChild &&
                            renderChild(fromSlateValue([element], portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0], type_1, { focused: focused, selected: selected, path: elmPath }, defaultRender, inlineBlockObjectRef),
                        !renderChild &&
                            defaultRender(fromSlateValue([element], portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0])))));
        }
        throw new Error('Block not found!');
    }
    var renderAttribs = { focused: focused, selected: selected, path: [{ _key: element._key }] };
    // If not inline, it's either a block (text) or a block object (non-text)
    // NOTE: text blocks aren't draggable with DraggableBlock (yet?)
    if (element._type === portableTextFeatures.types.block.name) {
        className = "pt-block pt-text-block";
        var isListItem = 'listItem' in element;
        var hasStyle = 'style' in element;
        if (hasStyle) {
            renderAttribs.style = element.style || 'normal';
            className = "pt-block pt-text-block pt-text-block-style-".concat(element.style);
        }
        if (isListItem) {
            renderAttribs.listItem = element.listItem;
            if (Number.isInteger(element.level)) {
                renderAttribs.level = element.level;
            }
            else {
                renderAttribs.level = 1;
            }
            className += " pt-list-item pt-list-item-".concat(renderAttribs.listItem, " pt-list-item-level-").concat(renderAttribs.level);
        }
        var textBlock_1 = (React.createElement(TextBlock, { block: element, portableTextFeatures: portableTextFeatures }, children));
        var propsOrDefaultRendered = renderBlock
            ? renderBlock(fromSlateValue([element], element._type, KEY_TO_VALUE_ELEMENT.get(editor))[0], portableTextFeatures.types.block, renderAttribs, function () { return textBlock_1; }, blockRef)
            : textBlock_1;
        return (React.createElement("div", __assign({ key: element._key }, attributes, { className: className, spellCheck: spellCheck }),
            React.createElement(DraggableBlock, { element: element, readOnly: readOnly, blockRef: blockRef },
                React.createElement("div", { ref: blockRef }, propsOrDefaultRendered))));
    }
    var type = portableTextFeatures.types.blockObjects.find(function (_type) { return _type.name === element._type; });
    if (!type) {
        throw new Error("Could not find schema type for block element of _type ".concat(element._type));
    }
    className = 'pt-block pt-object-block';
    var block = fromSlateValue([element], portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];
    var renderedBlockFromProps = renderBlock && renderBlock(block, type, renderAttribs, defaultRender, blockRef);
    return (React.createElement("div", __assign({ key: element._key }, attributes, { className: className }),
        children,
        React.createElement(DraggableBlock, { element: element, readOnly: readOnly, blockRef: blockRef },
            renderedBlockFromProps && (React.createElement("div", { ref: blockRef, contentEditable: false }, renderedBlockFromProps)),
            !renderedBlockFromProps && (React.createElement(DefaultBlockObject, { selected: selected }, defaultRender(fromSlateValue([element], portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0]))))));
};

var useIsomorphicEffect = typeof window === 'undefined' ? useEffect : useLayoutEffect;
function useForwardedRef(ref) {
    var innerRef = useRef(null);
    useIsomorphicEffect(function () {
        if (!ref)
            return;
        if (typeof ref === 'function') {
            ref(innerRef.current);
        }
        else {
            ref.current = innerRef.current;
        }
    });
    return innerRef;
}

var debug = debugWithName('component:Editable');
var PLACEHOLDER_STYLE = {
    opacity: 0.5,
    position: 'absolute',
    userSelect: 'none',
    pointerEvents: 'none',
};
var NOOP = function () {
    // Nope
};
var EMPTY_DECORATORS = [];
var PortableTextEditable = forwardRef(function PortableTextEditable(props, forwardedRef) {
    var hotkeys = props.hotkeys, onBeforeInput = props.onBeforeInput, onPaste = props.onPaste, onCopy = props.onCopy, renderAnnotation = props.renderAnnotation, renderBlock = props.renderBlock, renderChild = props.renderChild, renderDecorator = props.renderDecorator, renderPlaceholder = props.renderPlaceholder, propsSelection = props.selection, scrollSelectionIntoView = props.scrollSelectionIntoView, spellCheck = props.spellCheck, restProps = __rest(props, ["hotkeys", "onBeforeInput", "onPaste", "onCopy", "renderAnnotation", "renderBlock", "renderChild", "renderDecorator", "renderPlaceholder", "selection", "scrollSelectionIntoView", "spellCheck"]);
    var portableTextEditor = usePortableTextEditor();
    var readOnly = usePortableTextEditorReadOnlyStatus();
    var ref = useForwardedRef(forwardedRef);
    var change$ = portableTextEditor.change$, keyGenerator = portableTextEditor.keyGenerator, portableTextFeatures = portableTextEditor.portableTextFeatures, slateEditor = portableTextEditor.slateInstance;
    // React/UI-spesific plugins
    var withInsertData = useMemo(function () { return createWithInsertData(change$, portableTextFeatures, keyGenerator); }, [change$, keyGenerator, portableTextFeatures]);
    var withHotKeys = useMemo(function () { return createWithHotkeys(portableTextFeatures, keyGenerator, portableTextEditor, hotkeys); }, [hotkeys, keyGenerator, portableTextEditor, portableTextFeatures]);
    // Output a minimal React editor inside Editable when in readOnly mode.
    // NOTE: make sure all the plugins used here can be safely run over again at any point.
    // There will be a problem if they redefine editor methods and then calling the original method within themselves.
    useMemo(function () {
        if (readOnly) {
            debug('Editable is in read only mode');
            return withInsertData(slateEditor);
        }
        debug('Editable is in edit mode');
        return withInsertData(withHotKeys(slateEditor));
    }, [readOnly, slateEditor, withHotKeys, withInsertData]);
    var renderElement = useCallback(function (eProps) { return (React.createElement(Element, __assign({}, eProps, { portableTextFeatures: portableTextFeatures, readOnly: readOnly, renderBlock: renderBlock, renderChild: renderChild, spellCheck: spellCheck }))); }, [portableTextFeatures, spellCheck, readOnly, renderBlock, renderChild]);
    var renderLeaf = useCallback(function (lProps) {
        if (renderPlaceholder && lProps.leaf.placeholder && lProps.text.text === '') {
            return (React.createElement(React.Fragment, null,
                React.createElement("div", { style: PLACEHOLDER_STYLE, contentEditable: false }, renderPlaceholder()),
                React.createElement(Leaf, __assign({}, lProps, { keyGenerator: keyGenerator, portableTextFeatures: portableTextFeatures, renderAnnotation: renderAnnotation, renderChild: renderChild, renderDecorator: renderDecorator, readOnly: readOnly }))));
        }
        return (React.createElement(Leaf, __assign({}, lProps, { keyGenerator: keyGenerator, portableTextFeatures: portableTextFeatures, renderAnnotation: renderAnnotation, renderChild: renderChild, renderDecorator: renderDecorator, readOnly: readOnly })));
    }, [
        readOnly,
        keyGenerator,
        portableTextFeatures,
        renderAnnotation,
        renderChild,
        renderDecorator,
        renderPlaceholder,
    ]);
    // Restore selection from props
    useEffect(function () {
        if (propsSelection) {
            debug("Selection from props ".concat(JSON.stringify(propsSelection)));
            var normalizedSelection = normalizeSelection(propsSelection, fromSlateValue(slateEditor.children, portableTextFeatures.types.block.name));
            if (normalizedSelection !== null) {
                debug("Normalized selection from props ".concat(JSON.stringify(normalizedSelection)));
                var slateRange = toSlateRange(normalizedSelection, slateEditor);
                if (slateRange) {
                    Transforms.select(slateEditor, slateRange);
                    // Output selection here in those cases where the editor selection was the same, and there are no set selection operations in the
                    // editor (this is usually automatically outputted by the withPortableTextSelections plugin)
                    if (!slateEditor.operations.some(function (o) { return o.type === 'set_selection'; })) {
                        change$.next({ type: 'selection', selection: normalizedSelection });
                    }
                    slateEditor.onChange();
                }
            }
        }
    }, [slateEditor, propsSelection, portableTextFeatures.types.block.name, change$]);
    // Set initial selection from props
    useEffect(function () {
        if (propsSelection) {
            PortableTextEditor.select(portableTextEditor, propsSelection);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []); // Only initial
    // Handle from props onCopy function
    var handleCopy = useCallback(function (event) {
        if (onCopy) {
            var result = onCopy(event);
            // CopyFn may return something to avoid doing default stuff
            if (result !== undefined) {
                event.preventDefault();
            }
        }
    }, [onCopy]);
    // Handle incoming pasting events in the editor
    var handlePaste = useCallback(function (event) {
        event.preventDefault();
        if (!slateEditor.selection) {
            return;
        }
        if (!onPaste) {
            debug('Pasting normally');
            slateEditor.insertData(event.clipboardData);
            return;
        }
        // Resolve it as promise (can be either async promise or sync return value)
        new Promise(function (resolve) {
            var _a;
            resolve(onPaste({
                event: event,
                value: PortableTextEditor.getValue(portableTextEditor),
                path: ((_a = slateEditor.selection) === null || _a === void 0 ? void 0 : _a.focus.path) || [],
                portableTextFeatures: portableTextFeatures,
                type: portableTextFeatures.types.portableText, // For legacy support
            }));
        })
            .then(function (result) {
            debug('Custom paste function from client resolved', result);
            change$.next({ type: 'loading', isLoading: true });
            if (!result || !result.insert) {
                debug('No result from custom paste handler, pasting normally');
                slateEditor.insertData(event.clipboardData);
                return;
            }
            if (result && result.insert) {
                slateEditor.insertFragment(toSlateValue(result.insert, { portableTextFeatures: portableTextFeatures }));
                change$.next({ type: 'loading', isLoading: false });
                return;
            }
            console.warn('Your onPaste function returned something unexpected:', result);
        })
            .catch(function (error) {
            change$.next({ type: 'loading', isLoading: false });
            console.error(error); // eslint-disable-line no-console
            return error;
        });
    }, [change$, onPaste, portableTextEditor, portableTextFeatures, slateEditor]);
    var handleOnFocus = useCallback(function () {
        change$.next({ type: 'focus' });
    }, [change$]);
    var handleOnBlur = useCallback(function () {
        change$.next({ type: 'blur' });
    }, [change$]);
    var handleOnBeforeInput = useCallback(function (event) {
        if (onBeforeInput) {
            onBeforeInput(event);
        }
    }, [onBeforeInput]);
    var handleKeyDown = slateEditor.pteWithHotKeys;
    var scrollSelectionIntoViewToSlate = useMemo(function () {
        // Use slate-react default scroll into view
        if (scrollSelectionIntoView === undefined) {
            return undefined;
        }
        // Disable scroll into view totally
        if (scrollSelectionIntoView === null) {
            return NOOP;
        }
        // Translate PortableTextEditor prop fn to Slate plugin fn
        return function (editor, domRange) {
            scrollSelectionIntoView(portableTextEditor, domRange);
        };
    }, [portableTextEditor, scrollSelectionIntoView]);
    var decorate = useCallback(function () {
        if (isEqualToEmptyEditor(slateEditor.children, portableTextFeatures)) {
            return [
                {
                    anchor: {
                        path: [0, 0],
                        offset: 0,
                    },
                    focus: {
                        path: [0, 0],
                        offset: 0,
                    },
                    placeholder: true,
                },
            ];
        }
        return EMPTY_DECORATORS;
    }, [portableTextFeatures, slateEditor.children]);
    // The editor
    var slateEditable = useMemo(function () { return (React.createElement(Editable, { autoFocus: false, className: "pt-editable", decorate: decorate, onBlur: handleOnBlur, onCopy: handleCopy, onDOMBeforeInput: handleOnBeforeInput, onFocus: handleOnFocus, onKeyDown: handleKeyDown, onPaste: handlePaste, readOnly: readOnly, renderElement: renderElement, renderLeaf: renderLeaf, scrollSelectionIntoView: scrollSelectionIntoViewToSlate })); }, [
        decorate,
        handleCopy,
        handleKeyDown,
        handleOnBeforeInput,
        handleOnBlur,
        handleOnFocus,
        handlePaste,
        readOnly,
        renderElement,
        renderLeaf,
        scrollSelectionIntoViewToSlate,
    ]);
    if (!portableTextEditor) {
        return null;
    }
    return (React.createElement("div", __assign({ ref: ref }, restProps), slateEditable));
});

export { PortableTextEditable, PortableTextEditor, compactPatches, getPortableTextFeatures, defaultKeyGenerator as keyGenerator, usePortableTextEditor, usePortableTextEditorSelection };
//# sourceMappingURL=index.js.map

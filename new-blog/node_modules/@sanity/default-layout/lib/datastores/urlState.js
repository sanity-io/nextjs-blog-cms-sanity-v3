"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isStateUpdateEvent = isStateUpdateEvent;
exports.navigate = navigate;
exports.state = void 0;
var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));
var _location = _interopRequireDefault(require("part:@sanity/base/location"));
var _rxjs = require("rxjs");
var _operators = require("rxjs/operators");
var _router = _interopRequireDefault(require("../router"));
var _getOrderedTools = _interopRequireDefault(require("../util/getOrderedTools"));
var _reconfigureClient = _interopRequireDefault(require("../util/reconfigureClient"));
var _spaces = require("../util/spaces");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function resolveUrlStateWithDefaultSpace(state) {
  if (!_spaces.HAS_SPACES || !state || state.space) {
    return state;
  }
  var defaultSpace = _spaces.CONFIGURED_SPACES.find(ds => ds.default) || _spaces.CONFIGURED_SPACES[0];
  return Object.assign({}, state, {
    space: defaultSpace.name
  });
}
function resolveUrlStateWithDefaultTool(state) {
  var defaultTool = (0, _getOrderedTools.default)()[0];
  if (!state || state.tool || !defaultTool) {
    return state;
  }
  return Object.assign({}, state, {
    tool: defaultTool.name
  });
}
function makeBackwardsCompatible(state) {
  if (!state) {
    return state;
  }
  if ((0, _getOrderedTools.default)().find(tool => tool.name === state.space)) {
    return Object.assign({}, state, {
      tool: state.space,
      space: undefined
    });
  }
  return state;
}
function resolveDefaultState(state) {
  var urlStateWithDefaultTool = resolveUrlStateWithDefaultTool(makeBackwardsCompatible(state));
  return _spaces.HAS_SPACES ? resolveUrlStateWithDefaultSpace(urlStateWithDefaultTool) : urlStateWithDefaultTool;
}
function resolveIntentState(currentState, intentState) {
  var intent = intentState.intent,
    params = intentState.params,
    payload = intentState.payload;
  var tools = (0, _getOrderedTools.default)();
  var currentTool = currentState.tool ? tools.find(tool => tool.name === currentState.tool) : null;

  // If current tool can handle intent and if so, give it precedence
  var matchingTool = (currentTool ? [currentTool, ...tools] : tools).find(tool => tool && typeof tool.canHandleIntent === 'function' && tool.canHandleIntent(intent, params, currentState[tool.name]));
  if (matchingTool !== null && matchingTool !== void 0 && matchingTool.getIntentState) {
    var toolState = matchingTool.getIntentState(intent, params, currentState[matchingTool.name], payload);
    var currentWithState = resolveUrlStateWithDefaultSpace(currentState) || currentState;
    return Object.assign({}, currentWithState, {
      tool: matchingTool.name,
      [matchingTool.name]: toolState
    });
  }
  return {
    isNotFound: true,
    intent: {
      name: intent,
      params
    }
  };
}
function maybeHandleIntent(prevEvent, currentEvent) {
  if (currentEvent && currentEvent.state && currentEvent.state.intent) {
    var redirectState = resolveIntentState(prevEvent ? prevEvent.state : {}, currentEvent.state);
    if (redirectState) {
      var newUrl = _router.default.encode(redirectState);
      setTimeout(() => navigate(newUrl, {
        replace: true
      }), 0);
      return null;
    }
  }
  return currentEvent;
}
function decodeUrlState(locationEvent) {
  return {
    type: locationEvent.type,
    state: _router.default.decode(location.pathname),
    isNotFound: _router.default.isNotFound(location.pathname)
  };
}
function maybeRedirectDefaultState(event) {
  var redirectState = resolveDefaultState(event.state);
  if (redirectState !== event.state) {
    navigate(_router.default.encode(redirectState), {
      replace: true
    });
    return null;
  }
  return event;
}
function navigate(newUrl, options) {
  _location.default.actions.navigate(newUrl, options);
}
var state = _location.default.state.pipe((0, _operators.map)(decodeUrlState), (0, _operators.scan)(maybeHandleIntent, null), (0, _operators.filter)(Boolean), (0, _operators.map)(maybeRedirectDefaultState), (0, _operators.filter)(Boolean), (0, _operators.distinctUntilChanged)(_isEqual2.default), (0, _operators.catchError)(err => (0, _rxjs.of)({
  type: 'error',
  error: err
})), (0, _operators.publishReplay)(1), (0, _operators.refCount)());
exports.state = state;
function isStateUpdateEvent(event) {
  return event.type === 'snapshot' || event.type === 'change';
}
if (_spaces.HAS_SPACES) {
  // Uglybugly mutation ahead.
  state.pipe((0, _operators.filter)(isStateUpdateEvent), (0, _operators.map)(event => event.state), (0, _operators.filter)(Boolean), (0, _operators.tap)(_reconfigureClient.default)).subscribe();
}
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useScrollSelectionIntoView = useScrollSelectionIntoView;
var _portableTextEditor = require("@sanity/portable-text-editor");
var _react = require("react");
var _scrollIntoViewIfNeeded = _interopRequireDefault(require("scroll-into-view-if-needed"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// This hook is used to scroll the editor selection into place when actively editing the document.
function useScrollSelectionIntoView(scrollElement) {
  return (0, _react.useMemo)(() => (editor, domRange) => {
    var selection = _portableTextEditor.PortableTextEditor.getSelection(editor);
    if (selection) {
      var leafEl = domRange.startContainer.parentElement;
      if (!leafEl) {
        return;
      }
      var originalGetBoundingClientRect = leafEl.getBoundingClientRect;
      leafEl.getBoundingClientRect = domRange.getBoundingClientRect.bind(domRange);
      var voidOffset = 0;
      var voidIsVisible = false;
      try {
        var block = _portableTextEditor.PortableTextEditor.focusBlock(editor);
        var blockType = _portableTextEditor.PortableTextEditor.getPortableTextFeatures(editor).types.block;
        var isVoid = block._type !== blockType.name;
        if (block && isVoid && scrollElement) {
          var element = _portableTextEditor.PortableTextEditor.findDOMNode(editor, block);
          var boundingRect = element.getBoundingClientRect();
          voidOffset = boundingRect.height;
          // Get container properties
          var cTop = scrollElement.scrollTop;
          var cBottom = cTop + scrollElement.clientHeight;
          // Get element properties
          var eTop = element.offsetTop;
          var eBottom = eTop + element.clientHeight;
          // Check if in view
          var isTotal = eTop >= cTop && eBottom <= cBottom;
          var isPartial = eTop < cTop && eBottom > cTop || eBottom > cBottom && eTop < cBottom;
          voidIsVisible = isTotal || isPartial;
        }
      } catch (err) {
        // Nothing
      }
      (0, _scrollIntoViewIfNeeded.default)(leafEl, {
        scrollMode: 'if-needed',
        behavior: actions => {
          if (voidIsVisible) {
            return;
          }
          actions.forEach(_ref => {
            var el = _ref.el,
              top = _ref.top,
              left = _ref.left;
            el.scrollTop = top - (voidOffset ? voidOffset + 5 : 0);
            el.scrollLeft = left;
          });
        },
        boundary: scrollElement,
        block: voidOffset ? 'start' : 'center',
        inline: 'nearest'
      });

      // restore original method
      leafEl.getBoundingClientRect = originalGetBoundingClientRect;
    }
  }, [scrollElement]);
}
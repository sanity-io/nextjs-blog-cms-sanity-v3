"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useActionGroups = useActionGroups;
exports.useActiveActionKeys = useActiveActionKeys;
exports.useActiveStyleKeys = useActiveStyleKeys;
exports.useFeatures = useFeatures;
exports.useFocusBlock = useFocusBlock;
exports.useFocusChild = useFocusChild;
var _portableTextEditor = require("@sanity/portable-text-editor");
var _paths = require("@sanity/util/paths");
var _react = require("react");
var _useUnique = require("../utils/useUnique");
var _helpers = require("./helpers");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function useFocusBlock() {
  var editor = (0, _portableTextEditor.usePortableTextEditor)();
  var selection = (0, _portableTextEditor.usePortableTextEditorSelection)();

  // eslint-disable-next-line react-hooks/exhaustive-deps
  return (0, _react.useMemo)(() => _portableTextEditor.PortableTextEditor.focusBlock(editor), [editor, selection]); // selection must be an additional dep here
}

function useFocusChild() {
  var editor = (0, _portableTextEditor.usePortableTextEditor)();
  var selection = (0, _portableTextEditor.usePortableTextEditorSelection)();

  // eslint-disable-next-line react-hooks/exhaustive-deps
  return (0, _react.useMemo)(() => _portableTextEditor.PortableTextEditor.focusChild(editor), [editor, selection]); // selection must be an additional dep here
}

function useFeatures() {
  var editor = (0, _portableTextEditor.usePortableTextEditor)();
  return (0, _react.useMemo)(() => _portableTextEditor.PortableTextEditor.getPortableTextFeatures(editor), [editor]);
}
function useActionGroups(_ref) {
  var hotkeys = _ref.hotkeys,
    onFocus = _ref.onFocus,
    resolveInitialValue = _ref.resolveInitialValue,
    disabled = _ref.disabled;
  var editor = (0, _portableTextEditor.usePortableTextEditor)();
  var handleInsertAnnotation = (0, _react.useCallback)( /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(function* (type) {
      var initialValue = yield resolveInitialValue(type);
      var paths = _portableTextEditor.PortableTextEditor.addAnnotation(editor, type, initialValue);
      if (paths && paths.markDefPath) {
        _portableTextEditor.PortableTextEditor.blur(editor);
        onFocus(paths.markDefPath.concat(_paths.FOCUS_TERMINATOR));
      }
    });
    return function (_x) {
      return _ref2.apply(this, arguments);
    };
  }(), [editor, onFocus, resolveInitialValue]);
  return (0, _react.useMemo)(() => editor ? (0, _helpers.getPTEToolbarActionGroups)(editor, disabled, handleInsertAnnotation, hotkeys) : [], [disabled, editor, handleInsertAnnotation, hotkeys]);
}
function useActiveActionKeys(_ref3) {
  var actions = _ref3.actions;
  var editor = (0, _portableTextEditor.usePortableTextEditor)();
  var selection = (0, _portableTextEditor.usePortableTextEditorSelection)();
  return (0, _useUnique.useUnique)((0, _react.useMemo)(() => {
    var activeAnnotationKeys = _portableTextEditor.PortableTextEditor.activeAnnotations(editor).map(a => a._type);
    return actions.filter(a => {
      if (a.type === 'annotation') {
        return activeAnnotationKeys.includes(a.key);
      }
      if (a.type === 'listStyle') {
        return _portableTextEditor.PortableTextEditor.hasListStyle(editor, a.key);
      }
      return _portableTextEditor.PortableTextEditor.isMarkActive(editor, a.key);
    }).map(a => a.key);
  },
  // eslint-disable-next-line react-hooks/exhaustive-deps
  [editor,
  // This is needed so that active actions update as `selection` changes
  selection]));
}
function useActiveStyleKeys(_ref4) {
  var items = _ref4.items;
  var editor = (0, _portableTextEditor.usePortableTextEditor)();
  var focusBlock = useFocusBlock();
  var selection = (0, _portableTextEditor.usePortableTextEditorSelection)();
  return (0, _useUnique.useUnique)((0, _react.useMemo)(() => items.filter(i => _portableTextEditor.PortableTextEditor.hasBlockStyle(editor, i.style)).map(i => i.style),
  //  eslint-disable-next-line react-hooks/exhaustive-deps
  [focusBlock,
  // This is needed so that active styles update as `selection` changes
  selection]));
}